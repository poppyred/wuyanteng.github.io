<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Codis3.2.0集群部署 | Gary Wu | 运维架构师 - 从入门到放弃</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="zookeeper,高级运维,codis,codis集群,memcache,redis">
    <meta name="description" content="codis介绍  codis是一个分布式redis集群解决方案，对于上层的应用来说, 连接到codis-proxy和连接原生的redis-server没有明显的区别。  上层应用可以像使用单机的redis一样使用，codis底层会处理请求的转发，不停机的数据迁移等工作。所有后边的一切事情，对于前面的客户端来说是透明的，可以简单的认为后边连接的是一个内存无限大的redis服务。">
<meta name="keywords" content="zookeeper,高级运维,codis,codis集群,memcache,redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Codis3.2.0集群部署">
<meta property="og:url" content="https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/index.html">
<meta property="og:site_name" content="Gary Wu">
<meta property="og:description" content="codis介绍  codis是一个分布式redis集群解决方案，对于上层的应用来说, 连接到codis-proxy和连接原生的redis-server没有明显的区别。  上层应用可以像使用单机的redis一样使用，codis底层会处理请求的转发，不停机的数据迁移等工作。所有后边的一切事情，对于前面的客户端来说是透明的，可以简单的认为后边连接的是一个内存无限大的redis服务。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis%E5%AE%9E%E6%96%BD%E6%8B%93%E6%89%91.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/%E6%B7%BB%E5%8A%A0Group.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/3Group.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis-red.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/slots.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/slot_end.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/Codis_Dashboard.png">
<meta property="og:updated_time" content="2017-11-30T10:25:35.670Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Codis3.2.0集群部署">
<meta name="twitter:description" content="codis介绍  codis是一个分布式redis集群解决方案，对于上层的应用来说, 连接到codis-proxy和连接原生的redis-server没有明显的区别。  上层应用可以像使用单机的redis一样使用，codis底层会处理请求的转发，不停机的数据迁移等工作。所有后边的一切事情，对于前面的客户端来说是透明的，可以简单的认为后边连接的是一个内存无限大的redis服务。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis.png">
    
    <link rel="shortcut icon" href="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/bingchuan.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/touxiang.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Gary Wu</h5>
          <a href="mailto:wuyanteng@foxmail.com" title="wuyanteng@foxmail.com" class="mail">wuyanteng@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                所有文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/高级运维"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wuyanteng" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.sslforfree.com" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                Free SSL
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Codis3.2.0集群部署</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入关键字来检索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Codis3.2.0集群部署</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-11-28T07:35:54.000Z" itemprop="datePublished" class="page-time">
  2017-11-28
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#codis集群部署实战"><span class="post-toc-number">1.</span> <span class="post-toc-text">codis集群部署实战</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#安装zookeeper-41-42-43服务器配置"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">安装zookeeper-[41/42/43服务器配置]</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#安装go环境-除了zk服务器之外都安装"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">安装go环境-[除了zk服务器之外都安装]</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#安装codis-除了zk服务器之外都安装"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">安装codis-[除了zk服务器之外都安装]</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#集群配置前需要了解的问题"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">集群配置前需要了解的问题</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#集群配置"><span class="post-toc-number">2.</span> <span class="post-toc-text">集群配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#配置dashboard-在10-0-10-40上配置"><span class="post-toc-number">2.0.1.</span> <span class="post-toc-text">配置dashboard(在10.0.10.40上配置)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#配置codis-proxy-在10-0-10-44和45服务器配置"><span class="post-toc-number">2.0.2.</span> <span class="post-toc-text">配置codis-proxy(在10.0.10.44和45服务器配置)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#配置codis-server-需要在10-0-10-47-48-49上操作"><span class="post-toc-number">2.0.3.</span> <span class="post-toc-text">配置codis-server-[需要在10.0.10.47/48/49上操作]</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#启动codis-fe-在10-0-10-40上操作"><span class="post-toc-number">2.0.4.</span> <span class="post-toc-text">启动codis-fe-[在10.0.10.40上操作]</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#codis-fe面板操作"><span class="post-toc-number">3.</span> <span class="post-toc-text">codis-fe面板操作</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#用codis-proxy代理-压力测试"><span class="post-toc-number">4.</span> <span class="post-toc-text">用codis-proxy代理-压力测试</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#代理HA"><span class="post-toc-number">5.</span> <span class="post-toc-text">代理HA</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#上层代理HA使用LVS-keepalived来实现-使用zk集群中的41和42服务器来测试"><span class="post-toc-number">5.0.1.</span> <span class="post-toc-text">上层代理HA使用LVS+keepalived来实现, 使用zk集群中的41和42服务器来测试</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#压力测试"><span class="post-toc-number">6.</span> <span class="post-toc-text">压力测试</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Codis3.2集群部署"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Codis3.2.0集群部署</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-11-28 15:35:54" datetime="2017-11-28T07:35:54.000Z"  itemprop="datePublished">2017-11-28</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>codis介绍</p>
</blockquote>
<pre><code>codis是一个分布式redis集群解决方案，对于上层的应用来说, 连接到codis-proxy和连接原生的redis-server没有明显的区别。

上层应用可以像使用单机的redis一样使用，codis底层会处理请求的转发，不停机的数据迁移等工作。所有后边的一切事情，对于前面的客户端来说是透明的，可以简单的认为后边连接的是一个内存无限大的redis服务。
</code></pre><a id="more"></a>
<blockquote>
<p>codis体系结构</p>
</blockquote>
<pre><code>Codis引入了Group的概念，每个Group包括1个Redis Master及至少1个Redis Slave，这是和Twemproxy的区别之一。这样做的好处是，如果当前Master有问题，则运维人员可通过Dashboard“自助式”切换到Slave，而不需要小心翼翼地修改程序配置文件。

为支持数据热迁移（Auto Rebalance），出品方修改了Redis Server源码，并称之为Codis Server。

Codis采用预先分片（Pre-Sharding）机制，事先规定好了，分成1024个slots（也就是说，最多能支持后端1024个Codis Server），这些路由信息保存在ZooKeeper中。

ZooKeeper还维护Codis Server Group信息，并提供分布式锁等服务。
</code></pre><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis.png" alt="codis" title="">
                </div>
                <div class="image-caption">codis</div>
            </figure>
<blockquote>
<p>Codis 3.x 由以下组件组成：</p>
</blockquote>
<ul>
<li><strong>Codis Server</strong>：基于 redis-3.2.8 分支开发。增加了额外的数据结构，以支持 slot 有关的操作以及数据迁移指令。具体的修改可以参考文档 <a href="https://github.com/CodisLabs/codis/blob/release3.2/doc/redis_change_zh.md" target="_blank" rel="noopener">redis 的修改</a>。</li>
<li><strong>Codis Proxy</strong>：客户端连接的 Redis 代理服务, 实现了 Redis 协议。 除部分命令不支持以外(<a href="https://github.com/CodisLabs/codis/blob/release3.2/doc/unsupported_cmds.md" target="_blank" rel="noopener">不支持的命令列表</a>)，表现的和原生的 Redis 没有区别（就像 Twemproxy）。<ul>
<li>对于同一个业务集群而言，可以同时部署多个 codis-proxy 实例；</li>
<li>不同 codis-proxy 之间由 codis-dashboard 保证状态同步。</li>
</ul>
</li>
<li><strong>Codis Dashboard</strong>：集群管理工具，支持 codis-proxy、codis-server 的添加、删除，以及据迁移等操作。在集群状态发生改变时，codis-dashboard 维护集群下所有 codis-proxy 的状态的一致性。<ul>
<li>对于同一个业务集群而言，同一个时刻 codis-dashboard 只能有 0个或者1个；</li>
<li>所有对集群的修改都必须通过 codis-dashboard 完成。</li>
</ul>
</li>
<li><strong>Codis Admin</strong>：集群管理的命令行工具。<ul>
<li>可用于控制 codis-proxy、codis-dashboard 状态以及访问外部存储。</li>
</ul>
</li>
<li><strong>Codis FE</strong>：集群管理界面。<ul>
<li>多个集群实例共享可以共享同一个前端展示页面；</li>
<li>通过配置文件管理后端 codis-dashboard 列表，配置文件可自动更新。</li>
</ul>
</li>
<li><strong>Storage</strong>：为集群状态提供外部存储。<ul>
<li>提供 Namespace 概念，不同集群的会按照不同 product name 进行组织；</li>
<li>目前仅提供了 Zookeeper、Etcd、Fs 三种实现，但是提供了抽象的 interface 可自行扩展。</li>
</ul>
</li>
</ul>
<blockquote>
<p>重要概念</p>
</blockquote>
<p>关于多产品线部署</p>
<pre><code>很多朋友问我们如果有多个项目时，codis 如何部署比较好，我们
当时在豌豆荚的时候，一个产品线会部署一整套codis，但是zk 共用一个，不同的codis 集
群拥有不同的product name 来区分，codis 本身的设计没有命名空间那么一说，一个codis 只
能对应一个product name。不同product name 的codis 集群在同一个zk 上不会相互干扰。
</code></pre><p>关于zookeeper</p>
<pre><code>由于Codis 是一个强依赖的zk 的项目，而且在proxy 和zk 的连接发生抖动造
成sessionexpired 的时候，proxy 是不能对外提供服务的，所以尽量保证proxy 和zk 部署在
同一个机房。生产环境中zk 一定要是&gt;=3 台的奇数台机器，建议5 台物理机。
</code></pre><p>关于HA高可用</p>
<pre><code>这里的HA 分成两部分:
一个是proxy 层的HA，还有底层Redis 的HA。先说proxy 层的HA。之前提到过proxy 本身是无状态的，所以proxy 本身的HA 是比较好做的，因为连接到任何一个活着的proxy 上都是一样的，在生产环境中，我们使用的是jedis，这个是我们开发的一个jedis 连接池，很简单，就是监听zk 上面的存活proxy 列表，挨个返回jedis 对象，达到负载均衡和HA 的效果。也有朋友在生产环境中使用LVS 和HA Proxy来做负载均衡，这也是可以的。 

Redis 本身的HA，这里的Redis 指的是codis 底层的各个server group 的master，在一开始的时候codis 本来就没有将这部分的HA 设计进去，因为Redis 在挂掉后，如果直接将slave 提升上来的话，可能会造成数据不一致的情况，因为有新的修改可能在master 中还没有同步到slave 上，这种情况下需要管理员手动的操作修复数据。后来我们发现这个需求确实比较多的朋友反映，于是我们开发了一个简单的ha 工具：codis-ha，用于监控各个server group 的master 的存活情况，如果某个master 挂掉了，会直接提升该group 的一个slave 成为新的master。 

项目的地址是：https://github.com/ngaut/codisha
</code></pre><p>关于dashboard</p>
<pre><code>dashboard 在codis 中是一个很重要的角色，所有的集群信息变更操作都是通过dashboard 发起的（这个设计有点像docker），dashboard 对外暴露了一系列RESTfulAPI 接口，不管是web 管理工具，还是命令行工具都是通过访问这些httpapi 来进行操作的，所以请保证dashboard 和其他各个组件的网络连通性。
比如，经常发现有用户的dashboard 中集群的ops 为0，就是因为dashboard 无法连接到proxy 的机器的缘故。
</code></pre><p>关于主从和bgsave</p>
<pre><code>bgsave：codis 本身并不负责维护Redis 的主从关系，在codis 里面的master和slave 只是概念上的：proxy 会将请求打到「master」上，master 挂了codis-ha 会将某一个「slave」提升成master。而真正的主从复制，需要在启动底层的Redis 时手动的配置。在生产环境中，我建议master 的机器不要开bgsave，也不要轻易的执行save 命令，数据的备份尽量放在slave 上操作。
</code></pre><p>关于跨机房/多活</p>
<pre><code>想都别想codis 没有多副本的概念，而且codis 多用于缓存的业务场景，业务的压力是直接打到缓存上的，在这层做跨机房架构的话，性能和一致性是很难得到保证的
</code></pre><blockquote>
<p>重要Q&amp;A</p>
</blockquote>
<p>Q1: codis没有多副本概念？</p>
<pre><code>Codis 是一个分布式Redis 解决方案，是通过presharding 把数据在概念上分成1024 个slot，然后通过proxy 将不同的key的请求转发到不同的机器上，数据的副本还是通过Redis本身保证。
</code></pre><p>Q2：Codis 的信息在一个zk 里面存储着，zk 在Codis 中还有别的作用吗？主从切换为何不<br>用sentinel？</p>
<pre><code>Codis 的特点是动态的扩容缩容，对业务透明；zk 除了存储路由信息，同时还作为一个事件同步的媒介服务，比如变更master 或者数据迁移这样的事情，需要所有的proxy 通过监听特定zk 事件来实现。可以说zk 被我们当做了一个可靠的rpc 的信道来使用。因为只有集群变更的admin 时候会往zk 上发事件，proxy 监听到以后，回复在zk 上，admin 收到各个proxy 的回复后才继续。本身集群变更的事情不会经常发生，所以数据量不大。Redis 的主从切换是通过codis-ha 在zk 上遍历各个server group 的master 判断存活情况，来决定是否发起提升新master 的命令。
</code></pre><p>Q3: 数据分片，是用的一致性hash 吗</p>
<pre><code>不是，是通过presharding，hash 算法是crc32(key)%1024
</code></pre><p>Q4：Redis 跨机房有什么方案？</p>
<pre><code>目前没有好的办法，我们的Codis 定位是同一个机房内部的缓存服务，跨机房复制对于
Redis 这样的服务来说，一是延迟较大，二是一致性难以保证，对于性能要求比较高的缓存
服务，我觉得跨机房不是好的选择。
</code></pre><p>Q5：集群的主从怎么做（比如集群S 是集群M 的从）？</p>
<pre><code>Codis 只是一个proxy-based 的中间件，并不负责数据副本相关的工作。也就是数据只
有一份，在Redis 内部。
</code></pre><p>Q6: codis的设计初衷与特点在何处？</p>
<pre><code>Codis更多的是为了替换twemproxy的一个项目。Redis 是cache，Codis 主要解决的是Redis单点和水平扩展的问题
</code></pre><p>Q7：可否介绍下codis 的autorebalance(自动再平衡) 实现？</p>
<pre><code>算法比较简单。其实就是根据各个实例的内存比例，分配slot.


实现：自动再平衡（auto rebalance）
Codis 支持动态的根据实例内存，自动对slot进行迁移，以均衡数据分布

命令：bin/codis-config slot rebalance

要求:
所有的codis-server都必须设置了maxmemory参数；
所有的 slots 都应该处于 online 状态, 即没有迁移任务正在执行；
所有 server group 都必须有 Master；
</code></pre><p>Q8: 主要想了解对降低数据迁移对线上服务的影响?</p>
<pre><code>其实现在codis 数据迁移的方式已经很温和了，是一个个key 的原子迁移，如果怕抖动甚至可以加上每个key 的延迟时间。这个好处就是对业务基本没感知，但是缺点就是慢。
</code></pre><!-- more -->
<h2 id="codis集群部署实战"><a href="#codis集群部署实战" class="headerlink" title="codis集群部署实战"></a>codis集群部署实战</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis%E5%AE%9E%E6%96%BD%E6%8B%93%E6%89%91.png" alt="codis拓扑" title="">
                </div>
                <div class="image-caption">codis拓扑</div>
            </figure>
<!-- more -->
<blockquote>
<p>角色说明</p>
</blockquote>
<pre><code>zookeeper集群：
10.0.10.41
10.0.10.42
10.0.10.43

condis-server(非原生redis,每台机器俩进程,如下):
10.0.10.47:6379(主)  10.0.10.48:6380(从)  
10.0.10.48:6379(主)  10.0.10.49:6380(从) 
10.0.10.49:6379(主)  10.0.10.47:6380(从) 

codis-dashboard    + codis-fe
10.0.10.40

codis-proxy + nginx-tcp  lvs:
10.0.10.44  
10.0.10.45
</code></pre><h4 id="安装zookeeper-41-42-43服务器配置"><a href="#安装zookeeper-41-42-43服务器配置" class="headerlink" title="安装zookeeper-[41/42/43服务器配置]"></a>安装zookeeper-[41/42/43服务器配置]</h4><p>快速移步查看：<a href="https://wuyanteng.github.io/2017/11/28/zookeeper%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/#more">zookeeper集群部署</a></p>
<pre><code>作用：用于存放数据路由表。 
zookeeper简称zk。在生产环境中，zk部署越多，其可靠性越高。由于zk集群是以宕机个数过半才会让整个集群宕机，因此，奇数个zk更佳。
</code></pre><h4 id="安装go环境-除了zk服务器之外都安装"><a href="#安装go环境-除了zk服务器之外都安装" class="headerlink" title="安装go环境-[除了zk服务器之外都安装]"></a>安装go环境-[除了zk服务器之外都安装]</h4><blockquote>
<p>安装依赖</p>
</blockquote>
<pre><code>yum install -y git gcc make g++ gcc-c++ automake openssl-devel zlib-*
</code></pre><blockquote>
<p>安装go</p>
</blockquote>
<pre><code>下载地址：
wget https://mirrors.nju.edu.cn/golang/go1.7.6.linux-amd64.tar.gz

解压到/usr/local
tar -xf go1.7.6.linux-amd64.tar.gz  -C /usr/local 

把go加入到系统的环境变量
cat &gt;&gt;/etc/profile &lt;&lt; EOF
export PATH=$PATH:/usr/local/go/bin
export GOPATH=/usr/local/
EOF

source /etc/profile

[root@localhost local]# env |grep go
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/go/bin
[root@localhost local]# go version
go version go1.7.6 linux/amd64
</code></pre><h4 id="安装codis-除了zk服务器之外都安装"><a href="#安装codis-除了zk服务器之外都安装" class="headerlink" title="安装codis-[除了zk服务器之外都安装]"></a>安装codis-[除了zk服务器之外都安装]</h4><pre><code>https://codeload.github.com/CodisLabs/codis/tar.gz/3.2.0
mkdir -p /usr/local/src/github.com/CodisLabs/
tar -zxvf /root/codis-3.2.0.tar.gz -C /usr/local/src/github.com/CodisLabs/
cd /usr/local/src/github.com/CodisLabs/
mv codis-3.2.0 codis
cd codis &amp;&amp; make
./bin/redis-cli -v
ln -s /usr/local/src/github.com/CodisLabs/   /usr/local/

[root@localhost codis]# cat bin/version
version = unknown version
compile = 2017-11-29 04:56:00 -0500 by go version go1.7.6 linux/amd64
</code></pre><!-- more -->
<h4 id="集群配置前需要了解的问题"><a href="#集群配置前需要了解的问题" class="headerlink" title="集群配置前需要了解的问题"></a>集群配置前需要了解的问题</h4><p>集群分片主要分三种：</p>
<pre><code>客户端分片：这个需要自己开发，对客户端要求严格，集群很难扩容
代理端分片：如codis，对客户端几乎无要求，集群容易扩容
服务端分片：如redis集群，需要智能客户端支持集群协议的，集群容易扩容
</code></pre><p>codis3.2集群架构</p>
<pre><code>codis3.2集群架构

服务端：codis-fe------codis-dashboard------codis-proxy------codis-group------codis-server
客户端：client------nginx-tcp------codis-proxy
cdis-fe可以管理多个codis-dashboard

每个codis-dashboard代表一个产品线，每个codis-dashboard可以管理多个codis-proxy
每个codis-proxy可以管理多个codis-server group
每个codis-server group至少由两个codis-server组成，最少1主1备

由上可知一个大的codis集群可以分多个产品线，客户端连接各个产品线的codis-proxy，业务线之间可以做到物理隔离，比如group1，group2，group3分给codis-product1业务线，group4，group5，group6分给codis-product2业务线，codis-dashboard配置保存在zookeeper里。
</code></pre><p>特别注意</p>
<pre><code>同一个codis-server可以加入多个codis-dashboard的codis-group里，但是在不同的codis-dashboard里面主备的角色要一致，这代表逻辑隔离。

同一个codis-server只加入唯一的codis-dashboard的codis-group里，这代表物理隔离。
</code></pre><!-- more -->
<h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>重申下基本操作目录</p>
<pre><code>Codis软链目录：/usr/local/codis
Codis实际安装目录：/usr/local/src/github.com/CodisLabs/codis
</code></pre><h4 id="配置dashboard-在10-0-10-40上配置"><a href="#配置dashboard-在10-0-10-40上配置" class="headerlink" title="配置dashboard(在10.0.10.40上配置)"></a>配置dashboard(在10.0.10.40上配置)</h4><blockquote>
<p>配置并启动codis-dashboard</p>
</blockquote>
<p>修改dashboard配置文件</p>
<pre><code>cd /usr/local/codis
cat config/dashboard.toml 结果如下：
</code></pre><pre><code>[root@localhost codis]# egrep -v &quot;^#|^$&quot; config/dashboard.toml   #主要修改以下几项内容
coordinator_name = &quot;zookeeper&quot;
coordinator_addr = &quot;10.0.10.41:2181,10.0.10.42:2181,10.0.10.43:2181&quot;
product_name = &quot;codis-product1&quot;
product_auth = &quot;&quot;
admin_addr = &quot;0.0.0.0:18080&quot;
</code></pre><p>修改启动脚本并启动服务</p>
<pre><code>修改zookeeper地址池与product名称
egrep -v &quot;^#|^$&quot; admin/codis-dashboard-admin.sh
搜索并修改成如下配置：
CODIS_ADMIN_TOOL_BIN -v --remove-lock --product=codis-product1 --zookeeper=10.0.10.41:2181,10.0.10.42:2181,10.0.10.43:2181
</code></pre><pre><code>启动codis-dashboard
cd /usr/local/codis/admin/ &amp;&amp; ./codis-dashboard-admin.sh start

#查看codis-dashboard端口
netstat -tulpn |grep codis-dashboa
tcp    LISTEN     0      128      :::18080                :::*                   users:((&quot;codis-dashboard&quot;,pid=18245,fd=5))

#查看日志
tailf /usr/local/codis/log/codis-dashboard.log.2017-11-29
出现“2017/11/29 05:32:30 main.go:140: [WARN] [0xc4202d78c0] dashboard is working ...”说明启动成功。

#检查服务
http://10.0.10.40:18080/topom       #可以正常访问到相关配置数据
</code></pre><h4 id="配置codis-proxy-在10-0-10-44和45服务器配置"><a href="#配置codis-proxy-在10-0-10-44和45服务器配置" class="headerlink" title="配置codis-proxy(在10.0.10.44和45服务器配置)"></a>配置codis-proxy(在10.0.10.44和45服务器配置)</h4><blockquote>
<p>修改codis-proxy启动脚本</p>
</blockquote>
<pre><code>cd /usr/local/codis

搜索并修改“CODIS_DASHBOARD_ADDR”值，如下：
[root@localhost codis]# cat admin/codis-proxy-admin.sh|grep DASH
CODIS_DASHBOARD_ADDR=&quot;10.0.10.40:18080&quot;
</code></pre><blockquote>
<p>修改proxy.toml配置</p>
</blockquote>
<pre><code>[root@localhost codis]# cat config/proxy.toml|grep -Ev &quot;^#|^$&quot;
product_name = &quot;codis-product1&quot;    #修改product_name名称为刚才定义的codis-product1
product_auth = &quot;&quot;
session_auth = &quot;&quot;
admin_addr = &quot;0.0.0.0:11080&quot;
proto_type = &quot;tcp4&quot;
proxy_addr = &quot;0.0.0.0:19000&quot;
</code></pre><blockquote>
<p>启动codis-proxy</p>
</blockquote>
<pre><code>[root@localhost codis]# ./admin/codis-proxy-admin.sh start
./admin/codis-proxy-admin.sh: line 20: ODIS_DASHBOARD_ADDR: command not found
/usr/local/codis/admin/../config/proxy.toml
starting codis-proxy ... 
</code></pre><p>检查日志和端口</p>
<pre><code>[root@localhost codis]# cat log/codis-proxy.log.2017-11-29

2017/11/29 06:39:14 main.go:323: [WARN] rpc online proxy seems OK
2017/11/29 06:39:14 main.go:213: [WARN] [0xc4201584d0] proxy is working ...
</code></pre><pre><code>[root@localhost codis]# ss  -tulpn|grep codis-proxy
tcp    LISTEN     0  128   *:19000  *:*   users:((&quot;codis-proxy&quot;,pid=17985,fd=5))
tcp    LISTEN     0  128   :::11080  :::*  users:((&quot;codis-proxy&quot;,pid=17985,fd=6))
</code></pre><h4 id="配置codis-server-需要在10-0-10-47-48-49上操作"><a href="#配置codis-server-需要在10-0-10-47-48-49上操作" class="headerlink" title="配置codis-server-[需要在10.0.10.47/48/49上操作]"></a>配置codis-server-[需要在10.0.10.47/48/49上操作]</h4><pre><code>codis-server规划：
10.0.10.47:6379(主)  10.0.10.48:6380(从)  
10.0.10.48:6379(主)  10.0.10.49:6380(从) 
10.0.10.49:6379(主)  10.0.10.47:6380(从) 
</code></pre><blockquote>
<p>修改codis-server启动脚本</p>
</blockquote>
<pre><code>cd /usr/local/codis/

复制并修改脚本
cp admin/codis-server-admin.sh  admin/codis-server-admin-6379.sh 
cp admin/codis-server-admin.sh  admin/codis-server-admin-6380.sh
vim admin/codis-server-admin-6379.sh 
vim admin/codis-server-admin-6380.sh
</code></pre><pre><code>vim admin/codis-server-admin-6379.sh

主要修改如下几点：
CODIS_SERVER_PID_FILE=/var/run/redis_6379.pid
CODIS_SERVER_LOG_FILE=/var/log/redis_6379.log
CODIS_SERVER_CONF_FILE=/etc/redis/6379/redis-6379.conf
</code></pre><pre><code>vim admin/codis-server-admin-6380.sh

主要修改如下几点：
CODIS_SERVER_PID_FILE=/var/run/redis_6380.pid
CODIS_SERVER_LOG_FILE=/var/log/redis_6380.log
CODIS_SERVER_CONF_FILE=/etc/redis/6380/redis-6380.conf
</code></pre><blockquote>
<p>修改服务配置</p>
</blockquote>
<pre><code>创建redis配置文件存放目录
[root@localhost codis]# mkdir /etc/redis/6379 -p
[root@localhost codis]# mkdir /etc/redis/6380 -p

创建redis RDB缓存文件的存放目录
[root@localhost codis]# mkdir /data/redis/6379 -p
[root@localhost codis]# mkdir /data/redis/6380 -p
</code></pre><pre><code>拷贝默认redis配置文件
[root@localhost codis]# cp config/redis.conf /etc/redis/6379/redis-6379.conf
[root@localhost codis]# cp config/redis.conf /etc/redis/6380/redis-6380.conf
</code></pre><pre><code>编辑配置文件(注：每个配置文件独立配置，因为3个redis从节点的slaveof配置不同)

下面的主从关系有点绕，理顺了其实很简单。
</code></pre><blockquote>
<p>47服务器-redis配置文件</p>
</blockquote>
<p>10.0.10.47（主）redis-6379.conf</p>
<pre><code>vim  /etc/redis/6379/redis-6379.conf    #配置主文件

bind 10.0.10.47
port 6379
tcp-keepalive 300
daemonize yes
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &quot;/var/run/redis_6379.log&quot;
databases 16
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data/redis/6379
</code></pre><p>10.0.10.48（从）redis-6380.conf</p>
<pre><code>vim  /etc/redis/6379/redis-6380.conf    #配置主文件

bind 10.0.10.47
port 6380
tcp-keepalive 300
daemonize yes
pidfile /var/run/redis_6380.pid
loglevel notice
logfile &quot;/var/run/redis_6380.log&quot;
databases 16
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data/redis/6380
slaveof 10.0.10.48 6379
slave-serve-stale-data yes
</code></pre><blockquote>
<p>48服务器-redis配置文件</p>
</blockquote>
<p>10.0.10.48的(主)redis-6379.conf</p>
<pre><code>vim  /etc/redis/6379/redis-6379.conf    #配置主文件

bind 10.0.10.48
port 6379
tcp-keepalive 300
daemonize yes
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &quot;/var/run/redis_6379.log&quot;
databases 16
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data/redis/6379
</code></pre><p>10.0.10.49（从）redis-6380.conf</p>
<pre><code>vim  /etc/redis/6379/redis-6380.conf    #配置主文件

bind 10.0.10.48
port 6380
tcp-keepalive 300
daemonize yes
pidfile /var/run/redis_6380.pid
loglevel notice
logfile &quot;/var/log/redis_6380.log&quot;
databases 16
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data/redis/6380
slaveof 10.0.10.49 6379
slave-serve-stale-data yes
</code></pre><blockquote>
<p>49服务器-redis配置文件</p>
</blockquote>
<p>10.0.10.49（主）redis-6379.conf</p>
<pre><code>vim  /etc/redis/6379/redis-6379.conf    #配置主文件

bind 10.0.10.49
port 6379
tcp-keepalive 300
daemonize yes
pidfile /var/run/redis_6379.pid
loglevel notice
logfile &quot;/var/log/redis_6379.log&quot;
databases 16
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data/redis/6379
</code></pre><p>10.0.10.47（从）redis-6380.conf</p>
<pre><code>vim  /etc/redis/6379/redis-6380.conf    #配置主文件

bind 10.0.10.49
port 6380
tcp-keepalive 300
daemonize yes
pidfile /var/run/redis_6380.pid
loglevel notice
logfile &quot;/var/log/redis_6380.log&quot;
databases 16
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /data/redis/6380
slaveof 10.0.10.47 6379
slave-serve-stale-data yes
</code></pre><blockquote>
<p>分别启动47/48/49服务器的主从</p>
</blockquote>
<pre><code>[root@localhost codis]# ./admin/codis-server-admin-6379.sh start
starting codis-server ... 

[root@localhost codis]# ./admin/codis-server-admin-6380.sh start
starting codis-server ... 
</code></pre><blockquote>
<p>分别检测47/48/49服务器的日志与端口</p>
</blockquote>
<pre><code>[root@localhost codis]# ss -lntup |grep 63*
tcp    LISTEN     0  128  10.0.10.47:6379    *:*  users:((&quot;codis-server&quot;,pid=18153,fd=4))
tcp    LISTEN     0  128  10.0.10.47:6380    *:*  users:((&quot;codis-server&quot;,pid=18166,fd=4))
</code></pre><blockquote>
<p>在47服务器上连接redis 6379端口查看codis-server主从关系</p>
</blockquote>
<pre><code>[root@localhost codis]# ./bin/redis-cli -h 10.0.10.47 -p 6379
10.0.10.47:6379&gt; info
......
......
# Replication
role:master
connected_slaves:1
slave0:ip=10.0.10.49,port=6380,state=online,offset=1709,lag=1
master_repl_offset:1709
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:1708
......
......
</code></pre><h4 id="启动codis-fe-在10-0-10-40上操作"><a href="#启动codis-fe-在10-0-10-40上操作" class="headerlink" title="启动codis-fe-[在10.0.10.40上操作]"></a>启动codis-fe-[在10.0.10.40上操作]</h4><pre><code>cd /usr/local/codis/
vim admin/codis-fe-admin.sh  #主要修改以下几行
</code></pre><pre><code>#COORDINATOR_NAME=&quot;filesystem&quot;
#COORDINATOR_ADDR=&quot;/tmp/codis&quot;
CODIS_FE_ADDR=&quot;0.0.0.0:9090&quot;
COORDINATOR_NAME=&quot;zookeeper&quot;
COORDINATOR_ADDR=&quot;10.0.10.41:2181,10.0.10.42:2181,10.0.10.43:2181&quot;
</code></pre><blockquote>
<p>启动codis-fe脚本</p>
</blockquote>
<pre><code>./admin/codis-fe-admin.sh start
</code></pre><blockquote>
<p>检查日志与端口</p>
</blockquote>
<pre><code>[root@localhost codis]# ss -lntup |grep 9090
tcp    LISTEN     0      128      :::9090   :::*   users:((&quot;codis-fe&quot;,pid=18409,fd=6))

[root@localhost codis]# tailf log/codis-fe.log.2017-11-29
2017/11/29 08:19:23 zkclient.go:23: [INFO] zookeeper - zkclient setup new connection to 10.0.10.41:2181,10.0.10.42:2181,10.0.10.43:2181
2017/11/29 08:19:23 main.go:209: [WARN] option --pidfile = /usr/local/codis/bin/codis-fe.pid
2017/11/29 08:19:23 zkclient.go:23: [INFO] zookeeper - Re-submitting `0` credentials after reconnect
</code></pre><blockquote>
<p>访问codis-fe Web面板</p>
</blockquote>
<pre><code>http://10.0.10.40:9090/#codis-product1
</code></pre><!-- more -->
<h2 id="codis-fe面板操作"><a href="#codis-fe面板操作" class="headerlink" title="codis-fe面板操作"></a>codis-fe面板操作</h2><blockquote>
<p>通过codis-fe添加group</p>
</blockquote>
<pre><code>通过web浏览器访问集群管理页面(fe地址:http://192.168.188.125:9090/#codis-product1) 选择我们刚搭建的集群 codis-product1，在 Proxy 栏可看到我们已经启动的 Proxy， 但是Group 栏为空，因为我们启动的 codis-server 并未加入到集群.
</code></pre><blockquote>
<p>添加 NEW GROUP</p>
</blockquote>
<pre><code>NEW GROUP 行输入 1，再点击 NEW GROUP 即可。如图：
</code></pre><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/%E6%B7%BB%E5%8A%A0Group.png" alt="添加Group" title="">
                </div>
                <div class="image-caption">添加Group</div>
            </figure>
<pre><code>根据我们的拓扑规划，需要依次添加3个group , 6个codis-server 。默认每组里面第一个添加的为主，第二个添加的设置为从，同一个节点2个实例不能设置为同一group。 如图：
</code></pre><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/3Group.png" alt="3_Group" title="">
                </div>
                <div class="image-caption">3_Group</div>
            </figure>
<p>消除界面中的从condis-server的背景颜色,如图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/codis-red.png" alt="codis-red" title="">
                </div>
                <div class="image-caption">codis-red</div>
            </figure>
<blockquote>
<p>通过codis-fe初始化solt</p>
</blockquote>
<pre><code>新增的集群 slot 状态是 offline，因此我们需要对它进行初始化（将 1024 个 slot 分配到各个 group），而初始化最快的方法可通过fe提供的 rebalance all slots 按钮来做。

自动分配1024个solt到3个group，点击“reblance all solts”按钮会自动分配完所有solt到3个group。如下图：
</code></pre><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/slots.png" alt="slot分配" title="">
                </div>
                <div class="image-caption">slot分配</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/slot_end.png" alt="slot分配完成" title="">
                </div>
                <div class="image-caption">slot分配完成</div>
            </figure>
<h2 id="用codis-proxy代理-压力测试"><a href="#用codis-proxy代理-压力测试" class="headerlink" title="用codis-proxy代理-压力测试"></a>用codis-proxy代理-压力测试</h2><pre><code>上面我们已经配置好了2个codis-proxy，接下来使用它们其一对部署的集群进行压力测试

在其中一台codis-server上使用redis-benchmark命令进行测试。命令如下：
cd /usr/loca/codis
./bin/redis-benchmark -h 10.0.10.44 -p 19000 -q -n 1000000  -c 20  -d 100k
</code></pre><pre><code>命令行执行结果：
[root@localhost codis]# ./bin/redis-benchmark -h 10.0.10.44 -p 19000 -q -n 1000000  -c 20  -d 100k
PING_INLINE: 21769.42 requests per second
PING_BULK: 18310.32 requests per second
SET: 17011.14 requests per second
GET: 18086.45 requests per second
INCR: 17886.21 requests per second
LPUSH: 17146.48 requests per second
RPUSH: 17003.91 requests per second
LPOP: 17160.31 requests per second
RPOP: 17233.65 requests per second
SADD: 19542.32 
</code></pre><p>Dashboard测试效果如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/Codis_Dashboard.png" alt="Codis_Dashboard" title="">
                </div>
                <div class="image-caption">Codis_Dashboard</div>
            </figure>
<h2 id="代理HA"><a href="#代理HA" class="headerlink" title="代理HA"></a>代理HA</h2><h4 id="上层代理HA使用LVS-keepalived来实现-使用zk集群中的41和42服务器来测试"><a href="#上层代理HA使用LVS-keepalived来实现-使用zk集群中的41和42服务器来测试" class="headerlink" title="上层代理HA使用LVS+keepalived来实现, 使用zk集群中的41和42服务器来测试"></a>上层代理HA使用LVS+keepalived来实现, 使用zk集群中的41和42服务器来测试</h4><blockquote>
<p>安装ipvsadm管理工具并激活LVS</p>
</blockquote>
<pre><code>#查看lvs模块
lsmod |grep ip_vs

#默认没有加载模块，所以需要安装管理工具激活
yum -y install ipvsadm

#查看管理工具ipvsadm状态
ipvsadm

#再次查看lvs模块
lsmod |grep ip_vs
</code></pre><blockquote>
<p>安装keepalived</p>
</blockquote>
<pre><code>#安装keepalived
yum install -y keepalived
</code></pre><pre><code>#配置keepalived
vim /etc/keepalived/keepalived.conf
</code></pre><blockquote>
<p>41服务器keepalived配置文件</p>
</blockquote>
<pre><code>global_defs {
   router_id LVS_01
}
vrrp_instance VI_1 {   
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 150
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
     10.0.10.50/24
    }
}
virtual_server 10.0.10.50 19000 {
    delay_loop 6              
    lb_algo wrr                
    lb_kind DR                
    nat_mask 255.255.255.0
    persistence_timeout 50     
    protocol TCP                
    real_server 10.0.10.44 19000 {      
        weight 1              
        TCP_CHECK {
        connect_timeout 8       
        nb_get_retry 3
        delay_before_retry 3
        connect_port 19000
        }
    }
    real_server 10.0.10.45 19000 {
        weight 1              
        TCP_CHECK {
        connect_timeout 8       
        nb_get_retry 3
        delay_before_retry 3
        connect_port 19000
        }
    }
}
</code></pre><blockquote>
<p>42服务器keepalived配置文件</p>
</blockquote>
<pre><code>global_defs {
   router_id LVS_02
}
vrrp_instance VI_1 {   
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
     10.0.10.50/24
    }
}
virtual_server 10.0.10.50 19000 {
    delay_loop 6              
    lb_algo wrr                
    lb_kind DR                
    nat_mask 255.255.255.0
    persistence_timeout 50     
    protocol TCP                
    real_server 10.0.10.44 19000 {      
        weight 1              
        TCP_CHECK {
        connect_timeout 8       
        nb_get_retry 3
        delay_before_retry 3
        connect_port 19000
        }
    }
    real_server 10.0.10.45 19000 {
        weight 1              
        TCP_CHECK {
        connect_timeout 8       
        nb_get_retry 3
        delay_before_retry 3
        connect_port 19000
        }
    }
}
</code></pre><blockquote>
<p>分别启动</p>
</blockquote>
<pre><code>&gt;/etc/keepalived/keepalived.conf 
vim /etc/keepalived/keepalived.conf
systemctl start keepalived
systemctl status keepalived
</code></pre><blockquote>
<p>codis-proxy配置-【在2台lvs后端机codis-proxy上配置】</p>
</blockquote>
<pre><code>步骤1：在lo网卡绑定VIP地址（ip）
步骤2：修改内核参数抑制ARP响应
ip addr add 192.168.56.10/32 dev lo
cat &gt;&gt;/etc/sysctl.conf&lt;&lt;EOF
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
EOF
sysctl -p
</code></pre><blockquote>
<p>检查LVS集群</p>
</blockquote>
<pre><code>ipvsadm -ln
</code></pre><blockquote>
<p>最后把HA的IP和端口给研发即可</p>
</blockquote>
<pre><code>给研发正式启用前，务必进行多次压测

本测试环境中，Codis HA地址/端口为：10.0.10.50:19000
</code></pre><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><pre><code>压力测试命令：
/usr/local/codis
./bin/redis-benchmark -h HA_IP地址 -p HA_Port  -q -n 1000000  -c 20  -d 100k

如上Dashboard效果图
</code></pre>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-11-30T10:25:35.670Z" itemprop="dateUpdated">2017-11-30 18:25:35</time>
</span><br>


        
        转载文章请注明出处，否则我会竖中指的！  <br>文章永久链接：<a href="/2017/11/28/Codis3.2集群部署/" target="_blank" rel="external">https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/</a>
        
    </div>
    
    <footer>
        <a href="https://wuyanteng.github.io">
            <img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/touxiang.jpg" alt="Gary Wu">
            Gary Wu
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/codis/">codis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/codis集群/">codis集群</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高级运维/">高级运维</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/&title=《Codis3.2.0集群部署》 — Gary Wu&pic=https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/touxiang.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/&title=《Codis3.2.0集群部署》 — Gary Wu&source=
codis介绍

codis是一个分布式redis集群解决方案，对于上层的应用来说, 连接到codis-proxy和连接原生的redis-server没..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Codis3.2.0集群部署》 — Gary Wu&url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/&via=https://wuyanteng.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/12/02/shell高级编程-进阶2/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">shell高级编程-进阶2</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/11/28/zookeeper集群部署/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">zookeeper集群部署</h4>
      </a>
    </div>
  
</nav>



    














</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们不一样
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE.png" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>很惭愧，在运维不归路上，一去不复返。。。始终不忘初心！我是GaryWu</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Gary Wu &copy; 2015 - 2018</span>
            <span>
                
                <a href="https://wuyanteng.github.io" target="_blank">博客由Hexo强力驱动</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/&title=《Codis3.2.0集群部署》 — Gary Wu&pic=https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/touxiang.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/&title=《Codis3.2.0集群部署》 — Gary Wu&source=
codis介绍

codis是一个分布式redis集群解决方案，对于上层的应用来说, 连接到codis-proxy和连接原生的redis-server没..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Codis3.2.0集群部署》 — Gary Wu&url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/&via=https://wuyanteng.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://wuyanteng.github.io/2017/11/28/Codis3.2集群部署/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '经检测,你已离开...';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来...';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
