<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gary Wu</title>
  
  <subtitle>运维架构师 - 从入门到放弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyanteng.github.io/"/>
  <updated>2018-07-09T08:00:54.411Z</updated>
  <id>https://wuyanteng.github.io/</id>
  
  <author>
    <name>Gary Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mongo Slave节点无法show dbs</title>
    <link href="https://wuyanteng.github.io/2018/07/09/Mongo-Slave%E8%8A%82%E7%82%B9%E6%97%A0%E6%B3%95show-dbs/"/>
    <id>https://wuyanteng.github.io/2018/07/09/Mongo-Slave节点无法show-dbs/</id>
    <published>2018-07-09T08:00:54.000Z</published>
    <updated>2018-07-09T08:00:54.411Z</updated>
    
    <content type="html"><![CDATA[<p>在SECONDARY节点无法show dbs</p><pre><code>主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:QUERY  Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }</code></pre><a id="more"></a><p>解决方法</p><pre><code>在报错的slave机器上执行 rs.slaveOk()  再执行show dbs即可</code></pre><p>官网解释</p><pre><code>Provides a shorthand for the following operation:db.getMongo().setSlaveOk()This allows the current connection to allow read operations to run on secondary members. See the readPref() method for more fine-grained control over read preference in the mongo shell.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SECONDARY节点无法show dbs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:

QUERY  Error: listDatabases failed:{ &amp;quot;note&amp;quot; : &amp;quot;from execCommand&amp;quot;, &amp;quot;ok&amp;quot; : 0, &amp;quot;errmsg&amp;quot; : &amp;quot;not master&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="SECONDARY" scheme="https://wuyanteng.github.io/tags/SECONDARY/"/>
    
      <category term="PRIMARY" scheme="https://wuyanteng.github.io/tags/PRIMARY/"/>
    
      <category term="MongoDB" scheme="https://wuyanteng.github.io/tags/MongoDB/"/>
    
      <category term="slave" scheme="https://wuyanteng.github.io/tags/slave/"/>
    
      <category term="show dbs" scheme="https://wuyanteng.github.io/tags/show-dbs/"/>
    
  </entry>
  
  <entry>
    <title>mysql从库-只同步某些库</title>
    <link href="https://wuyanteng.github.io/2018/07/06/mysql%E4%BB%8E%E5%BA%93-%E5%8F%AA%E5%90%8C%E6%AD%A5%E6%9F%90%E4%BA%9B%E5%BA%93/"/>
    <id>https://wuyanteng.github.io/2018/07/06/mysql从库-只同步某些库/</id>
    <published>2018-07-06T09:54:12.000Z</published>
    <updated>2018-07-06T10:09:38.923Z</updated>
    
    <content type="html"><![CDATA[<pre><code>生产环境需求：从库同步时，限定只同步某些数据库，而非全部同步，如何优雅逆袭？</code></pre><p>配置</p><pre><code>vim /etc/my.cnf[mysqld]......replicate_wild_do_table=db1.%replicate_wild_do_table=db2.%replicate_wild_do_table=db3.%db1到db3是需要同步的数据库名，如果复制多个数据库，重复设置这个选项即可。</code></pre><pre><code>重启mysql</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;生产环境需求：从库同步时，限定只同步某些数据库，而非全部同步，如何优雅逆袭？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/my.cnf

[mysqld]
......
replicate_wild_do_table
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mysql从库" scheme="https://wuyanteng.github.io/tags/mysql%E4%BB%8E%E5%BA%93/"/>
    
      <category term="同步个别库" scheme="https://wuyanteng.github.io/tags/%E5%90%8C%E6%AD%A5%E4%B8%AA%E5%88%AB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump备份避免锁表</title>
    <link href="https://wuyanteng.github.io/2018/07/02/mysqldump%E5%A4%87%E4%BB%BD%E9%81%BF%E5%85%8D%E9%94%81%E8%A1%A8/"/>
    <id>https://wuyanteng.github.io/2018/07/02/mysqldump备份避免锁表/</id>
    <published>2018-07-02T04:09:26.000Z</published>
    <updated>2018-07-02T04:26:27.768Z</updated>
    
    <content type="html"><![CDATA[<pre><code>生产环境中,场景难免会遇到对正在运行的数据库进行备份，而mysqldump备份会有锁表风险，导致数据在备份期间无法写入数据，所以对正在运行的数据库备份需要慎重。下面就聊聊如何解决锁表？</code></pre><a id="more"></a><h5 id="mysqldump命令备份Mysql数据库的参数说明"><a href="#mysqldump命令备份Mysql数据库的参数说明" class="headerlink" title="mysqldump命令备份Mysql数据库的参数说明"></a>mysqldump命令备份Mysql数据库的参数说明</h5><pre><code>-q       采用快速的dump方式(提高导出性能)-e       采用多重insert语句形式(提高还原性能)-R       导出存储过程，函数，和触发器--events        如果是5.1以上的版本使用，包含事件--skip-opt      避免锁表--create-option            添加create相关的选项--single-transaction       一致性备份--no-autocommit      采用批量提交方式(提高还原性能)--master-data   如果有写log-bin且版本为5.0以上的版本，则再加上 --master-data=2</code></pre><h5 id="改良mysqldump备份命令"><a href="#改良mysqldump备份命令" class="headerlink" title="改良mysqldump备份命令"></a>改良mysqldump备份命令</h5><pre><code>我的版本是MySQL-5.7.11,启用了binlog，所以应使用如下命令备份数据库mysqldump -uroot -p --events --single-transaction --master-data=2 --skip-opt --databases db1 db2 &gt;/root/mysql.sql</code></pre><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><pre><code>mysqldump命令适用于对数据库相对较小的MySQL进行备份，一般数据量约50GB以内，大于50GB强烈建议使用xtrabackup工具。</code></pre><p>参考：<a href="https://wuyanteng.github.io/2018/01/23/MySql-xtrabackup%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/">MySql xtrabackup大数据量备份与还原</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;生产环境中,场景难免会遇到对正在运行的数据库进行备份，而mysqldump备份会有锁表风险，导致数据在备份期间无法写入数据，所以对正在运行的数据库备份需要慎重。下面就聊聊如何解决锁表？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="MySQL" scheme="https://wuyanteng.github.io/tags/MySQL/"/>
    
      <category term="xtrabackup" scheme="https://wuyanteng.github.io/tags/xtrabackup/"/>
    
      <category term="mysqldump" scheme="https://wuyanteng.github.io/tags/mysqldump/"/>
    
      <category term="innobackup" scheme="https://wuyanteng.github.io/tags/innobackup/"/>
    
      <category term="锁表" scheme="https://wuyanteng.github.io/tags/%E9%94%81%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>shell变量传参</title>
    <link href="https://wuyanteng.github.io/2018/06/22/shell%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82/"/>
    <id>https://wuyanteng.github.io/2018/06/22/shell变量传参/</id>
    <published>2018-06-22T07:54:54.000Z</published>
    <updated>2018-06-22T08:53:43.784Z</updated>
    
    <content type="html"><![CDATA[<pre><code>有时候经常会写传参脚本，下面是一个zabbix自定义key传参案例</code></pre><h5 id="zabbix配置文件"><a href="#zabbix配置文件" class="headerlink" title="zabbix配置文件"></a>zabbix配置文件</h5><pre><code>UnsafeUserParameters=1#mysql slave监控UserParameter=mysql.slave[*],/var/lib/mysql/check_mysql_slave.sh $1注：留意下这个key值，后面是*表示所有</code></pre><a id="more"></a><h5 id="自定义key传参脚本"><a href="#自定义key传参脚本" class="headerlink" title="自定义key传参脚本"></a>自定义key传参脚本</h5><pre><code>vim  check_mysql.sh</code></pre><pre><code>#!/bin/bashUSER=xxxPASS=xxxxxxio_status(){    IoStatus=`mysql -u${USER} -p${PASS} -e &quot;show slave status\G;&quot; |grep -i running|sed -n 1p|awk &#39;{print $NF}&#39;`    if [ $IoStatus == &quot;Yes&quot; ];then        IoStatus=1    else        IoStatus=0    fi    echo  $IoStatus}sql_status(){    SqlStatus=`mysql -u${USER} -p${PASS} -e &quot;show slave status\G;&quot; |grep -i running|sed -n 2p|awk &#39;{print $NF}&#39;`    if [ $SqlStatus == &quot;Yes&quot; ];then        SqlStatus=1    else        SqlStatus=0    fi    echo $SqlStatus}lag_status(){    DelayStatus=`mysql -u${USER} -p${PASS} -e &quot;show slave status\G;&quot; |grep &quot;Seconds_Behind_Master&quot;|awk &#39;{print $NF}&#39;`    echo $DelayStatus}$1</code></pre><pre><code>如何快速理解脚本传参逻辑？(1)可以看到整个脚本使用了3个函数,要知道，写了函数需要在脚本调用才会生效，而本脚本中是使用$1来进行调用的。(2)从脚本中可以看到，对应的传参值分别为io_status、sql_status和lag_status, 其他传参值将不会被调用。(3)zabbix mysql模板中自定义key名称与脚本函数名称相同，所以可以被正确赋值给$1并正确取值。</code></pre><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><pre><code>如果zabbix mysql模板中自定义key名称不是 io_status、sql_status和lag_status，依然能被正确调用？</code></pre><pre><code>需要在脚本中, 加入判断。如果$1等于zabbix mysql模板中的某个值，则执行脚本中其中一个函数。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;有时候经常会写传参脚本，下面是一个zabbix自定义key传参案例
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;zabbix配置文件&quot;&gt;&lt;a href=&quot;#zabbix配置文件&quot; class=&quot;headerlink&quot; title=&quot;zabbix配置文件&quot;&gt;&lt;/a&gt;zabbix配置文件&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;UnsafeUserParameters=1

#mysql slave监控
UserParameter=mysql.slave[*],/var/lib/mysql/check_mysql_slave.sh $1

注：留意下这个key值，后面是*表示所有
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="zabbix" scheme="https://wuyanteng.github.io/tags/zabbix/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="变量传参" scheme="https://wuyanteng.github.io/tags/%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82/"/>
    
      <category term="shell传参" scheme="https://wuyanteng.github.io/tags/shell%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>Telegram群组-Linux</title>
    <link href="https://wuyanteng.github.io/2018/06/19/Telegram%E7%BE%A4%E7%BB%84-Linux/"/>
    <id>https://wuyanteng.github.io/2018/06/19/Telegram群组-Linux/</id>
    <published>2018-06-19T03:19:18.000Z</published>
    <updated>2018-06-19T03:24:35.723Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Linux-Telegram-群组："><a href="#Linux-Telegram-群组：" class="headerlink" title="Linux Telegram 群组："></a>Linux Telegram 群组：</h5><p>(1) 运维中国  <a href="https://t.me/om_china" target="_blank" rel="noopener">https://t.me/om_china</a></p><p>(2) 运维中国-电报0101兆赫 <a href="https://t.me/om_china_0101" target="_blank" rel="noopener">https://t.me/om_china_0101</a></p><h5 id="群组简介"><a href="#群组简介" class="headerlink" title="群组简介"></a>群组简介</h5><p>正经Linux技术讨论群, 不开车，不扯蛋。交流范围：从底层(OSI7层模型)到OpenStack/K8S等虚拟化,再到Ceph/Swift等分布式存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Linux-Telegram-群组：&quot;&gt;&lt;a href=&quot;#Linux-Telegram-群组：&quot; class=&quot;headerlink&quot; title=&quot;Linux Telegram 群组：&quot;&gt;&lt;/a&gt;Linux Telegram 群组：&lt;/h5&gt;&lt;p&gt;(1) 运维
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://wuyanteng.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Telegram" scheme="https://wuyanteng.github.io/tags/Telegram/"/>
    
      <category term="Telegram Groups" scheme="https://wuyanteng.github.io/tags/Telegram-Groups/"/>
    
      <category term="Telegram群组" scheme="https://wuyanteng.github.io/tags/Telegram%E7%BE%A4%E7%BB%84/"/>
    
      <category term="Telegram群组linux" scheme="https://wuyanteng.github.io/tags/Telegram%E7%BE%A4%E7%BB%84linux/"/>
    
      <category term="TG" scheme="https://wuyanteng.github.io/tags/TG/"/>
    
      <category term="TG X" scheme="https://wuyanteng.github.io/tags/TG-X/"/>
    
  </entry>
  
  <entry>
    <title>MariaDB Galera Cluster部署</title>
    <link href="https://wuyanteng.github.io/2018/06/14/MariaDB-Galera-Cluster%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/06/14/MariaDB-Galera-Cluster部署/</id>
    <published>2018-06-14T08:46:11.000Z</published>
    <updated>2018-06-14T10:24:29.444Z</updated>
    
    <content type="html"><![CDATA[<pre><code>MariaDB作为Mysql的一个分支，在开源项目中已经广泛使用，例如大热的openstack，所以，为了保证服务的高可用性，同时提高系统的负载能力，集群部署是必不可少的。</code></pre><h5 id="MariaDB-Galera-Cluster-介绍"><a href="#MariaDB-Galera-Cluster-介绍" class="headerlink" title="MariaDB Galera Cluster 介绍"></a>MariaDB Galera Cluster 介绍</h5><pre><code>MariaDB集群是MariaDB同步多主机集群。它仅支持XtraDB/ InnoDB存储引擎（虽然有对MyISAM实验支持 - 看wsrep_replicate_myisam系统变量）。</code></pre><a id="more"></a><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><pre><code>- 同步复制- 真正的multi-master，即所有节点可以同时读写数据库- 自动的节点成员控制，失效节点自动被清除- 新节点加入数据自动复制- 真正的并行复制，行级- 用户可以直接连接集群，使用感受上与MySQL完全一致</code></pre><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><pre><code>因为是多主，所以不存在Slavelag(延迟)不存在丢失事务的情况同时具有读和写的扩展能力更小的客户端延迟节点间数据是同步的,而Master/Slave模式是异步的,不同slave上的binlog可能是不同的</code></pre><h5 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h5><pre><code>Galera集群的复制功能基于Galeralibrary实现,为了让MySQL与Galera library通讯，特别针对MySQL开发了wsrep API。Galera插件保证集群同步数据，保持数据的一致性，靠的就是可认证的复制，工作原理如下图： </code></pre><p><img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/mariadb-galera-cluster.png" alt="mariadb cluster"></p><pre><code>当客户端发出一个commit的指令，在事务被提交之前，所有对数据库的更改都会被 write-set 收集起来,并且将 write-set 记录的内容发送给其他节点。write-set 将在每个节点进行认证测试，测试结果决定着节点是否应用write-set更改数据。如果认证测试失败，节点将丢弃 write-set ；如果认证测试成功，则事务提交。</code></pre><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><h5 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h5><pre><code>安装MariaDB集群至少需要3台服务器（如果只有两台的话需要特殊配置，请参照官方文档）</code></pre><p>官方文档：<a href="http://galeracluster.com/documentation-webpages/twonode.html" target="_blank" rel="noopener">链接</a></p><pre><code>操作系统版本：CentOS7node1:10.128.20.16 node2:10.128.20.17 node3:10.128.20.18</code></pre><p>3节点配置hosts</p><pre><code>10.128.20.16 node110.128.20.17 node210.128.20.18 node3</code></pre><p>禁用防火墙和selinux</p><pre><code>(1)为了保证节点间相互通信，需要禁用防火墙设置（如果需要防火墙，则参照官方网站增加防火墙信息设置）(2)禁用selinux</code></pre><h5 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h5><p>配置MariaDB YUM源</p><pre><code>官方源配置向导：https://link.jianshu.com/?t=https://downloads.mariadb.org/mariadb/repositories</code></pre><pre><code>官方源vim /etc/yum.repos.d/mariadb.repo# MariaDB 10.0 CentOS repository list - created 2018-06-14 08:14 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = http://yum.mariadb.org/10.0/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1</code></pre><pre><code>国内源vim /etc/yum.repos.d/mariadb.repo[mariadb]name = MariaDBbaseurl = http://mirrors.ustc.edu.cn/mariadb/yum/10.2/centos7-amd64/gpgkey=http://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck=1</code></pre><p>安装MariaDB-10.0</p><pre><code>yum install -y mariadb mariadb-galera-server mariadb-galera-common galera rsync</code></pre><p>初始化服务(只在node1节点执行)</p><pre><code>systemctl start mariadbmysql_secure_installation</code></pre><p>关闭node1节点数据库，修改 <code>/etc/my.cnf.d/galera.cnf</code></p><pre><code>systemctl stop mariadbvim /etc/my.cnf.d/galera.cnf     #修改内容如下</code></pre><pre><code>[mysqld]......wsrep_provider = /usr/lib64/galera/libgalera_smm.sowsrep_cluster_address = &quot;gcomm://node1,node2,node3&quot;wsrep_node_name = node1wsrep_node_address=10.128.20.16#wsrep_provider_options=&quot;socket.ssl_key=/etc/pki/galera/galera.key; socket.ssl_cert=/etc/pki/galera/galera.crt;&quot;提示：如果不用ssl的方式认证的话，请把 wsrep_provider_options 注释掉。</code></pre><pre><code>将此文件复制到node2、node3，注意要把 wsrep_node_name 和 wsrep_node_address 改成相应节点的 hostname 和 ip。</code></pre><h5 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h5><pre><code>node1 启动 MariaDB Galera Cluster 服务/usr/libexec/mysqld --wsrep-new-cluster --user=root &amp;</code></pre><pre><code>观察日志：[root@node4 ~]# tail -f /var/log/mariadb/mariadb.log150701 19:54:17 [Note] WSREP: wsrep_load(): loading provider library &#39;none&#39;150701 19:54:17 [Note] /usr/libexec/mysqld: ready for connections.Version: &#39;5.5.40-MariaDB-wsrep&#39;  socket: &#39;/var/lib/mysql/mysql.sock&#39;  port: 3306  MariaDB Server, wsrep_25.11.r4026当出现 ready for connections ,证明我们启动成功</code></pre><p>继续启动node2和node3节点</p><pre><code>systemctl start mariadb可以查看 /var/log/mariadb/mariadb.log，在日志可以看到节点均加入了集群中。警告⚠：--wsrep-new-cluster 这个参数只能在初始化集群使用，且只能在一个节点使用。</code></pre><h5 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h5><pre><code>mysql -uroot -p&gt;SHOW STATUS LIKE `wsrep_%`;</code></pre><p><img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/galera-status.png" alt="galera-status"></p><pre><code>我们可以关注几个关键的参数：wsrep_connected = on 链接已开启wsrep_local_index = 1 在集群中的索引值wsrep_cluster_size =3 集群中节点的数量wsrep_incoming_addresses = 10.128.20.17:3306,10.128.20.16:3306,10.128.20.18:3306 集群中节点的访问地址</code></pre><h5 id="验证数据同步"><a href="#验证数据同步" class="headerlink" title="验证数据同步"></a>验证数据同步</h5><pre><code>我们在 node1 上新建数据库 galera_test ,然后在 node2 和 node3 上查询，如果可以查询到 galera_test 这个库，说明数据同步成功，集群运行正常。</code></pre><pre><code>[root@node1 ~]# mysql  -uroot  -proot  -e  &quot;create database galera_test&quot;</code></pre><pre><code>[root@node2 ~]# mysql  -uroot  -proot  -e  &quot;show databases&quot;+--------------------+| Database           |+--------------------+| information_schema || galera_test        || mysql              || performance_schema |+--------------------+</code></pre><pre><code>[root@node3 ~]# mysql  -uroot  -proot  -e  &quot;show databases&quot;+--------------------+| Database           |+--------------------+| information_schema || galera_test        || mysql              || performance_schema |+--------------------+</code></pre><p>至此，我们的 MariaDB Galera Cluster 已经成功部署。</p><p>参考：<a href="http://code.oneapm.com/database/2015/07/02/mariadb-galera-cluster/" target="_blank" rel="noopener">OpenARM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;MariaDB作为Mysql的一个分支，在开源项目中已经广泛使用，例如大热的openstack，所以，为了保证服务的高可用性，同时提高系统的负载能力，集群部署是必不可少的。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;MariaDB-Galera-Cluster-介绍&quot;&gt;&lt;a href=&quot;#MariaDB-Galera-Cluster-介绍&quot; class=&quot;headerlink&quot; title=&quot;MariaDB Galera Cluster 介绍&quot;&gt;&lt;/a&gt;MariaDB Galera Cluster 介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;MariaDB集群是MariaDB同步多主机集群。它仅支持XtraDB/ InnoDB存储引擎（虽然有对MyISAM实验支持 - 看wsrep_replicate_myisam系统变量）。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="MariaDB" scheme="https://wuyanteng.github.io/tags/MariaDB/"/>
    
      <category term="Galera" scheme="https://wuyanteng.github.io/tags/Galera/"/>
    
      <category term="Cluster" scheme="https://wuyanteng.github.io/tags/Cluster/"/>
    
      <category term="MySQL" scheme="https://wuyanteng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>nginx日志配合iptables封IP防CC攻击</title>
    <link href="https://wuyanteng.github.io/2018/06/12/nginx%E6%97%A5%E5%BF%97%E9%85%8D%E5%90%88iptables%E5%B0%81IP%E9%98%B2CC%E6%94%BB%E5%87%BB/"/>
    <id>https://wuyanteng.github.io/2018/06/12/nginx日志配合iptables封IP防CC攻击/</id>
    <published>2018-06-12T07:30:44.000Z</published>
    <updated>2018-06-12T08:30:07.776Z</updated>
    
    <content type="html"><![CDATA[<pre><code>通过分析nginx日志找出请求数较大的IP，并用iptables封掉。</code></pre><p>编写脚本</p><pre><code>#!/bin/bash#定义访问次数上限100num=100LOG_DIR=/var/log/nginxcd $LOG_DIR#定义筛选访问量＞100的IP地址IP=`tail access.log -n 1000|awk &#39;{print $1}&#39;|sort|uniq -c|sort -rn|awk &#39;{if ($1&gt;&#39;$num&#39;){print $2}}&#39;`for i in $IP#读取最新1000条记录，如果单IP超过100条就封掉。do      iptables -I INPUT -p tcp -s $i --dport 80 -j DROPdone</code></pre><a id="more"></a><p>配置crontab</p><pre><code>#5分钟执行一次*/5 * * * * sh /path/deny.sh   </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;通过分析nginx日志找出请求数较大的IP，并用iptables封掉。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编写脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

#定义访问次数上限100
num=100
LOG_DIR=/var/log/nginx
cd $LOG_DIR

#定义筛选访问量＞100的IP地址
IP=`tail access.log -n 1000|awk &amp;#39;{print $1}&amp;#39;|sort|uniq -c|sort -rn|awk &amp;#39;{if ($1&amp;gt;&amp;#39;$num&amp;#39;){print $2}}&amp;#39;`

for i in $IP
#读取最新1000条记录，如果单IP超过100条就封掉。
do
      iptables -I INPUT -p tcp -s $i --dport 80 -j DROP
done
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="CC" scheme="https://wuyanteng.github.io/tags/CC/"/>
    
      <category term="Ddos" scheme="https://wuyanteng.github.io/tags/Ddos/"/>
    
      <category term="nginx日志" scheme="https://wuyanteng.github.io/tags/nginx%E6%97%A5%E5%BF%97/"/>
    
      <category term="高积运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%A7%AF%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反爬虫</title>
    <link href="https://wuyanteng.github.io/2018/06/12/Nginx%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    <id>https://wuyanteng.github.io/2018/06/12/Nginx反爬虫/</id>
    <published>2018-06-12T03:09:14.000Z</published>
    <updated>2018-06-12T04:03:46.602Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Nginx被爬虫的服务器，会在某个时间点CPU占用骤增, 不同时间段CPU占用较高（也可能会出现内存溢出等问题）。如果服务器有web业务，那么基本可以确定被爬虫了...</code></pre><a id="more"></a><h4 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h4><h5 id="首先对爬虫IP进行屏蔽"><a href="#首先对爬虫IP进行屏蔽" class="headerlink" title="首先对爬虫IP进行屏蔽"></a>首先对爬虫IP进行屏蔽</h5><pre><code>策略: 通过awk筛选日志，找出访问量较高的可以IP地址进行屏蔽。(1)查找要禁止的IP:awk &#39;{print $1}&#39; /var/log/nginx/access.log|sort |uniq -c|sort -rn(2)屏蔽IP或IP段在nginx server区段添加如下即可：deny 5.188.211.72;或deny 5.188.211.70/32;</code></pre><h5 id="Nginx判断UA处理反爬虫"><a href="#Nginx判断UA处理反爬虫" class="headerlink" title="Nginx判断UA处理反爬虫"></a>Nginx判断UA处理反爬虫</h5><pre><code>这个时候就有充足的时间通过一些手段进行反爬虫处理了...</code></pre><p>将下面的if语句放在nginx配置文件的server或者location代码区域内【不能放在http区域】。</p><pre><code>#禁止指定UA及UA为空的访问(常见UA列表详见附录)if ($http_user_agent ~* &quot;Applebot|SEOkicks-Robot|DotBot|YunGuanCe|Exabot|spiderman|Scrapy|HttpClient|Teleport|TeleportPro|SiteExplorer|WBSearchBot|Elefent|psbot|TurnitinBot|wsAnalyzer|ichiro|ezooms|FeedDemon|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms|^$&quot;) {  return 403;} </code></pre><p>生效</p><pre><code>添加此配置之后，验证语法：nginx -t 无误后,重载Nginx配置: nginx -s reload</code></pre><p>测试</p><pre><code>curl -I -A &quot;spiderman&quot; https://xx.xxx.com或curl -I -A &quot;YunGuanCe&quot; https://xx.xxx.com如果返回403的输出，则说明配置已经生效了</code></pre><h5 id="自行筛选屏蔽UA"><a href="#自行筛选屏蔽UA" class="headerlink" title="自行筛选屏蔽UA"></a>自行筛选屏蔽UA</h5><pre><code>log筛选命令：cat access.log|awk -F &#39;&quot;&#39; &#39;{print $6}&#39;|sort|uniq -c |sort -rn|head -20将可疑的UA加入以上屏蔽列表即可。</code></pre><h5 id="附录：常见的爬虫UA"><a href="#附录：常见的爬虫UA" class="headerlink" title="附录：常见的爬虫UA"></a>附录：常见的爬虫UA</h5><p>常见搜索引擎爬虫的User-Agent</p><pre><code>百度爬虫Baiduspider+(+http://www.baidu.com/search/spider.htm”)Google爬虫Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)Googlebot/2.1 (+http://www.googlebot.com/bot.html)Googlebot/2.1 (+http://www.google.com/bot.html)雅虎爬虫(分别是雅虎中国和美国总部的爬虫)Mozilla/5.0 (compatible; Yahoo! Slurp China; http://misc.yahoo.com.cn/help.html”)Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp”)新浪爱问爬虫iaskspider/2.0(+http://iask.com/help/help_index.html”)Mozilla/5.0 (compatible; iaskspider/1.0; MSIE 6.0)搜狗爬虫Sogou web spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07″)Sogou Push Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07″)网易爬虫Mozilla/5.0 (compatible; YodaoBot/1.0; http://www.yodao.com/help/webmaster/spider/”; )MSN爬虫msnbot/1.0 (+http://search.msn.com/msnbot.htm”)</code></pre><p>网络上常见的垃圾UA列表</p><pre><code>内容采集：      FeedDemon      Java 内容采集      Jullo 内容采集      Feedly 内容采集      UniversalFeedParser 内容采集SQL注入：      BOT/0.1 (BOT for JCE)      CrawlDaddy无用爬虫:      EasouSpider      Swiftbot      YandexBot      AhrefsBot      jikeSpider      MJ12bot      YYSpider      oBotCC攻击器:      ApacheBench      WinHttpTCP攻击:      HttpClient扫描:      Microsoft URL Control      ZmEu phpmyadmin      jaunty</code></pre><p>参考：<a href="https://www.hi-linux.com/posts/5492.html" target="_blank" rel="noopener">运维之美</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Nginx被爬虫的服务器，会在某个时间点CPU占用骤增, 不同时间段CPU占用较高（也可能会出现内存溢出等问题）。如果服务器有web业务，那么基本可以确定被爬虫了...
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="nginx反爬虫" scheme="https://wuyanteng.github.io/tags/nginx%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
      <category term="蜘蛛" scheme="https://wuyanteng.github.io/tags/%E8%9C%98%E8%9B%9B/"/>
    
      <category term="User Agent" scheme="https://wuyanteng.github.io/tags/User-Agent/"/>
    
      <category term="垃圾UA" scheme="https://wuyanteng.github.io/tags/%E5%9E%83%E5%9C%BEUA/"/>
    
  </entry>
  
  <entry>
    <title>mongodb单机版安装</title>
    <link href="https://wuyanteng.github.io/2018/06/08/mongodb%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85/"/>
    <id>https://wuyanteng.github.io/2018/06/08/mongodb单机版安装/</id>
    <published>2018-06-08T01:58:30.000Z</published>
    <updated>2018-06-08T02:00:13.122Z</updated>
    
    <content type="html"><![CDATA[<p>下载</p><pre><code>cd rootwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.2.0.tgz</code></pre><p>解压</p><pre><code>tar -zxvf mongodb-linux-x86_64-amazon-3.2.0.tgz</code></pre><a id="more"></a><p>剪切MongoDB到/usr/local目录中</p><pre><code>mv mongodb-linux-x86_64-amazon-3.2.0 /usr/local/mongodb</code></pre><p>创建MongoDB数据库和日志存放路径</p><pre><code>mkdir -p /data/mongodbmkdir -p /var/log/mongodbmkdir -p /var/run/mongodbtouch /var/log/mongodb/mongodb.log注：(1)这个log文件必须事先创建且存在(2)如果mongodb以其他用户启动，该用户需具有所有相关目录和文件的属主权限</code></pre><p>启动</p><pre><code>vim /usr/local/mongodb/config.conf## 配置文件内容pidfilepath = /var/run/mongodb/mongodb.piddbpath = /data/mongodblogpath = /var/log/mongodb/mongodb.loglogappend = truebind_ip = 0.0.0.0port = 27017fork = true#declare this is a config db of a cluster;configsvr = true#副本集名称replSet=configs#设置最大连接数maxConns=20000</code></pre><p>启动</p><pre><code>/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/config.conf</code></pre><pre><code>停止mongo服务/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/config.conf --shutdown注意：禁止使用kill -9 &lt;pid&gt; 的方式把进程结束掉,会造成数据丢失！</code></pre><p>启动故障-解决方案</p><pre><code>启动错误：mongod: /usr/lib64/libstdc++.so.6: version `CXXABI_1.3.5&#39; not found (required by mongod)mongod: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&#39; not found (required by mongod)mongod: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14&#39; not found (required by mongod)解决方法：查看动态库版本strings /usr/lib64/libstdc++.so.6 | grep GLIBC   查找动态库文件find / -name &quot;libstdc++.so*&quot;   备份现有的libstdc++.so.6mv /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.bak  软链最新的动态库文件ln -sv ln -sv /usr/local/androidSDK/tools/lib64/libstdc++/libstdc++.so.6.0.18 /usr/lib64/libstdc++.so.6  /usr/lib64/libstdc++.so.6再次查看动态库版本strings /usr/lib64/libstdc++.so.6 | grep GLIBC 再次启动mongodb</code></pre><p>验证启动</p><pre><code>netstat -lntup|grep 27017</code></pre><p>Mongo服务启动脚本</p><pre><code>不多说，网上down脚本，按照配置文件指定参数进行对应替换即可</code></pre><p>连接</p><pre><code>/usr/local/mongodb/bin/mongo ip:port</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd root
wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.2.0.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解压&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar -zxvf mongodb-linux-x86_64-amazon-3.2.0.tgz
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Mongodb" scheme="https://wuyanteng.github.io/tags/Mongodb/"/>
    
      <category term="mongod" scheme="https://wuyanteng.github.io/tags/mongod/"/>
    
      <category term="二进制版" scheme="https://wuyanteng.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>单独运行shell脚本与crontab运行shell脚本的区别</title>
    <link href="https://wuyanteng.github.io/2018/06/02/%E5%8D%95%E7%8B%AC%E8%BF%90%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E4%B8%8Ecrontab%E8%BF%90%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wuyanteng.github.io/2018/06/02/单独运行shell脚本与crontab运行shell脚本的区别/</id>
    <published>2018-06-02T00:10:57.000Z</published>
    <updated>2018-06-02T00:19:50.923Z</updated>
    
    <content type="html"><![CDATA[<pre><code>crontab运行脚本存在两大问题：环境变量和路径.现象：单独运行脚本没问题，但用crontab定时运行脚本就报错，cron日志只显示执行过了命令，但运行结果不是我们想要的，因为中间过程中出现了错误。</code></pre><a id="more"></a><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><pre><code>常常写脚本，要能够基本判断某个命令是否是shell内部命令（所支持的命令），外部命令在脚本中需要使用命令绝对路径，否则crontab去执行这个脚本时会出现错误。外部命令如：python、jq等等解决方法：命令使用绝对路径即可（可使用which命令查看）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;crontab运行脚本存在两大问题：环境变量和路径.
现象：单独运行脚本没问题，但用crontab定时运行脚本就报错，cron日志只显示执行过了命令，但运行结果不是我们想要的，因为中间过程中出现了错误。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="crontab" scheme="https://wuyanteng.github.io/tags/crontab/"/>
    
      <category term="外部命令" scheme="https://wuyanteng.github.io/tags/%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="内部命令" scheme="https://wuyanteng.github.io/tags/%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB副本集成员状态</title>
    <link href="https://wuyanteng.github.io/2018/05/29/MongoDB%E5%89%AF%E6%9C%AC%E9%9B%86%E6%88%90%E5%91%98%E7%8A%B6%E6%80%81/"/>
    <id>https://wuyanteng.github.io/2018/05/29/MongoDB副本集成员状态/</id>
    <published>2018-05-29T09:38:59.000Z</published>
    <updated>2018-05-29T09:50:35.281Z</updated>
    
    <content type="html"><![CDATA[<pre><code>副本集的每个成员都有一个状态，反映了它在集合中的配置情况。</code></pre><table><thead><tr><th><strong>数字</strong></th><th><strong>名称</strong></th><th><strong>状态描述</strong></th></tr></thead><tbody><tr><td>0</td><td>STARTUP</td><td>还不是任何集合的活动成员。所有的成员启动在该状态。在STARTUP状态mongod解析副本集配置文档。</td></tr><tr><td>1</td><td>PRIMARY</td><td>处于PRIMARY状态的成员是唯一能接受写操作的成员。</td></tr><tr><td>2</td><td>SECONDARY</td><td>处于SECONDARY状态的成员复制数据存储。数据可用于读，尽管可能比较旧。</td></tr><tr><td>3</td><td>RECOVERING</td><td>可以选举。成员要么实施启动自检测，或完成回滚或重新同步的转换。</td></tr><tr><td>5</td><td>STARTUP2</td><td>成员加入了集合，正运行初始化同步。</td></tr><tr><td>6</td><td>UNKNOWN</td><td>成员的状态，正如从集合的另一个成员中所看到的，未知。</td></tr><tr><td>7</td><td>ARBITER</td><td>仲裁不复制数据，而仅仅参与选举。</td></tr><tr><td>8</td><td>DOWN</td><td>该成员，正如从集合的立即你跟一个成员所见，不可达。</td></tr><tr><td>9</td><td>ROLLBACK</td><td>该成员正在实施回滚。数据不可读。</td></tr><tr><td>10</td><td>REMOVED</td><td>成员曾今在副本集但随后被移除。</td></tr></tbody></table><a id="more"></a><h4 id="核心状态"><a href="#核心状态" class="headerlink" title="核心状态"></a>核心状态</h4><h5 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h5><pre><code>处于PRIMARY状态的成员接受写操作。一个副本集每次最多只有一个主成员。在一次选举后，一个SECONDARY状态成员成为主成员。处于PRIMARY状态的成员有资格选举。</code></pre><h5 id="SECONDARY"><a href="#SECONDARY" class="headerlink" title="SECONDARY"></a>SECONDARY</h5><pre><code>处于SECONDARY状态的成员复制主成员的数据集合，并可以被配置为接受读操作。辅助成员有资格在选举中投票，如果主成员不可用，会被选举为PRIMARY状态。</code></pre><h5 id="ARBITER"><a href="#ARBITER" class="headerlink" title="ARBITER"></a>ARBITER</h5><pre><code>处于ARBITER状态的成员不复制数据，也不接受写操作。它们有资格选举，仅仅存在于选举中决胜负。如果集合要么有大量的成员，并能够参与决胜选举，否则副本集应该只有一个成员处于ARBITER状态。在任何副本集中最多只有一个仲裁被配置。</code></pre><h4 id="其他状态"><a href="#其他状态" class="headerlink" title="其他状态"></a>其他状态</h4><h5 id="STARTUP"><a href="#STARTUP" class="headerlink" title="STARTUP"></a>STARTUP</h5><pre><code>副本集的每个成员以STARTUP状态启动。Mongod然后加载成员的副本集配置，成员的状态转化为STARTUP2。在STARTUP状态的成员没有资格选举，因为它们不被人为是任何副本集的成员。</code></pre><h5 id="STARTUP2"><a href="#STARTUP2" class="headerlink" title="STARTUP2"></a>STARTUP2</h5><pre><code>一旦mongod加载成员配置完成，副本集的每个成员就进入STARTUP2状态，在此时它开始成员副本集的一个活动成员。成员然后决定是否需要初始化同步。如果一个成员开始初始化同步，成员保持STARTUP2状态直到所有数据拷贝完成所有索引创建完成。之后，成员转换为RECOVERING状态。</code></pre><h5 id="RECOVERING"><a href="#RECOVERING" class="headerlink" title="RECOVERING"></a>RECOVERING</h5><pre><code>当副本集成员不准备接受读取时，它进入RECOVERING状态。RECOVERING状态发生在正常操作期间，不必显示一个错误条件。处于RECOVERING状态的成员有资格在选举中投票，但是没有资格进入PRIMARY状态。在复制足够的数据给客户端所需读取数据的一致性视图，成员便从RECOVERING状态转为SECONDARY状态。在RECOVERING和SECONDARY状态之间的唯一区别是，RECOVERING阻止客户端读取，SECONDARY运行读取。SECONDARY状态并不保证主成员数据陈旧化。</code></pre><pre><code>注：关于负载，一个辅助成员可能会远远落后于副本集的其他成员，以至于它可能需要重新同步数据到副本集。当这种情况发生时，成员进入RECOVERING状态，并需要手工干预。</code></pre><h4 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h4><pre><code>处于错误状态的成员不能选举。</code></pre><h5 id="UNKNOWN"><a href="#UNKNOWN" class="headerlink" title="UNKNOWN"></a>UNKNOWN</h5><pre><code>从没交流状态信息到副本集的成员会处于UNKNOWN状态。</code></pre><h5 id="DOWN"><a href="#DOWN" class="headerlink" title="DOWN"></a>DOWN</h5><pre><code>丢失到副本集连接的成员被集合的剩余成员看作为DOWN状态。</code></pre><h5 id="REMOVED"><a href="#REMOVED" class="headerlink" title="REMOVED"></a>REMOVED</h5><pre><code>从副本集移除的成员进入REMOVED状态。当成员进入REMOVED状态，日志将会标记replset REMOVED消息事件。</code></pre><h5 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h5><pre><code>当副本集在选举中替换掉主成员，旧的主成员可能包含不会复制到辅助成员的文档。在这种情况下，旧的主成员反转这些写操作。在回滚期间，成员将保持ROLLBACK状态。</code></pre><h5 id="FATAL"><a href="#FATAL" class="headerlink" title="FATAL"></a>FATAL</h5><pre><code>处于FATAL状态的成员触发了一个不可恢复错误。成员必需关闭并重启，可能还需要重新同步。</code></pre><p>参考：<a href="http://blog.51cto.com/ultrasql/1663181" target="_blank" rel="noopener">UltraSQL</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;副本集的每个成员都有一个状态，反映了它在集合中的配置情况。
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;数字&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;名称&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;状态描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;STARTUP&lt;/td&gt;
&lt;td&gt;还不是任何集合的活动成员。所有的成员启动在该状态。在STARTUP状态mongod解析副本集配置文档。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;处于PRIMARY状态的成员是唯一能接受写操作的成员。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;SECONDARY&lt;/td&gt;
&lt;td&gt;处于SECONDARY状态的成员复制数据存储。数据可用于读，尽管可能比较旧。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;RECOVERING&lt;/td&gt;
&lt;td&gt;可以选举。成员要么实施启动自检测，或完成回滚或重新同步的转换。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;STARTUP2&lt;/td&gt;
&lt;td&gt;成员加入了集合，正运行初始化同步。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;UNKNOWN&lt;/td&gt;
&lt;td&gt;成员的状态，正如从集合的另一个成员中所看到的，未知。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;ARBITER&lt;/td&gt;
&lt;td&gt;仲裁不复制数据，而仅仅参与选举。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;DOWN&lt;/td&gt;
&lt;td&gt;该成员，正如从集合的立即你跟一个成员所见，不可达。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;ROLLBACK&lt;/td&gt;
&lt;td&gt;该成员正在实施回滚。数据不可读。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;REMOVED&lt;/td&gt;
&lt;td&gt;成员曾今在副本集但随后被移除。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="SECONDARY" scheme="https://wuyanteng.github.io/tags/SECONDARY/"/>
    
      <category term="PRIMARY" scheme="https://wuyanteng.github.io/tags/PRIMARY/"/>
    
      <category term="MongoDB" scheme="https://wuyanteng.github.io/tags/MongoDB/"/>
    
      <category term="STARTUP" scheme="https://wuyanteng.github.io/tags/STARTUP/"/>
    
      <category term="副本集成员" scheme="https://wuyanteng.github.io/tags/%E5%89%AF%E6%9C%AC%E9%9B%86%E6%88%90%E5%91%98/"/>
    
      <category term="成员状态" scheme="https://wuyanteng.github.io/tags/%E6%88%90%E5%91%98%E7%8A%B6%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>ps命令查看进程启动及运行时间-linux</title>
    <link href="https://wuyanteng.github.io/2018/05/23/ps%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4-linux/"/>
    <id>https://wuyanteng.github.io/2018/05/23/ps命令查看进程启动及运行时间-linux/</id>
    <published>2018-05-23T02:27:26.000Z</published>
    <updated>2018-05-23T02:54:15.169Z</updated>
    
    <content type="html"><![CDATA[<pre><code>有时候排查故障，可能需要查看下某个服务进程的启动时间与运行时间，如果进程由supervisor启动，就好办了。supervisor查看服务启动时间：supervisorctl status 如果程序没有使用supervisor启动，该怎么查看呢？</code></pre><a id="more"></a><h5 id="man命令查看下ps参数含义"><a href="#man命令查看下ps参数含义" class="headerlink" title="man命令查看下ps参数含义"></a>man命令查看下ps参数含义</h5><pre><code># man ps|egrep &#39;lstart|etime&#39;       running during the entire lifetime of a process.  This is not ideal,       %t     etime    ELAPSED       args, cmd, comm, command, fname, ucmd, ucomm, lstart, bsdstart, start.                             to be fully destroyed by its parent.  Sometimes                             lstart, start, start_time, and stime.                             lifetime of the process.  (see %cpu).       etime       ELAPSED   elapsed time since the process was started, in       etimes      ELAPSED   elapsed time since the process was started, in       lstart      STARTED   time the command started.  See also                             lstart, bsdstart, start_time, and stime.                             otherwise.  See also bsdstart, start, lstart,可以看到官方解释：etime指: 进程启动后运行或流逝的时间lstart指: 进程启动精确时间</code></pre><h5 id="查看服务或进程的启动时间"><a href="#查看服务或进程的启动时间" class="headerlink" title="查看服务或进程的启动时间"></a>查看服务或进程的启动时间</h5><pre><code># ps -eo pid,lstart,etime,cmd |grep mysql30244 Thu Feb  8 18:27:02 2018 103-16:22:50 /bin/mysqld_safe...</code></pre><p>或</p><pre><code># ps -eo lstart,etime,cmd |grep pid30244 Thu Feb  8 18:27:02 2018 103-16:23:27  common</code></pre><p>参考：<a href="https://jaminzhang.github.io/linux/using-ps-to-view-process-started-and-elapsed-time-in-linux/" target="_blank" rel="noopener">JAMIN ZHANG</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;有时候排查故障，可能需要查看下某个服务进程的启动时间与运行时间，如果进程由supervisor启动，就好办了。

supervisor查看服务启动时间：
supervisorctl status 

如果程序没有使用supervisor启动，该怎么查看呢？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ps" scheme="https://wuyanteng.github.io/tags/ps/"/>
    
      <category term="进程启动时间" scheme="https://wuyanteng.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    
      <category term="进程运行时间" scheme="https://wuyanteng.github.io/tags/%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>curl和wget的底层实现区别</title>
    <link href="https://wuyanteng.github.io/2018/05/21/curl%E5%92%8Cwget%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%88%AB/"/>
    <id>https://wuyanteng.github.io/2018/05/21/curl和wget的底层实现区别/</id>
    <published>2018-05-21T08:56:17.000Z</published>
    <updated>2018-05-21T10:01:00.530Z</updated>
    
    <content type="html"><![CDATA[<pre><code>开发有个php程序,通过curl去调用bind dns中一个域名(2个A记录)，在某些服务器上始终只轮询落到其中一个A记录服务器（使用wget和ping不存在这个问题），具体原因后研究认定可能与路由消耗有关。但现在来说说curl和wget的区别。</code></pre><a id="more"></a><h4 id="使用strace命令去跟踪整个请求过程"><a href="#使用strace命令去跟踪整个请求过程" class="headerlink" title="使用strace命令去跟踪整个请求过程"></a>使用strace命令去跟踪整个请求过程</h4><h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><pre><code>strace curl -v  web.test.zone</code></pre><p>摘出关键部分</p><pre><code>......开始部分调用了几个模块, libcurl.so.4、libz.so.1、libpthread.so.0、libssl.so.1等等......接下来打开了文件：/etc/ssl/openssl.cnf和/lib64/locale/locale-archive,不知道它要干嘛！......</code></pre><pre><code>write(2, &quot;Rebuilt URL to: web.test.zone/\n&quot;, 32Rebuilt URL to: web.test.zone/) = 32mmap(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fbd43387000......write(2, &quot;*&quot;, 1*)                        = 1write(2, &quot; &quot;, 1 )                        = 1write(2, &quot;  Trying 192.168.10.25...\n&quot;, 23  Trying 192.168.10.25...上面这部分就是域名解析了，完全懵逼的状态，通过尼玛什么机制获取的IP地址呢？？？下面的部分就是直接去请求资源了...write(2, &quot;GET / HTTP/1.1\r\n&quot;, 16GET / HTTP/1.1)      = 16write(2, &quot;&gt;&quot;, 1&gt;)                        = 1write(2, &quot; &quot;, 1 )                        = 1write(2, &quot;Host: web.test.zone\r\n&quot;, 22Host: web.test.zone) = 22write(2, &quot;&gt;&quot;, 1&gt;)                        = 1write(2, &quot; &quot;, 1 )                        = 1write(2, &quot;User-Agent: curl/7.45.0\r\n&quot;, 25User-Agent: curl/7.45.0</code></pre><h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><pre><code>strace wget web.test.zone</code></pre><p>摘出关键部分</p><pre><code>......最开始加载模块:libpcre.so.1、libssl.so.1.0等等......</code></pre><pre><code>#查找了/etc/resalv.conf文件open(&quot;/etc/resolv.conf&quot;, O_RDONLY|O_CLOEXEC) = 3fstat(3, {st_mode=S_IFREG|0644, st_size=105, ...}) = 0#查找了/etc/nsswitch.conf文件open(&quot;/etc/nsswitch.conf&quot;, O_RDONLY|O_CLOEXEC) = 3fstat(3, {st_mode=S_IFREG|0644, st_size=508, ...}) = 0                           = 0#查找了/etc/host.conf文件open(&quot;/etc/host.conf&quot;, O_RDONLY|O_CLOEXEC) = 3fstat(3, {st_mode=S_IFREG|0644, st_size=935, ...}) = 0#查找了/etc/hosts文件open(&quot;/etc/hosts&quot;, O_RDONLY|O_CLOEXEC)  = 3fstat(3, {st_mode=S_IFREG|0644, st_size=1205, ...}) = 0#(可能是根据hosts优先原则)最后通过DNS获取到域名解析结果write(2, &quot;192.168.10.25&quot;, 192.168.10.25)              = 10write(2, &quot;, &quot;, 2, )                       = 2write(2, &quot;192.168.10.26&quot;, 192.168.10.26)              = 10write(2, &quot;\n&quot;, 1)                       = 1#拿着域名解析结果去请求数据write(2, &quot;Connecting to web.test.zone|10.&quot;..., 47Connecting to web.test.zone... ) = 47socket(PF_INET, SOCK_STREAM, IPPROTO_IP) = 3connect(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr(&quot;192.168.10.25&quot;)}, 16) = 0write(2, &quot;connected.\n&quot;, 11connected.</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>curl是通过libcurl跨平台库去实现的，暂且搞不懂curl是通过何种方式或规律一次获取的IP地址,不过从strace的结果中来看，它并没有遵循Bind DNS轮询IP地址去请求数据。相对于curl来说，一次wget请求，它把很多时间都用在了域名解析上，在查找hosts文件无果的情况下，通过类似dig的方式解析获取所有ip地址并去选择其一去请求数据，多次测试，结果是使用不同A记录IP地址去请求数据。</code></pre><pre><code>对于以上结论，纯属个人观点，如有雷同，纯属巧合。我已经在stackoverflow发布了该话题，如果有大牛回答，我可能会更新我的观点。</code></pre><h5 id="其他-curl请求URL不使用缓存"><a href="#其他-curl请求URL不使用缓存" class="headerlink" title="其他-curl请求URL不使用缓存"></a>其他-curl请求URL不使用缓存</h5><pre><code>curl请求url不使用缓存curl -H &#39;Cache-Control: no-cache&#39; http://www.example.com</code></pre><p>基本无价值参考: <a href="https://daniel.haxx.se/docs/curl-vs-wget.html" target="_blank" rel="noopener">haxx.se</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;开发有个php程序,通过curl去调用bind dns中一个域名(2个A记录)，在某些服务器上始终只轮询落到其中一个A记录服务器（使用wget和ping不存在这个问题），具体原因后研究认定可能与路由消耗有关。但现在来说说curl和wget的区别。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="curl" scheme="https://wuyanteng.github.io/tags/curl/"/>
    
      <category term="wget" scheme="https://wuyanteng.github.io/tags/wget/"/>
    
      <category term="curl请求url不使用缓存" scheme="https://wuyanteng.github.io/tags/curl%E8%AF%B7%E6%B1%82url%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>proxychains4 socks5代理神器</title>
    <link href="https://wuyanteng.github.io/2018/05/18/proxychains4-socks5%E4%BB%A3%E7%90%86%E7%A5%9E%E5%99%A8/"/>
    <id>https://wuyanteng.github.io/2018/05/18/proxychains4-socks5代理神器/</id>
    <published>2018-05-18T07:39:34.000Z</published>
    <updated>2018-05-18T08:02:59.484Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Github: https://github.com/rofl0r/proxychains-ng</code></pre><pre><code>功能：让命令支持SOCKS5代理</code></pre><a id="more"></a><h5 id="clone源码安装"><a href="#clone源码安装" class="headerlink" title="clone源码安装"></a>clone源码安装</h5><pre><code>clone以上源码到本地/opt目录cd /opt/proxychains-master./configure --sysconfdir=/usr/local/etcmake &amp;&amp; make install</code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><pre><code>vim /etc/proxychains.conf</code></pre><pre><code>#推荐使用如下配置strict_chainproxy_dnsremote_dns_subnet 224tcp_read_time_out 15000tcp_connect_time_out 8000localnet 127.0.0.0/255.0.0.0quiet_mode[ProxyList]socks5  127.0.0.1 1080</code></pre><pre><code>注: 模板文件在&quot; (源码编译目录)/src/proxychains.conf &quot;</code></pre><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code> yum走代理 proxychains4 yum install youtube-dl 下载一个2分钟的4k Youtube视频 proxychains4 youtube-dl https://www.youtube.com/watch?v=IRSVsCBtgnk</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Github: https://github.com/rofl0r/proxychains-ng
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;功能：让命令支持SOCKS5代理
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="SOCKS5" scheme="https://wuyanteng.github.io/tags/SOCKS5/"/>
    
      <category term="proxychains" scheme="https://wuyanteng.github.io/tags/proxychains/"/>
    
      <category term="命令代理" scheme="https://wuyanteng.github.io/tags/%E5%91%BD%E4%BB%A4%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>sar命令-Linux查找系统瓶颈利器</title>
    <link href="https://wuyanteng.github.io/2018/05/16/sar%E5%91%BD%E4%BB%A4-Linux%E6%9F%A5%E6%89%BE%E7%B3%BB%E7%BB%9F%E7%93%B6%E9%A2%88%E5%88%A9%E5%99%A8/"/>
    <id>https://wuyanteng.github.io/2018/05/16/sar命令-Linux查找系统瓶颈利器/</id>
    <published>2018-05-16T08:03:13.000Z</published>
    <updated>2018-05-16T08:52:41.794Z</updated>
    
    <content type="html"><![CDATA[<pre><code>SAR是一个在Unix和Linux操作系统中用来收集、报告和保存CPU、内存、输入输出端口使用情况的命令。sar 命令将操作系统中选定的累计活动计数器的内容写到标准输出。基于 number 和 interval 参数的值，记帐系统按指定次数，以指定的时间间隔（以秒为单位）写入信息。number 参数的缺省采样时间间隔为 1 秒。收集的数据也可以保存在由 -o file 标志指定的文件中。当指定 –X 选项时，sar 命令会生成 XML 文件。</code></pre><a id="more"></a><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code>yum install sysstat当启动sysstat服务后，报告就会被写入到日志文件“/var/log/sa/saDD”中并且已经存在的文档将会被归档。DD表示当前日期。systemctl start sysstatsystemctl enable sysstat</code></pre><pre><code>[root@bogon ~]# cat /etc/cron.d/sysstat #每10分钟运行一次系统活动收集*/10 * * * * root /usr/lib64/sa/sa1 1 1#每天形成一份报告53 23 * * * root /usr/lib64/sa/sa2 -A其中,crontab文件负责收集和生成报告。</code></pre><pre><code>SysStat的默认Config配置文件[root@bogon ~]# grep -v &quot;^[#]&quot; /etc/sysconfig/sysstatHISTORY=28COMPRESSAFTER=31SADC_OPTIONS=&quot;-S DISK&quot;ZIP=&quot;bzip2&quot;</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="每隔2秒动态生成5次CPU的使用情况"><a href="#每隔2秒动态生成5次CPU的使用情况" class="headerlink" title="每隔2秒动态生成5次CPU的使用情况"></a>每隔2秒动态生成5次CPU的使用情况</h5><pre><code>[root@bogon ~]# sar -u 2 5Linux 3.10.0-327.el7.x86_64 (bogon)     05/16/2018     _x86_64_    (8 CPU)04:17:00 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle04:17:02 AM     all      0.00      0.00      0.00      0.00      0.00    100.0004:17:04 AM     all      0.00      0.00      0.06      0.00      0.00     99.9404:17:06 AM     all      0.00      0.00      0.00      0.00      0.00    100.0004:17:08 AM     all      0.00      0.00      0.00      0.00      0.00    100.0004:17:10 AM     all      0.00      0.00      0.00      0.00      0.00    100.00Average:        all      0.00      0.00      0.01      0.00      0.00     99.99%user 用户模式下消耗的CPU时间的比例；%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例%system 系统模式下消耗的CPU时间的比例；%iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；%idle CPU空闲时间比例；注：如果 &quot;%iowait&quot; 这一项是一个超过0的长时间值，那么我们就要考虑是否在输入输出系统方面存在瓶颈(比如硬盘或者网络)。</code></pre><h5 id="使用-q选项查看平均负载"><a href="#使用-q选项查看平均负载" class="headerlink" title="使用-q选项查看平均负载"></a>使用-q选项查看平均负载</h5><pre><code>[root@bogon ~]# sar -q 2 5Linux 3.10.0-327.el7.x86_64 (bogon)     05/16/2018     _x86_64_    (8 CPU)04:37:43 AM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked04:37:45 AM         0       163      0.00      0.01      0.05         004:37:47 AM         0       163      0.00      0.01      0.05         004:37:49 AM         0       163      0.00      0.01      0.05         004:37:51 AM         0       163      0.00      0.01      0.05         004:37:53 AM         0       163      0.00      0.01      0.05         0Average:            0       163      0.00      0.01      0.05         0runq-sz：运行队列的长度（等待运行的进程数）plist-sz：进程列表中进程（processes）和线程（threads）的数量ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载ldavg-15：过去15分钟的系统平均负载</code></pre><h5 id="使用-o选项保存sar命令的输出结果"><a href="#使用-o选项保存sar命令的输出结果" class="headerlink" title="使用-o选项保存sar命令的输出结果"></a>使用-o选项保存sar命令的输出结果</h5><pre><code>[root@bogon ~]# sar 2 5 -o /tmp/cpu_data.log &gt;/dev/null 2&gt;&amp;1</code></pre><p>使用”sar -f”输出结果(否则将出现乱码)：</p><pre><code>[root@bogon ~]# sar -f /tmp/cpu_data.log Linux 3.10.0-327.el7.x86_64 (bogon)     05/16/2018     _x86_64_    (8 CPU)04:19:56 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle04:19:58 AM     all      0.00      0.00      0.06      0.00      0.00     99.94......</code></pre><h5 id="使用-r选项生成内存的使用情况报告"><a href="#使用-r选项生成内存的使用情况报告" class="headerlink" title="使用-r选项生成内存的使用情况报告"></a>使用-r选项生成内存的使用情况报告</h5><pre><code>[root@bogon ~]# sar -r 2 5Linux 3.10.0-327.el7.x86_64 (bogon)     05/16/2018     _x86_64_    (8 CPU)......kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</code></pre><h5 id="w选项查看页面交换发生情况"><a href="#w选项查看页面交换发生情况" class="headerlink" title="-w选项查看页面交换发生情况"></a>-w选项查看页面交换发生情况</h5><pre><code>[root@bogon ~]# sar -w  1 3Linux 3.10.0-327.el7.x86_64 (bogon)     05/16/2018     _x86_64_    (8 CPU)04:41:37 AM  pswpin/s pswpout/s04:41:38 AM      0.00      0.0004:41:39 AM      0.00      0.0004:41:40 AM      0.00      0.00Average:         0.00      0.00pswpin/s：每秒系统换入的交换页面（swap page）数量pswpout/s：每秒系统换出的交换页面（swap page）数量</code></pre><h5 id="使用-d选项生成块设备使用情况报告"><a href="#使用-d选项生成块设备使用情况报告" class="headerlink" title="使用-d选项生成块设备使用情况报告"></a>使用-d选项生成块设备使用情况报告</h5><pre><code>-d 选项在sar命令中被用以显示块设备的状态报告。在 -d 后面加上 -p  (pretty-print)选项可以增强 dev 列的可读性.[root@bogon ~]# sar -d -p 2 4Linux 3.10.0-327.el7.x86_64 (bogon)     05/16/2018     _x86_64_    (8 CPU)04:30:46 AM  DEV  tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util04:30:48 AM  sda  0.00   0.00      0.00      0.00      0.00      0.00      0.00      0.0004:30:48 AM  sdb  0.00   0.00      0.00      0.00      0.00      0.00      0.00      0.00......</code></pre><h5 id="使用-n选项生成网络使用情况报告"><a href="#使用-n选项生成网络使用情况报告" class="headerlink" title="使用-n选项生成网络使用情况报告"></a>使用-n选项生成网络使用情况报告</h5><pre><code>-n选项在sar命令中被用来生成网络使用情况的统计报告。下面是语法规则：# sar -n {keyword} or {ALL}</code></pre><pre><code># sar -n ALL</code></pre><h5 id="用-f读sar日志文件"><a href="#用-f读sar日志文件" class="headerlink" title="用-f读sar日志文件"></a>用-f读sar日志文件</h5><pre><code>sar的日志文件是保存在“/var/log/sa/saDD”里的。使用-f选项可以查看日志文件。</code></pre><pre><code>[root@bogon ~]# sar -r -f /var/log/sa/sa16 </code></pre><h5 id="输出前两个核心CPU的使用情况"><a href="#输出前两个核心CPU的使用情况" class="headerlink" title="输出前两个核心CPU的使用情况"></a>输出前两个核心CPU的使用情况</h5><pre><code>[root@bogon ~]# sar  -u  -P 0,1</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>要判断系统瓶颈问题，通常需几个sar命令选项结合起来；怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</code></pre><h4 id="sar参数说明"><a href="#sar参数说明" class="headerlink" title="sar参数说明"></a>sar参数说明</h4><pre><code>-A 汇总所有的报告-a 报告文件读写使用情况-B 报告附加的缓存的使用情况-b 报告缓存的使用情况-c 报告系统调用的使用情况-d 报告磁盘的使用情况-g 报告串口的使用情况-h 报告关于buffer使用的统计数据-m 报告IPC消息队列和信号量的使用情况-n 报告命名cache的使用情况-p 报告调页活动的使用情况-q 报告运行队列和交换队列的平均长度-R 报告进程的活动情况-r 报告没有使用的内存页面和硬盘块-u 报告CPU的利用率-v 报告进程、i节点、文件和锁表状态-w 报告系统交换活动状况-y 报告TTY设备活动状况</code></pre><p>参考: <a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds5/sar.htm" target="_blank" rel="noopener">IBM等</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;SAR是一个在Unix和Linux操作系统中用来收集、报告和保存CPU、内存、输入输出端口使用情况的命令。

sar 命令将操作系统中选定的累计活动计数器的内容写到标准输出。基于 number 和 interval 参数的值，记帐系统按指定次数，以指定的时间间隔（以秒为单位）写入信息。number 参数的缺省采样时间间隔为 1 秒。收集的数据也可以保存在由 -o file 标志指定的文件中。

当指定 –X 选项时，sar 命令会生成 XML 文件。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="系统瓶颈" scheme="https://wuyanteng.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%93%B6%E9%A2%88/"/>
    
      <category term="sar" scheme="https://wuyanteng.github.io/tags/sar/"/>
    
      <category term="System Activity Reporter" scheme="https://wuyanteng.github.io/tags/System-Activity-Reporter/"/>
    
      <category term="系统活动情况报告" scheme="https://wuyanteng.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%B4%BB%E5%8A%A8%E6%83%85%E5%86%B5%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>带有附加数据的加密算法-libsodium</title>
    <link href="https://wuyanteng.github.io/2018/05/16/%E5%B8%A6%E6%9C%89%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86-libsodium/"/>
    <id>https://wuyanteng.github.io/2018/05/16/带有附加数据的认证加密-libsodium/</id>
    <published>2018-05-16T02:17:14.000Z</published>
    <updated>2018-05-16T02:51:41.647Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Libsodium支持的加密"><a href="#Libsodium支持的加密" class="headerlink" title="Libsodium支持的加密"></a>Libsodium支持的加密</h5><pre><code>Libsodium 支持两种流行的加密算法: AES256-GCM 和 ChaCha20-Poly1305(原始版和IETF版) ，另一种是后者的一种变体，即: XChaCha20-Poly1305</code></pre><a id="more"></a><h5 id="加密信息对比"><a href="#加密信息对比" class="headerlink" title="加密信息对比"></a>加密信息对比</h5><table><thead><tr><th>加密方式</th><th>Key  大小</th><th>Nonce大小</th><th>Block大小</th><th>MAC  大小</th><th>对应libsodium版本</th></tr></thead><tbody><tr><td>AES-256-GCM</td><td>256  比特</td><td>96比特</td><td>128  比特</td><td>128  比特</td><td>libsodium &gt;= 1.0.4 but requires hardware support. IETF standard; also implemented in many other libraries.</td></tr><tr><td>ChaCha20-Poly1305</td><td>256  比特</td><td>64比特</td><td>512  比特</td><td>128  比特</td><td>libsodium &gt;= 0.6.0. Also implemented in {Libre,Open,Boring}SSL.</td></tr><tr><td>ChaCha20-IETF-Poly1305</td><td>256  比特</td><td>96比特</td><td>512  比特</td><td>128  比特</td><td>libsodium &gt;= 1.0.4. IETF standard; also implemented in Ring, {Libre,Open,Boring}SSL and other libraries.</td></tr><tr><td>XChaCha20-IETF-Poly1305</td><td>256  比特</td><td>192  比特</td><td>512  比特</td><td>128  比特</td><td>libsodium &gt;= 1.0.12.</td></tr></tbody></table><h5 id="加密方式选择"><a href="#加密方式选择" class="headerlink" title="加密方式选择"></a>加密方式选择</h5><pre><code>Xchacha20-poly1305-ietf是相对最安全的</code></pre><h5 id="AES-256-GCM"><a href="#AES-256-GCM" class="headerlink" title="AES-256-GCM"></a>AES-256-GCM</h5><pre><code>目前这种结构支持硬件加速，需要Intel SSSE3扩展，以及 aesni 和 pclmul。官方暂无计划将AES-256-GCM通过非硬件技术(即软件层)来实现</code></pre><h5 id="ChaCha20-Poly1305"><a href="#ChaCha20-Poly1305" class="headerlink" title="ChaCha20-Poly1305"></a>ChaCha20-Poly1305</h5><pre><code>虽然AES-256-GCM在专用硬件上速度非常快，但在非专用硬件上性能要低得多。并且, AES容易受到缓存冲突时间的攻击。ChaCha20在纯软件方面加密就比AES快得多，在缺乏专用AES硬件的平台上速度比其快三倍。 并且, ChaCha20对定时攻击也不敏感。而Poly1305是一种高速信息验证码。ChaCha20流密码+Poly1305认证的组合的使得其成为了Salsa20-Poly1305加密方式的替代品。其于2015年5月成为IETF官方标准，所以目前很多主流操作系统均以支持ChaCha20-Poly1305，</code></pre><h5 id="XChaCha20-IETF-Poly1305"><a href="#XChaCha20-IETF-Poly1305" class="headerlink" title="XChaCha20-IETF-Poly1305"></a>XChaCha20-IETF-Poly1305</h5><pre><code>XChaCha20-Poly1305继承了ChaCha20-Poly1305所有优势并将随机文件nonce大小扩展到192位。这种扩展的随机数大小允许安全使用随机数。libsodium中的XChaCha20-Poly1305实现可在所有支持的体系结构中移植。这种加密需要 &gt;=libsodium 1.0.12的版本方能支持。</code></pre><p>翻译自:<a href="https://download.libsodium.org/doc/secret-key_cryptography/aead.html" target="_blank" rel="noopener">Libsodium官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Libsodium支持的加密&quot;&gt;&lt;a href=&quot;#Libsodium支持的加密&quot; class=&quot;headerlink&quot; title=&quot;Libsodium支持的加密&quot;&gt;&lt;/a&gt;Libsodium支持的加密&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Libsodium 支持两种流行的加密算法: AES256-GCM 和 ChaCha20-Poly1305(原始版和IETF版) ，另一种是后者的一种变体，即: XChaCha20-Poly1305
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="libsodium" scheme="https://wuyanteng.github.io/tags/libsodium/"/>
    
      <category term="AES-256-GCM" scheme="https://wuyanteng.github.io/tags/AES-256-GCM/"/>
    
      <category term="ChaCha20-Poly1305" scheme="https://wuyanteng.github.io/tags/ChaCha20-Poly1305/"/>
    
      <category term="XChaCha20-Poly1305" scheme="https://wuyanteng.github.io/tags/XChaCha20-Poly1305/"/>
    
      <category term="AEAD加密" scheme="https://wuyanteng.github.io/tags/AEAD%E5%8A%A0%E5%AF%86/"/>
    
      <category term="加密算法" scheme="https://wuyanteng.github.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>shell if小数判断</title>
    <link href="https://wuyanteng.github.io/2018/05/10/shell-if%E5%B0%8F%E6%95%B0%E5%88%A4%E6%96%AD/"/>
    <id>https://wuyanteng.github.io/2018/05/10/shell-if小数判断/</id>
    <published>2018-05-10T10:27:18.000Z</published>
    <updated>2018-05-10T10:34:03.375Z</updated>
    
    <content type="html"><![CDATA[<pre><code>由于程序需要，我要判断一个小数是否大于另一个值。即一个浮点数是否大于另一个浮点数。</code></pre><a id="more"></a><pre><code>加入$mya变量是一个浮点数，按照正常思路执行：# if [ $mya -le 4 ]; then echo &quot;ok&quot;;else echo &quot;fail&quot;; fi  -bash: [: 5.7: integer expression expected  shell报错：提示integer expression expected意思就是shell默认只能判断整数，而不是浮点数</code></pre><pre><code>参考了大牛的方案，改为了如下：# if [ $(echo &quot;$mya &lt;= 4&quot;|bc) = 1 ]; then echo &quot;ok&quot;;else echo &quot;fail&quot;;fi  </code></pre><pre><code>测试：# if [ $(echo &quot;0.5 &lt;= 4&quot;|bc) = 1 ]; then echo &quot;ok&quot;;else echo &quot;fail&quot;;fi  ok# if [ $(echo &quot;0.5 &gt;= 4&quot;|bc) = 1 ]; then echo &quot;ok&quot;;else echo &quot;fail&quot;;fi  fail# if [ $(echo &quot;5.5 &gt;= 4&quot;|bc) = 1 ]; then echo &quot;ok&quot;;else echo &quot;fail&quot;;fi  ok# if [ $(echo &quot;4.1 &gt;= 4&quot;|bc) = 1 ]; then echo &quot;ok&quot;;else echo &quot;fail&quot;;fi ok</code></pre><pre><code>接下来终于可以愉快的写脚本了...</code></pre><p>参考：<a href="http://nigelzeng.iteye.com/blog/1604640" target="_blank" rel="noopener">nigelzeng</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;由于程序需要，我要判断一个小数是否大于另一个值。即一个浮点数是否大于另一个浮点数。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="小数判断" scheme="https://wuyanteng.github.io/tags/%E5%B0%8F%E6%95%B0%E5%88%A4%E6%96%AD/"/>
    
      <category term="if判断" scheme="https://wuyanteng.github.io/tags/if%E5%88%A4%E6%96%AD/"/>
    
      <category term="浮点数判断" scheme="https://wuyanteng.github.io/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>curl命令详解</title>
    <link href="https://wuyanteng.github.io/2018/05/09/curl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wuyanteng.github.io/2018/05/09/curl命令详解/</id>
    <published>2018-05-09T06:17:40.000Z</published>
    <updated>2018-05-09T07:30:28.103Z</updated>
    
    <content type="html"><![CDATA[<pre><code>curl是一个利用URL规则在命令行下工作的强大文件传输工具。语法：# curl [option] [url]</code></pre><a id="more"></a><h5 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h5><pre><code>-A/--user-agent &lt;string&gt;          设置用户代理发送给服务器-b/--cookie &lt;name=string/file&gt;    cookie字符串或文件读取位置-c/--cookie-jar &lt;file&gt;            操作结束后把cookie写入到这个文件中-C/--continue-at &lt;offset&gt;         断点续转-D/--dump-header &lt;file&gt;           把header信息写入到该文件中-e/--referer                      来源网址-f/--fail                         连接失败时不显示http错误-o/--output                       把输出写到该文件中-O/--remote-name                  把输出写到该文件中，保留远程文件的文件名-r/--range &lt;range&gt;                检索来自HTTP/1.1或FTP服务器字节范围-s/--silent                       静音模式。不输出任何东西-T/--upload-file &lt;file&gt;          上传文件-u/--user &lt;user[:password]&gt;      设置服务器的用户和密码-w/--write-out [format]          什么输出完成后-x/--proxy &lt;host[:port]&gt;         在给定的端口上使用HTTP代理-#/--progress-bar                进度条显示当前的传送状态</code></pre><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><pre><code>curl  http://www.baidu.com</code></pre><h5 id="保存访问的网页"><a href="#保存访问的网页" class="headerlink" title="保存访问的网页"></a>保存访问的网页</h5><pre><code>使用重定向功能保存curl http://www.baidu.com &gt;baidu.html</code></pre><pre><code>使用内置option选项保存curl -o qq.html http://www.qq.com</code></pre><h5 id="测试网页返回值"><a href="#测试网页返回值" class="headerlink" title="测试网页返回值"></a>测试网页返回值</h5><pre><code>curl -o /dev/null -s -w %{http_code} www.qq.com在脚本中，这是很常见的测试网站是否正常的用法</code></pre><h5 id="指定proxy服务器以及端口"><a href="#指定proxy服务器以及端口" class="headerlink" title="指定proxy服务器以及端口"></a>指定proxy服务器以及端口</h5><pre><code>通过-x 选项来支持设置http代理curl -x 10.10.10.100:1080 http://www.google.com</code></pre><h5 id="保存http的response里面的header信息"><a href="#保存http的response里面的header信息" class="headerlink" title="保存http的response里面的header信息"></a>保存http的response里面的header信息</h5><pre><code>curl -D header.txt http://www.qq.com</code></pre><h5 id="模仿浏览器User-agent"><a href="#模仿浏览器User-agent" class="headerlink" title="模仿浏览器User-agent"></a>模仿浏览器User-agent</h5><pre><code>curl -A &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en) AppleWebKit/48 (like Gecko) Safari/48&quot; http://www.qq.com &gt; qq.html</code></pre><p>参考：<a href="https://youruseragent.info/commonua.en.htm" target="_blank" rel="noopener">所有版本User-agent列表</a></p><h5 id="伪造referer-盗链"><a href="#伪造referer-盗链" class="headerlink" title="伪造referer-盗链"></a>伪造referer-盗链</h5><pre><code>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面。其中这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了</code></pre><pre><code>curl中内置-e 选项可以自定义referercurl -e &quot;www.qq.com&quot; https://mail.qq.com</code></pre><h5 id="下载显示进度条"><a href="#下载显示进度条" class="headerlink" title="下载显示进度条"></a>下载显示进度条</h5><pre><code>curl -# -O https://codeload.github.com/shadowsocks/shadowsocks-windows/zip/master注：-#表示显示进度条</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;curl是一个利用URL规则在命令行下工作的强大文件传输工具。

语法：
# curl [option] [url]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="curl" scheme="https://wuyanteng.github.io/tags/curl/"/>
    
      <category term="cookie" scheme="https://wuyanteng.github.io/tags/cookie/"/>
    
      <category term="POST" scheme="https://wuyanteng.github.io/tags/POST/"/>
    
      <category term="response" scheme="https://wuyanteng.github.io/tags/response/"/>
    
      <category term="模拟浏览器" scheme="https://wuyanteng.github.io/tags/%E6%A8%A1%E6%8B%9F%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="伪造referer" scheme="https://wuyanteng.github.io/tags/%E4%BC%AA%E9%80%A0referer/"/>
    
  </entry>
  
  <entry>
    <title>让mongo的从库支持读操作</title>
    <link href="https://wuyanteng.github.io/2018/04/28/%E8%AE%A9mongo%E7%9A%84%E4%BB%8E%E5%BA%93%E6%94%AF%E6%8C%81%E8%AF%BB%E6%93%8D%E4%BD%9C/"/>
    <id>https://wuyanteng.github.io/2018/04/28/让mongo的从库支持读操作/</id>
    <published>2018-04-28T03:41:26.000Z</published>
    <updated>2018-04-28T03:52:04.562Z</updated>
    
    <content type="html"><![CDATA[<pre><code>对于replica set 中的secondary 节点默认是不可读的。通过在连接时指定或者在主库指定slaveOk，由Secondary来分担读的压力，Primary只承担写操作。</code></pre><a id="more"></a><pre><code>如果通过shell访问mongo，要在secondary进行查询。会出现如下错误：#mongo 192.168.10.10:27017SECONDARY&gt; show dbs;2018-04-28T11:28:17.596+0800 E QUERY    Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }    at Error (&lt;anonymous&gt;)    at Mongo.getDBs (src/mongo/shell/mongo.js:47:15)    at shellHelper.show (src/mongo/shell/utils.js:630:33)    at shellHelper (src/mongo/shell/utils.js:524:36)    at (shellhelp2):1:1 at src/mongo/shell/mongo.js:47SECONDARY&gt; </code></pre><h4 id="有两种方法实现从机的查询："><a href="#有两种方法实现从机的查询：" class="headerlink" title="有两种方法实现从机的查询："></a>有两种方法实现从机的查询：</h4><h5 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h5><pre><code>db.getMongo().setSlaveOk();</code></pre><h5 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h5><pre><code>rs.slaveOk();</code></pre><pre><code>但是这种方式有一个缺点就是，下次再通过mongo进入实例的时候，查询仍然会报错，为此可以通过下列方式vi ~/.mongorc.js增加一行rs.slaveOk();这样的话以后每次通过mongo命令进入都可以查询了</code></pre><h5 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法:"></a>第三种方法:</h5><pre><code>在配置mongo的时候增加slave-ok=&quot;true&quot;  来实现从secondary中进行读操作。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;对于replica set 中的secondary 节点默认是不可读的。通过在连接时指定或者在主库指定slaveOk，由Secondary来分担读的压力，Primary只承担写操作。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mongodb" scheme="https://wuyanteng.github.io/tags/mongodb/"/>
    
      <category term="mongo" scheme="https://wuyanteng.github.io/tags/mongo/"/>
    
      <category term="rs.slaveOk()" scheme="https://wuyanteng.github.io/tags/rs-slaveOk/"/>
    
      <category term="mongodb从库读操作" scheme="https://wuyanteng.github.io/tags/mongodb%E4%BB%8E%E5%BA%93%E8%AF%BB%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Parted给大容量硬盘分区格式化与挂载</title>
    <link href="https://wuyanteng.github.io/2018/04/27/Parted%E7%BB%99%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E6%8C%82%E8%BD%BD/"/>
    <id>https://wuyanteng.github.io/2018/04/27/Parted给大容量硬盘分区格式化与挂载/</id>
    <published>2018-04-27T10:06:10.000Z</published>
    <updated>2018-04-27T10:15:55.690Z</updated>
    
    <content type="html"><![CDATA[<pre><code>使用parted给大于2T的硬盘分区</code></pre><a id="more"></a><pre><code>查看现有设备fdisk -l使用parted分区#parted(parted) select /dev/sdb      //选择磁盘sdbUsing /dev/sdb(parted) mklabel gpt          //将MBR磁盘格式化为GPT(parted) mkpart primary 0 -1  //将整块磁盘分成一个分区(parted) printquit###################################或者创建多个分区mkpart primary 0 3Gmkpart primary 3G 10Gmkpart primary 10G -1###################################快速格式化mkfs.ext4 -T largefile /dev/sdb1 对/dev/sdb1添加（修改）标签为/data1e2label /dev/sdb1 /data1 查看分区的标签e2label /dev/sdb1 在/分区下创建一个配额的挂载点mkdir /data/B对该分区进行手动挂载mount /dev/sdb1 /data/B 查看挂载的分区df -h 最后只需在fstab中添加如下一行或使用UUID，就能完成分区的自动挂载[root@server ~]# vim /etc/fstab/dev/sdb1 /data1 ext3 defaults 0 0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;使用parted给大于2T的硬盘分区
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="parted" scheme="https://wuyanteng.github.io/tags/parted/"/>
    
      <category term="fdisk" scheme="https://wuyanteng.github.io/tags/fdisk/"/>
    
  </entry>
  
</feed>
