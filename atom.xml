<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gary Wu</title>
  
  <subtitle>运维架构师 - 从入门到放弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyanteng.github.io/"/>
  <updated>2018-09-18T07:58:14.244Z</updated>
  <id>https://wuyanteng.github.io/</id>
  
  <author>
    <name>Gary Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql主从库同步出现主键错误-分析</title>
    <link href="https://wuyanteng.github.io/2018/09/18/mysql%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E5%87%BA%E7%8E%B0%E4%B8%BB%E9%94%AE%E9%94%99%E8%AF%AF-%E5%88%86%E6%9E%90/"/>
    <id>https://wuyanteng.github.io/2018/09/18/mysql主从库同步出现主键错误-分析/</id>
    <published>2018-09-18T07:45:38.000Z</published>
    <updated>2018-09-18T07:58:14.244Z</updated>
    
    <content type="html"><![CDATA[<pre><code>mysql主库数据量TB级别，废了九牛二虎之力做了从库，一切正常。过了没几天，出现了主键等错误。</code></pre><p>原因分析</p><pre><code>造成此问题的原因 与主库数据量几乎没有关系，很大可能是因为从库被写入了数据，导致主从主键不一致。</code></pre><a id="more"></a><p>建议</p><pre><code>1. 从库启用read_only, 配置文件添加如下配置【也可动态配置，无需重启服务】：   read_only = ON   super_read_only = ON2. 主从均开启GTID3. 主从均使用ROW格式</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;mysql主库数据量TB级别，废了九牛二虎之力做了从库，一切正常。过了没几天，出现了主键等错误。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原因分析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;造成此问题的原因 与主库数据量几乎没有关系，很大可能是因为从库被写入了数据，导致主从主键不一致。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="主从同步" scheme="https://wuyanteng.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
      <category term="mysql" scheme="https://wuyanteng.github.io/tags/mysql/"/>
    
      <category term="主键错误" scheme="https://wuyanteng.github.io/tags/%E4%B8%BB%E9%94%AE%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>重温ps命令</title>
    <link href="https://wuyanteng.github.io/2018/09/14/%E9%87%8D%E6%B8%A9ps-aux%E5%91%BD%E4%BB%A4/"/>
    <id>https://wuyanteng.github.io/2018/09/14/重温ps-aux命令/</id>
    <published>2018-09-14T02:48:20.000Z</published>
    <updated>2018-09-14T03:04:24.028Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Linux下最常用的2个命令：ps -efps aux来重新温习下他们两个命令的区别</code></pre><a id="more"></a><h4 id="ps-ef能输出什么内容："><a href="#ps-ef能输出什么内容：" class="headerlink" title="ps -ef能输出什么内容："></a>ps -ef能输出什么内容：</h4><pre><code>[root@gfw_proxy_15 ~]# ps -ef|headUID        PID  PPID  C STIME TTY          TIME CMDroot         8     2  0 Jul13 ?        00:00:00 [rcu_bh]root         9     2  0 Jul13 ?        00:00:00 [rcuob/0]root        10     2  0 Jul13 ?        00:00:00 [rcuob/1]root        11     2  0 Jul13 ?        00:00:00 [rcuob/2]</code></pre><pre><code>UID     //用户ID、但输出的是用户名PID     //进程的IDPPID    //父进程IDC       //进程占用CPU的百分比STIME   //进程启动到现在的时间TTY     //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。CMD     //命令的名称和参数</code></pre><h4 id="ps-aux能输出什么内容？"><a href="#ps-aux能输出什么内容？" class="headerlink" title="ps aux能输出什么内容？"></a>ps aux能输出什么内容？</h4><pre><code>[root@gfw_proxy_15 ~]# ps aux|headUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.0 123308  3820 ?        Ss   Jul13  45:58 /usr/lib/systemd/systemd...root         2  0.0  0.0      0     0 ?        S    Jul13   0:04 [kthreadd]root         3  0.0  0.0      0     0 ?        S    Jul13   0:14 [ksoftirqd/0]</code></pre><pre><code>USER      //用户名PID       //PID%CPU      //进程占用的CPU百分比%MEM      //占用内存的百分比VSZ       //该进程使用的虚拟內存量（KB）RSS       //该进程占用的固定內存量（KB）（驻留中页的数量）STAT      //进程的状态START     //该进程被触发启动时间TIME      //该进程实际使用CPU运行的时间</code></pre><h4 id="查看进程占用的CPU和内存大小"><a href="#查看进程占用的CPU和内存大小" class="headerlink" title="查看进程占用的CPU和内存大小"></a>查看进程占用的CPU和内存大小</h4><pre><code># ps aux |grep openvpnroot     18493  0.7  0.1  12336  3888 ?        Sl   Sep13   7:54 /usr/sbin/openvpn.....上面第3列是CPU占用百分比；上面第6列，是进程所占用的固定内存,单位k(除以1000单位是M)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Linux下最常用的2个命令：
ps -ef
ps aux

来重新温习下他们两个命令的区别
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ps" scheme="https://wuyanteng.github.io/tags/ps/"/>
    
      <category term="aux" scheme="https://wuyanteng.github.io/tags/aux/"/>
    
      <category term="查看进程内存" scheme="https://wuyanteng.github.io/tags/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>date时间戳转换</title>
    <link href="https://wuyanteng.github.io/2018/09/13/date%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2/"/>
    <id>https://wuyanteng.github.io/2018/09/13/date时间戳转换/</id>
    <published>2018-09-13T06:12:01.000Z</published>
    <updated>2018-09-13T06:18:27.767Z</updated>
    
    <content type="html"><![CDATA[<pre><code>linux时间戳转换</code></pre><p>查看当前unix时间戳</p><pre><code>date +%s变量赋值Now_UNIX=`date +%s`</code></pre><a id="more"></a><p>标准时间转unix</p><pre><code>date -d &quot;2017-08-01 00:00:00&quot; +%s变量赋值UNIX=`date -d &quot;2017-08-01 00:00:00&quot; +%s`</code></pre><p>unix转标准时间</p><pre><code>date -d &quot;@1536819453&quot; </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;linux时间戳转换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看当前unix时间戳&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date +%s

变量赋值
Now_UNIX=`date +%s`
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="unix" scheme="https://wuyanteng.github.io/tags/unix/"/>
    
      <category term="date" scheme="https://wuyanteng.github.io/tags/date/"/>
    
      <category term="时间戳" scheme="https://wuyanteng.github.io/tags/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    
      <category term="time" scheme="https://wuyanteng.github.io/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>基于easyrsa3自动化实现openvpn用户证书的创建与吊销</title>
    <link href="https://wuyanteng.github.io/2018/09/12/%E5%9F%BA%E4%BA%8Eeasyrsa3%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E7%8E%B0openvpn%E7%94%A8%E6%88%B7%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%8A%E9%94%80/"/>
    <id>https://wuyanteng.github.io/2018/09/12/基于easyrsa3自动化实现openvpn用户证书的创建与吊销/</id>
    <published>2018-09-12T08:36:25.000Z</published>
    <updated>2018-09-12T08:47:16.343Z</updated>
    
    <content type="html"><![CDATA[<pre><code>写个脚本，一键创建用户证书与吊销证书，使用格式：想要的效果--使用方法sh vpn.sh add/del username</code></pre><pre><code>前提：(1)自己能通过SSH登陆到自己，即ssh免密登陆(2)提前安装好所需包   yum install -y expect expect-devel tcl问题：为什么要这么做？因为自己的openvpn证书基于easyrsa3的版本进行创建，而此版本并不能使用pkitool的参数来方便快捷的解决免交互的问题【pkitool不支持easyrsa3, 只适用于easyrsa2】，所以只能借助于expect实现免交互</code></pre><a id="more"></a><pre><code>#!/bin/bashif [ $# != 2 ];then   echo &quot;USAGE: sh $0 add/del username&quot;   exit 1;fi#定义变量AD=$1USER=$2PASS=`head -c 100 /dev/urandom | tr -dc a-z0-9A-Z |head -c 16`DIR1=/opt/easy-rsa-3.0.5/easyrsa3DIR2=/etc/openvpn/easy-rsa/easyrsa3TMP=/tmp/openvpn.ept#解决签约错误cd $DIR2/pkiif [ -f index.txt ];then   rm -f index.txt &amp;&amp; touch index.txtfi#创建客户端证书if [ &quot;$AD&quot; == &quot;add&quot; ];thencat &gt; $TMP &lt;&lt; EOF#!/usr/bin/expectspawn ssh -p22 root@192.168.0.11set timeout -1expect &quot;]#&quot;send -- &quot;cd $DIR1\r&quot;sleep 2expect &quot;]#&quot;send -- &quot;echo &#39;yes&#39;|./easyrsa gen-req $USER\r&quot;sleep 5expect &quot;phrase:&quot;send -- &quot;$PASS\r&quot;expect &quot;phrase:&quot;send -- &quot;$PASS\r&quot;expect  &quot;]:&quot;send -- &quot;\r&quot;sleep 3expect &quot;]#&quot;   send -- &quot;cd $DIR2\r&quot;expect &quot;]#&quot;send -- &quot;./easyrsa import-req $DIR1/pki/reqs/$USER.req $USER\r&quot; sleep 3expect  &quot;]#&quot;send -- &quot;./easyrsa sign client $USER\r&quot;expect  &quot;details: &quot;send -- &quot;yes\r&quot;expect  &quot;key:&quot;send -- &quot;CA passwd\r&quot;expect  &quot;]#&quot;send -- &quot;exit\r&quot;expect eofEOF#运行expect脚本pass_file=$DIR1/pass_filestat_file=/tmp/openvpn_add_del.logecho &quot;$USER  $PASS&quot; &gt;&gt;$pass_fileuserpass=`tail -1 $pass_file`echo &quot;#..................................#&quot;echo &quot;  OVPN用户账号自动创建中...请稍等   &quot;echo &quot;#..................................#&quot;/usr/bin/expect -f $TMP &gt;$stat_fileif [ $? -ne 0 ];then   echo &quot;用户证书文件创建异常,请检查&quot;fi#拷贝crt/keymkdir -p $DIR1/users/$USERcp $DIR2/pki/issued/$USER.crt $DIR1/users/$USER/cp $DIR1/pki/private/$USER.key $DIR1/users/$USER/echo &quot;#.....用户账号创建完成,详情如下........#&quot;echo &quot;                                        &quot;echo &quot;用户crt/key下载目录：$DIR1/users/$USER&quot;echo &quot;用户证书密码[请牢记]: $userpass&quot;echo &quot;                                        &quot;echo &quot;#......................................#&quot;#写入随机数到文件,用于sync md5变更依据echo &quot;$PASS&quot; &gt;&gt;/tmp/ovpn_create.logrm $TMPfi#吊销用户证书if [ &quot;$AD&quot; == &quot;del&quot; ];thenTMP2=/tmp/ovpn_revoke.eptstat_file2=/tmp/ovpn_revoke.logcat &gt; $TMP2 &lt;&lt; EOF#!/usr/bin/expectspawn ssh -p22 root@192.168.0.11set timeout -1expect &quot;]#&quot;send -- &quot;cd $DIR2\r&quot;expect &quot;]#&quot;send -- &quot;./easyrsa revoke $USER\r&quot;expect &quot;revocation: &quot;send -- &quot;yes\r&quot;expect &quot;key:&quot;send -- &quot;CA passwd\r&quot;expect &quot;]#&quot;send -- &quot;./easyrsa gen-crl\r&quot;expect &quot;key:&quot;send -- &quot;CA passwd\r&quot;expect  &quot;]#&quot;send -- &quot;exit\r&quot;expect eofEOFecho &quot;#..................................#&quot;echo &quot;  OVPN账号自动吊销中...请稍等   &quot;echo &quot;#..................................#&quot;/usr/bin/expect -f $TMP2 &gt;${stat_file2}if [ $? -ne 0 ];then   echo &quot;用户证书吊销出现问题,请检查&quot;fi\cp /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem /etc/openvpn/num1=`ps -ef|grep &quot;server.conf&quot;|grep -v grep|awk &#39;{print $2}&#39;`kill -9 $num1 &amp;&amp; sleep 2 /usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf  &gt; /tmp/open.log 2&gt;&amp;1 &amp; if [ $? -eq 0 ];then   echo &quot;警告: $USER账号已被注销, 即刻生效!&quot;firm $TMP2fi</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;写个脚本，一键创建用户证书与吊销证书，使用格式：

想要的效果--使用方法
sh vpn.sh add/del username
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;前提：
(1)自己能通过SSH登陆到自己，即ssh免密登陆
(2)提前安装好所需包
   yum install -y expect expect-devel tcl

问题：为什么要这么做？
因为自己的openvpn证书基于easyrsa3的版本进行创建，而此版本并不能使用pkitool的参数来方便快捷的解决免交互的问题【pkitool不支持easyrsa3, 只适用于easyrsa2】，所以只能借助于expect实现免交互
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="openvpn" scheme="https://wuyanteng.github.io/tags/openvpn/"/>
    
      <category term="expect" scheme="https://wuyanteng.github.io/tags/expect/"/>
    
      <category term="easyrsa" scheme="https://wuyanteng.github.io/tags/easyrsa/"/>
    
      <category term="ssh免交互" scheme="https://wuyanteng.github.io/tags/ssh%E5%85%8D%E4%BA%A4%E4%BA%92/"/>
    
      <category term="免交互" scheme="https://wuyanteng.github.io/tags/%E5%85%8D%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>编译安装cmake3和boost1.65</title>
    <link href="https://wuyanteng.github.io/2018/09/07/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85cmake3%E5%92%8Cboost1-65/"/>
    <id>https://wuyanteng.github.io/2018/09/07/编译安装cmake3和boost1-65/</id>
    <published>2018-09-07T12:55:58.000Z</published>
    <updated>2018-09-07T12:58:15.431Z</updated>
    
    <content type="html"><![CDATA[<pre><code>编译安装cmake3和boost1.65版本</code></pre><h4 id="编译安装cmake3-10"><a href="#编译安装cmake3-10" class="headerlink" title="编译安装cmake3.10"></a>编译安装cmake3.10</h4><pre><code>wget https://cmake.org/files/v3.10/cmake-3.10.2.tar.gztar -zxvf cmake-3.10.2.tar.gzcd cmake-3.10.2./bootstrap --prefix=/usrmake &amp;&amp; sudo make installcmake --version</code></pre><a id="more"></a><h4 id="编译安装bootst1-65-1"><a href="#编译安装bootst1-65-1" class="headerlink" title="编译安装bootst1.65.1"></a>编译安装bootst1.65.1</h4><pre><code>wget https://dl.bintray.com/boostorg/release/1.65.1/source/boost_1_65_1.tar.gztar zxvf boost_1_65_1.tar.gz使用bootstrap来生成编译工具b2sudo ./bootstrap.sh  使用b2安装sudo ./b2 install            安装Boost.Build(1)进入&quot;tools/build&quot;目录    cd tools/build(2)使用 bootstrap来生成编译工具b2    sudo ./bootstrap.sh(3)使用b2安装    sudo ./b2 install</code></pre><pre><code>查看boost版本cat /usr/local/include/boost/version.hpp | grep &quot;BOOST_LIB_VERSION&quot;结果如下：//  BOOST_LIB_VERSION must be defined to be the same as BOOST_VERSION#define BOOST_LIB_VERSION &quot;1_65_1&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;编译安装cmake3和boost1.65版本
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;编译安装cmake3-10&quot;&gt;&lt;a href=&quot;#编译安装cmake3-10&quot; class=&quot;headerlink&quot; title=&quot;编译安装cmake3.10&quot;&gt;&lt;/a&gt;编译安装cmake3.10&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;wget https://cmake.org/files/v3.10/cmake-3.10.2.tar.gz
tar -zxvf cmake-3.10.2.tar.gz
cd cmake-3.10.2
./bootstrap --prefix=/usr
make &amp;amp;&amp;amp; sudo make install
cmake --version
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="cmake3" scheme="https://wuyanteng.github.io/tags/cmake3/"/>
    
      <category term="boost" scheme="https://wuyanteng.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>编译安装openssl</title>
    <link href="https://wuyanteng.github.io/2018/09/07/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openssl/"/>
    <id>https://wuyanteng.github.io/2018/09/07/编译安装openssl/</id>
    <published>2018-09-07T12:40:12.000Z</published>
    <updated>2018-09-07T12:54:45.547Z</updated>
    
    <content type="html"><![CDATA[<pre><code>本文主要记录openssl编译安装以及lib库的正确加载问题注：如果之前有yum或apt安装过openssl，建议卸载干净再继续。不建议手动删除老版本文件，否则后果可能很严重。</code></pre><a id="more"></a><p>编译安装openssl</p><p>官网：<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">下载</a></p><pre><code>wget https://www.openssl.org/source/openssl-1.0.2p.tar.gztar -xzf openssl-1.0.2p.tar.gzcd openssl-1.0.2p./config --prefix=/usr/local/opensslmake &amp;&amp; make install</code></pre><pre><code>命令软链【或添加环境变量均可】ln -sv /usr/local/openssl/bin/openssl /usr/bin/opensslopenssl version</code></pre><pre><code>打印openssl库文件所依赖的共享库列表ldd /usr/local/openssl/bin/openssl</code></pre><pre><code>加载openssl新版lib库cat /etc/ld.so.conf新增如下行：/usr/local/openssl/lib生效ldconfig /etc/ld.so.conf</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;本文主要记录openssl编译安装以及lib库的正确加载问题

注：如果之前有yum或apt安装过openssl，建议卸载干净再继续。不建议手动删除老版本文件，否则后果可能很严重。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="openssl" scheme="https://wuyanteng.github.io/tags/openssl/"/>
    
      <category term="libssl" scheme="https://wuyanteng.github.io/tags/libssl/"/>
    
      <category term="libcrypto" scheme="https://wuyanteng.github.io/tags/libcrypto/"/>
    
  </entry>
  
  <entry>
    <title>certbot免费证书申请</title>
    <link href="https://wuyanteng.github.io/2018/09/04/certbot%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"/>
    <id>https://wuyanteng.github.io/2018/09/04/certbot免费证书申请/</id>
    <published>2018-09-04T07:02:53.000Z</published>
    <updated>2018-09-04T07:09:15.064Z</updated>
    
    <content type="html"><![CDATA[<pre><code> Let&#39;s Encrypt Certbot生成免费证书</code></pre><p>Certbot官网：<a href="https://certbot.eff.org" target="_blank" rel="noopener">链接</a></p><a id="more"></a><h4 id="安装cerbot"><a href="#安装cerbot" class="headerlink" title="安装cerbot"></a>安装cerbot</h4><pre><code>在certbot官网选择对应的操作系统，安装其提供的方法来安装certbotyum -y install yum-utilsyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optionalyum install -y certbot</code></pre><h4 id="使用certbot-certonly命令-生成证书公私钥-支持多域名"><a href="#使用certbot-certonly命令-生成证书公私钥-支持多域名" class="headerlink" title="使用certbot certonly命令,生成证书公私钥(支持多域名)"></a>使用certbot certonly命令,生成证书公私钥(支持多域名)</h4><pre><code>生成证书certbot certonly --webroot -w /home/sites/webroot1 -d domain1.com或certbot certonly --webroot -w /home/sites/webroot1 -d domain1.com  -w /home/sites/webroot2/ -d www.domain2.com此过程中 Certbot 会创建随机文件，然后远程验证域名及服务控制权新生成的证书及相关文件，将生成到 /etc/letsencrypt 路径下。</code></pre><pre><code>/etc/letsencrypt目录结构：drwx------ 3 root root 4096 Aug  8 23:11 accountsdrwx------ 3 root root 4096 Aug  8 23:16 archivedrwxr-xr-x 2 root root 4096 Aug  8 23:16 csrdrwx------ 2 root root 4096 Aug  8 23:30 keysdrwx------ 3 root root 4096 Aug  8 23:16 live      #这个是nginx可用证书目录drwxr-xr-x 2 root root 4096 Aug  8 23:25 renewal</code></pre><h4 id="配置Nginx-301跳转并配置SSL区域-指定SSL证书"><a href="#配置Nginx-301跳转并配置SSL区域-指定SSL证书" class="headerlink" title="配置Nginx 301跳转并配置SSL区域(指定SSL证书)"></a>配置Nginx 301跳转并配置SSL区域(指定SSL证书)</h4><pre><code>配置略, 配置完成需要重启nginx服务刷新浏览器访问网页就出现了绿色安全锁图标</code></pre><h4 id="最后为了保证证书长期可用，需要添加crond任务，每月自动续期"><a href="#最后为了保证证书长期可用，需要添加crond任务，每月自动续期" class="headerlink" title="最后为了保证证书长期可用，需要添加crond任务，每月自动续期"></a>最后为了保证证书长期可用，需要添加crond任务，每月自动续期</h4><pre><code>crontab -e# 输入* * * */1 * /usr/bin/certbot renew 1&gt;&gt; /dev/null 2&gt;&amp;1</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>(1) Let&#39;s Encrypt 是单域绑定， 虽然支持多域名，但是不支持泛域绑定。(2) Let&#39;s Encrypt 需要每90天续期,请自行斟酌(3) 不支持IP地址绑定,必须指定域名</code></pre><p>参考：<a href="https://laravel-china.org/topics/2525/using-certbot-lets-encrypt-small-step-run-towards-https" target="_blank" rel="noopener">Laravel China</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt; Let&amp;#39;s Encrypt Certbot生成免费证书
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Certbot官网：&lt;a href=&quot;https://certbot.eff.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="HTTPS" scheme="https://wuyanteng.github.io/tags/HTTPS/"/>
    
      <category term="SSL" scheme="https://wuyanteng.github.io/tags/SSL/"/>
    
      <category term="免费SSL证书" scheme="https://wuyanteng.github.io/tags/%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6/"/>
    
      <category term="crt" scheme="https://wuyanteng.github.io/tags/crt/"/>
    
      <category term="pem" scheme="https://wuyanteng.github.io/tags/pem/"/>
    
      <category term="certbot" scheme="https://wuyanteng.github.io/tags/certbot/"/>
    
      <category term="Let&#39;s Encrypt" scheme="https://wuyanteng.github.io/tags/Let-s-Encrypt/"/>
    
      <category term="SSL证书自动续签" scheme="https://wuyanteng.github.io/tags/SSL%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>基于OpenSSL自建CA和颁发SSL证书</title>
    <link href="https://wuyanteng.github.io/2018/09/03/%E5%9F%BA%E4%BA%8EOpenSSL%E8%87%AA%E5%BB%BACA%E5%92%8C%E9%A2%81%E5%8F%91SSL%E8%AF%81%E4%B9%A6/"/>
    <id>https://wuyanteng.github.io/2018/09/03/基于OpenSSL自建CA和颁发SSL证书/</id>
    <published>2018-09-03T07:46:16.000Z</published>
    <updated>2018-09-04T04:35:10.332Z</updated>
    
    <content type="html"><![CDATA[<h5 id="编译安装openssl"><a href="#编译安装openssl" class="headerlink" title="编译安装openssl"></a>编译安装openssl</h5><pre><code>官网：https://www.openssl.org/source/</code></pre><pre><code>wget https://www.openssl.org/source/openssl-1.1.1-pre9.tar.gztar -zxvf openssl-1.1.1-pre9.tar.gz cd openssl-1.1.1-pre9/./configmakemake testmake install</code></pre><a id="more"></a><pre><code>whereis opensslecho &quot;export LD_LIBRARY_PATH=/usr/local/lib&quot; &gt;&gt;/etc/profilesource /etc/profileroot@lohost:~# openssl versionOpenSSL 1.1.1-pre9 (beta) 21 Aug 2018</code></pre><h2 id="颁发证书"><a href="#颁发证书" class="headerlink" title="颁发证书"></a>颁发证书</h2><h5 id="生成根密钥"><a href="#生成根密钥" class="headerlink" title="生成根密钥"></a>生成根密钥</h5><pre><code>CA要给别人颁发证书，首先自己得有一个作为根证书cd /data/caopenssl genrsa -out cakey.pem 4096</code></pre><h5 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h5><pre><code>使用req命令生成自签证书：openssl req -new -x509 -key cakey.pem -out cacert.pem会提示输入一些信息：Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:BJOrganization Name (eg, company) [Internet Widgits Pty Ltd]:AloneOrganizational Unit Name (eg, section) []:AloneCommon Name (e.g. server FQDN or YOUR name) []:xx.xx.xx.xx     Email Address []:xxx@gmail.com</code></pre><h5 id="以上CA证书创建完毕-下面来给程序颁发SSL证书"><a href="#以上CA证书创建完毕-下面来给程序颁发SSL证书" class="headerlink" title="以上CA证书创建完毕,下面来给程序颁发SSL证书"></a>以上CA证书创建完毕,下面来给程序颁发SSL证书</h5><pre><code>mkdir -p /data/ca/sslcd /data/ca/ssl#生成ssl密钥openssl genrsa -out server.key 4096#生成csropenssl req -new -key server.key -out server.csr同样会提示输入一些内容，除了Commone Name字段一定要是你要授予证书的服务器域名或主机名，challenge password不填。#最后使用CA签署证书openssl x509 -req -in /data/ca/ssl/server.csr -CA /data/ca/cacert.pem -CAkey /data/ca/cakey.pem -CAcreateserial -out /data/ca/ssl/server.crt</code></pre><pre><code>生成以后，/data/ca/ssl目录下的crt和key文件就可以被程序使用了</code></pre><h2 id="无交互SSL证书生成"><a href="#无交互SSL证书生成" class="headerlink" title="无交互SSL证书生成"></a>无交互SSL证书生成</h2><pre><code>适用场景：自签名SSL证书安全性大大降低，有被攻击风险，故可通过如下命令编写脚本定期生成并更换到程序中来保障安全性</code></pre><pre><code>openssl genrsa -des3 -passout pass:huawei -out ca.key 4096openssl req -new -passin pass:huawei -key ca.key -out ca.csr -subj &quot;/C=HK/ST=HongKong/L=HongKong/O=foundation/OU=FD/CN=example.com/emailAddress=fd@gmail.com&quot;openssl x509 -sha256 -req -in ca.csr -out ca.crt -signkey ca.key -passin pass:huawei -days 30</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;编译安装openssl&quot;&gt;&lt;a href=&quot;#编译安装openssl&quot; class=&quot;headerlink&quot; title=&quot;编译安装openssl&quot;&gt;&lt;/a&gt;编译安装openssl&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;官网：https://www.openssl.org/source/
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;wget https://www.openssl.org/source/openssl-1.1.1-pre9.tar.gz
tar -zxvf openssl-1.1.1-pre9.tar.gz 
cd openssl-1.1.1-pre9/
./config
make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="pem" scheme="https://wuyanteng.github.io/tags/pem/"/>
    
      <category term="OpenSSL" scheme="https://wuyanteng.github.io/tags/OpenSSL/"/>
    
      <category term="CA" scheme="https://wuyanteng.github.io/tags/CA/"/>
    
      <category term="SSL证书" scheme="https://wuyanteng.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"/>
    
      <category term="csr" scheme="https://wuyanteng.github.io/tags/csr/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本中嵌入ssh无密钥登陆</title>
    <link href="https://wuyanteng.github.io/2018/08/31/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%B5%8C%E5%85%A5ssh%E6%97%A0%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/"/>
    <id>https://wuyanteng.github.io/2018/08/31/shell脚本中嵌入ssh无密钥登陆/</id>
    <published>2018-08-31T06:17:21.000Z</published>
    <updated>2018-08-31T07:36:19.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><pre><code>有这样一个生产场景: zabbix-agent只在server1服务器有安装并提供监控服务，想使用这一台server1服务器通过编写shell脚本去监控其他服务器运行的服务，比如：服务运行状态、log日志统计并发等等。如何做？</code></pre><a id="more"></a><p>场景分析</p><pre><code>server1需要与其他server创建SSH互信，shell中通过ssh来远程登陆到其他服务器来执行命令。那么问题来了？命令执行完成，如何在shell中退出并将命令执行后的结果返回到server1中，并让zabbix去监控呢？</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h4 id="将server1的密钥上传到101服务器实现ssh互信"><a href="#将server1的密钥上传到101服务器实现ssh互信" class="headerlink" title="将server1的密钥上传到101服务器实现ssh互信"></a>将server1的密钥上传到101服务器实现ssh互信</h4><pre><code>首先在server1以root命令生成SSH密钥[root@web01 ~]# ssh-keygen -t dsaGenerating public/private dsa key pair.Enter file in which to save the key (/root/.ssh/id_dsa):Created directory &#39;/root/.ssh&#39;.Enter passphrase (empty for no passphrase):Enter same passphrase again: Your identification has been saved in /root/.ssh/id_dsa.Your public key has been saved in /root/.ssh/id_dsa.pub.The key fingerprint is:25:93:78:e9:01:2d:82:db:cb:0b:34:f7:0c:a9:1b:11 root@web01The key&#39;s randomart image is:+--[ DSA 1024]----+|   .  ..         ||  E . .o.o       ||   + o..B .      ||  = =  o =       || . * =  S        ||  + o o          ||   + .           ||  . .            ||                 |+-----------------+#检查密钥文件[root@web01 ~]# ll /root/.ssh/total 8-rw------- 1 root root 736 2017-08-06 15:17 id_dsa-rw-r--r-- 1 root root 600 2017-08-06 15:17 id_dsa.pub#将生成的.pub密钥上传到所需的服务器上（比如：101），实现ssh免密登陆 ssh-copy-id -i ~/.ssh/id_dsa.pub root@10.10.10.101#确认远端101服务器密钥上传成功[root@101 ~]# ll /root/.ssh/total 8-rw------- 1 root root 600 2017-08-06 15:29 authorized_keys-rw-r--r-- 1 root root 393 2017-08-05 11:03 known_hosts#在server1服务器无密码远程登录测试[root@web01 ~]# ssh root@10.10.10.101注意：如果远程登录失败,需要配置ssh允许root登录，并重启ssh服务。</code></pre><h4 id="在101服务器生成密钥上传到server1服务器，实现反向ssh互信"><a href="#在101服务器生成密钥上传到server1服务器，实现反向ssh互信" class="headerlink" title="在101服务器生成密钥上传到server1服务器，实现反向ssh互信"></a>在101服务器生成密钥上传到server1服务器，实现反向ssh互信</h4><pre><code>在101服务器，生成dsa密钥，并上传到server1服务器，实现互信。</code></pre><h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h4><pre><code>接下来就可以愉快的在server1编写所需的shell脚本了，范例如下：[root@web01 ~]# cat /opt/check_service.sh</code></pre><pre><code>#!/bin/bashDNS_IP=10.0.0.101FILE1=/var/log/dns.logFILE2=/tmp/pri_dns.logNOW_UNIX=`date +%s`UNIX=`expr ${NOW_UNIX} - 60` #本地文件清理rm -f $FILE2#SSH DNS并发信息获取ssh root@${DNS_IP} &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF    egrep &quot;${UNIX}&quot; $FILE1|wc -l &gt;$FILE2    scp -r $FILE2 root@server1:/tmp/     exitEOF</code></pre><pre><code>脚本逻辑：(1)定义所需环境变量(2)通过如下方式在shell中嵌入SSH远程登录并在远程服务器执行命令   ssh root@10.10.10.101 &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF      comm1...      comm2...      comm3...      exit   EOF在上面的例子中，远端执行完毕后，通过scp方式，将结果传输到server1服务器的/tmp目录下，最后再编写zabbix自定义key来实现监控。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;有这样一个生产场景: zabbix-agent只在server1服务器有安装并提供监控服务，想使用这一台server1服务器通过编写shell脚本去监控其他服务器运行的服务，比如：服务运行状态、log日志统计并发等等。如何做？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://wuyanteng.github.io/tags/ssh/"/>
    
      <category term="shell脚本" scheme="https://wuyanteng.github.io/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>rsync限速实例</title>
    <link href="https://wuyanteng.github.io/2018/08/31/rsync%E9%99%90%E9%80%9F%E5%AE%9E%E4%BE%8B/"/>
    <id>https://wuyanteng.github.io/2018/08/31/rsync限速实例/</id>
    <published>2018-08-31T03:54:35.000Z</published>
    <updated>2018-08-31T04:02:31.533Z</updated>
    
    <content type="html"><![CDATA[<h4 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h4><pre><code>生产环境有这样的需求，需要跨机房传输TB级文件，但又不想其带宽占用的太厉害而影响了其他业务，这时候就需要使用rsync的限速功能了，简单扯下</code></pre><a id="more"></a><h4 id="rsync限速参数-–bwlimit"><a href="#rsync限速参数-–bwlimit" class="headerlink" title="rsync限速参数: –bwlimit"></a>rsync限速参数: –bwlimit</h4><pre><code>--bwlimit=100   单位：KBPS, 100意思是 传输速度限制100KB/s，也就是限速大概1MB的速度。再比如：想要限速50MB的速度，那么应该设置为 --bwlimit=5000</code></pre><h4 id="rsync限速传输命令"><a href="#rsync限速传输命令" class="headerlink" title="rsync限速传输命令"></a>rsync限速传输命令</h4><pre><code>参考：time rsync --port 873 -ravPz ./2018* rsync@X.X.X.X::logfile/2018/H5/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;场景介绍&quot;&gt;&lt;a href=&quot;#场景介绍&quot; class=&quot;headerlink&quot; title=&quot;场景介绍&quot;&gt;&lt;/a&gt;场景介绍&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;生产环境有这样的需求，需要跨机房传输TB级文件，但又不想其带宽占用的太厉害而影响了其他业务，这时候就需要使用rsync的限速功能了，简单扯下
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="rsync" scheme="https://wuyanteng.github.io/tags/rsync/"/>
    
      <category term="rsync限速" scheme="https://wuyanteng.github.io/tags/rsync%E9%99%90%E9%80%9F/"/>
    
      <category term="bwlimit" scheme="https://wuyanteng.github.io/tags/bwlimit/"/>
    
  </entry>
  
  <entry>
    <title>shell数组</title>
    <link href="https://wuyanteng.github.io/2018/08/28/shell%E6%95%B0%E7%BB%84/"/>
    <id>https://wuyanteng.github.io/2018/08/28/shell数组/</id>
    <published>2018-08-28T09:24:20.000Z</published>
    <updated>2018-08-29T10:44:38.462Z</updated>
    
    <content type="html"><![CDATA[<pre><code>shell数组</code></pre><a id="more"></a><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><pre><code>在Shell中，用括号来表示数组, 数组元素使用“空格” 分隔开，如：#数组定义name=(tom jerry jackson free gary)  #读取数组读取数组元素值的一般格式是：${数组名[下标]}，注：下标是从0开始的例如：echo ${name[0]}       #获取第1个元素值echo ${name[1]}       #获取第2个元素值echo ${name[2]}       #获取第3个元素值使用“*”或“@”符号可以获取数组中的所有元素echo ${name=[*]}echo $(name=[@])</code></pre><h4 id="数组删除"><a href="#数组删除" class="headerlink" title="数组删除"></a>数组删除</h4><pre><code>直接通过：&quot;unset 数组[下标]&quot; 可以清除相应的元素；若不带下标，则清除整个数据。 只清除第1个元素a=(1 2 3 4 5)unset a[0]echo ${a[*]}2 3 4 5清除整个数组元素unset a </code></pre><h4 id="数组之分片"><a href="#数组之分片" class="headerlink" title="数组之分片"></a>数组之分片</h4><pre><code>直接通过 &quot;${数组名[@或*]:起始位置:长度}&quot; 切片原先数组,然后返回字符串。如下：a=(1 2 3 4 5)       #定义数组echo ${a[@]:0:3}    #分片 1 2 3echo ${a[@]:1:4}2 3 4 5如果加上”()”，将得到切片数组，下面例子中，c就是一个新数据。c=(${a[@]:1:4})echo ${#c[@]}      #统计新数据c的元素总个数4echo ${c[*]}       #重新打印c的新数据数组 2 3 4 5  </code></pre><h4 id="数组之替换"><a href="#数组之替换" class="headerlink" title="数组之替换"></a>数组之替换</h4><pre><code>调用方法是：&quot;${数组名[@或*]/查找字符/替换字符}&quot; 注：该操作不会改变原先数组内容，如果需要修改，可以看下面例子，重新定义数据。# name=(gary tom jerry jackson)# echo ${name[@]/jackson/green}   #查找字符jackson，替换字符为greengary tom jerry green# echo ${name[@]}                 #可以看到，数组替换不会改变原数组的内容gary tom jerry jackson# name2=(${name[@]/jackson/green})  #但可以进行重新赋值来实现数组替换# echo ${name2[@]}gary tom jerry green</code></pre><pre><code>关于数组相关shell案例，有时间补充。。。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;shell数组
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="数组" scheme="https://wuyanteng.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>OpenVPN编译安装部署</title>
    <link href="https://wuyanteng.github.io/2018/08/23/OpenVPN%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/08/23/OpenVPN编译安装部署/</id>
    <published>2018-08-23T01:43:46.000Z</published>
    <updated>2018-08-23T02:30:24.380Z</updated>
    
    <content type="html"><![CDATA[<pre><code>整理下OpenVPN编译安装+部署过程，尤其是向客户端push路由、证书创建与吊销等相关技术。最后还会说明下客户端如何高可用实现逻辑负载均衡。</code></pre><a id="more"></a><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><pre><code>启动并清空iptables规则  # iptables -F  # service iptables save  # service iptables restart关闭SELINUX  # setenforce 0  # vi /etc/sysconfig/selinux    修改为SELINUX=disabled开启服务器端路由转发功能  # vi /etc/sysctl.conf    改为 net.ipv4.ip_forward = 1  # sysctl -p设置nat转发（注：添加正确的OpenVPN客户端网络地址）  # iptables -t nat -A POSTROUTING -s 172.101.101.0/24 -o eth0 -j MASQUERADE  注：如果是VPS配置openvpn，需要把上面的“-o eth0”参数取消，否则无法上网。设置iptables开放openvpn端口：  # iptables -A INPUT -p TCP --dport 1194 -j ACCEPT  # service iptables save  # service iptables restart时间同步(重要)：  # yum install ntp  # ntpdate asia.pool.ntp.org  # vi /etc/rc.d/rc.local    添加 /usr/bin/ntpdate asia.pool.ntp.org安装编译依赖库  # yum install -y openssl openssl-devel lzo lzo-devel pam pam-devel automake pkgconfig gcc gcc++</code></pre><h5 id="下载openvpn：-官网"><a href="#下载openvpn：-官网" class="headerlink" title="下载openvpn： 官网"></a>下载openvpn： <a href="https://openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="noopener">官网</a></h5><pre><code># tar -zxvf openvpn.2.3.10.tar.gz &amp;&amp; cd openvpn.2.3.10# ./configure --prefix=/usr/local/openvpn# make &amp;&amp; make install</code></pre><pre><code>创建/etc/openvpn目录# mkdir -p /etc/openvpn# cp -rf /root/openvpn.2.3.10/sample /etc/openvpn# cp /etc/openvpn/sample/sample-config-files/server.conf /etc/openvpn</code></pre><h5 id="安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3"><a href="#安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3" class="headerlink" title="安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3"></a>安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3</h5><pre><code># wget -c https://github.com/OpenVPN/easy-rsa/archive/master.zip# unzip master.zip# mv easy-ras-master easy-rsa# cp -rf easy-rsa /etc/openvpn# cd /etc/openvpn/easy-rsa/easyrsa3# cp vars.example vars# chmod +x vars修改Vars文件内的如下字段：set_var EASYRSA_REQ_COUNTRY &quot;CN&quot; //根据自己情况更改set_var EASYRSA_REQ_PROVINCE &quot;Beijing&quot;set_var EASYRSA_REQ_CITY &quot;Tong&quot;set_var EASYRSA_REQ_ORG &quot;qingliu Certificate&quot;set_var EASYRSA_REQ_EMAIL &quot;shuiqingliu14@gmail.com&quot;set_var EASYRSA_REQ_OU &quot;My OpenVPN&quot;创建服务端证书及KeyA. 进入/etc/openvpn/easy-rsa/easyrsa3/目录初始化：   ./easyrsa init-pkiB. 创建根证书   ./easyrsa build-ca   B1. 根据提示输入PEM密码，密码为：P**4 【务必要记住改密码，否则以后不能为证书签名】   B2. 还需要输入common name 通用名，配置为Moxiu。  C. 创建服务器端证书    ./easyrsa gen-req server nopassD. 签约服务端证书   ./easyrsa sign server server   根据提示输入”yes ” ,再输入刚才设置的PEM密码D. 创建Diffie-Hellman，确保key穿越不安全网络的命令   ./easyrsa gen-dh</code></pre><h5 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h5><pre><code>A. 在/root目录下，创建openvpn_users文件夹来存储所有客户端证书文件。   # mkdir  /root/openvpn_users &amp;&amp; cd openvpn_users   # cp -R /root/easy-rsa  ./   # cd easy-rsa/easyrsa3/   # cp vars.example  varsB. 初始化   # ./easyrsa init-pkiC. 创建客户端key以及生成证书（记住生成是自己输入的密码）   # ./easyrsa  gen-req  test   //名字自己定义D. 切换到Server证书目录下，将得到的test.req导入，然后签约证书# cd  /etc/openvpn/easy-rsa/easyrsa3/# ./easyrsa  import-req /root/openvpn_users/easy-rsa/easyrsa3/pki/reqs/test.req testD. 用户签约，根据提示输入服务端CA密码   # ./easyrsa sign client testE. 这一步很重要，看看生成的全部文件    (1)Server:  [目录：/etc/openvpn/easy-rsa/文件夹]    /etc/openvpn/easy-rsa/easyrsa3/pki/ca.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/reqs/server.req    /etc/openvpn/easy-rsa/easyrsa3/pki/reqs/test.req    /etc/openvpn/easy-rsa/easyrsa3/pki/private/ca.key    /etc/openvpn/easy-rsa/easyrsa3/pki/private/server.key    /etc/openvpn/easy-rsa/easyrsa3/pki/issued/server.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/issued/test.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/dh.pem    (2) Client: [目录：/etc/openvpn/clients/easy-rsa/文件夹]      /root/openvpn_users/easy-rsa/easyrsa3/pki/private/test.key      /root/openvpn_users/easy-rsa/easyrsa3/pki/reqs/test.req         这个文件被我们导入到了服务端文件所以那里也有F. 拷贝服务器证书文件放到/etc/openvpn目录   进入/etc/openvpn/easy-rsa/easyrsa3目录   #cp pki/ca.crt  /etc/openvpn   #cp pki/private/server.key  /etc/openvpn   #cp pki/issued/server.crt  /etc/openvpn   #cp pki/dh.pem  /etc/openvpnG. Client证书（集中放到一个文件夹下，给VPN用户使用）   # mkdir /root/users   # mkdir /root/users/test //内部文件夹以姓名全拼命名，方便下载这些密钥文件   # cd /root/users/test/   # cp /etc/openvpn/ca.crt ./              拷贝CA证书到test目录下   # cp /etc/openvpn/easy-rsa/easyrsa3/pki/issued/test.crt ./          拷贝（服务端路径）用户crt文件   # cp /root/openvpn_users/easy-rsa/easyrsa3/pki/private/test.key ./　　拷贝（客户端路径）用户key文件   查看   [root@OpenVPN test]# ls   ca.crt  test.crt  test.key</code></pre><h5 id="生成ta-key【为了安全】"><a href="#生成ta-key【为了安全】" class="headerlink" title="生成ta.key【为了安全】"></a>生成ta.key【为了安全】</h5><pre><code>配置服务之前，需要生成配置文件需要的ta.key文件，并将ta.key放入/etc/openvpn目录下【注：客户端连接也要使用有此文件】# cd /root/# /usr/local/openvpn/sbin/openvpn --genkey --secret ta.key# ls# cp  ta.key  /etc/openvpn/# cp ta.key /root/users/test</code></pre><h5 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h5><pre><code># vi /etc/openvpn/server.conf       local 10.0.8.28     #申明本机使用的IP地址，也可以不说明     port 1194     #申明使用的端口，默认1194     proto tcp     #申明使用的协议，默认使用UDP，如果使用HTTP proxy，必须使用TCP协议     dev tun     #申明使用的设备可选tap和tun，tap是二层设备，支持链路层协议。     ca /etc/openvpn/ca.crt     #指定ca证书的路径     cert /etc/openvpn/server.crt     #指定server.crt路径     key /etc/openvpn/server.key     #指定server.key路径     dh /etc/openvpn/dh.pem     #指定dh.pem路径     server 172.101.101.0 255.255.255.0     #为VPN客户端指定分配的网络地址（自己根据规划分配）     ifconfig-pool-persist ipp.txt     push &quot;redirect-gateway&quot;           #向客户端push网关【push 网关后，客户端通过远程网络上网，作用类似NAT伪装；如果不想这么做，就需要向客户端直接push路由--后边故障解决部分有介绍】     push &quot;dhcp-option DNS 114.114.114.114&quot;  #向客户端push DNS     client-to-client  #让客户端彼此可以互相访问     tls-auth   /etc/openvpn/ta.key 0       #注：此处客户端配置文件中该参数需要改为 tls-auth ta.key 1     comp-lzo     auth md5      cipher AES-256-CBC      max-clients 100      keepalive 10 120      persist-key      persist-tun      status openvpn-status.log      verb 3</code></pre><h5 id="启动openvpn"><a href="#启动openvpn" class="headerlink" title="启动openvpn"></a>启动openvpn</h5><pre><code>/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &amp;加入开机启动项【手动创建开机启动脚本文件】# vi  /etc/init.d/openvpn 输入以下内容，保存：#!/bin/bash# chkconfig: 2345 67 33# description: ntpd is the NTPv4 daemon.nohup /usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &gt; /tmp/open.log 2&gt;&amp;1 &amp;</code></pre><pre><code># chmod  755  openvpn             //添加执行权限# chkconfig --add openvpn# chkconfig openvpn on           //加入开机启动项# netstat -ln                   //查看端口是否正确启动</code></pre><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><pre><code>此处以windows客户端为例：安装Openvpn客户端并以管理员身份运行</code></pre><p>配置创建client.ovpn文件</p><pre><code>clientdev tunproto udpremote 10.0.8.28   #主要这里修改成自己server ipresolv-retry infinitenobindpersist-keypersist-tunca ca.crt               #这里需要证书cert test.crtkey  test.keyauth md5cipher AES-256-CBCtls-auth ta.key 1comp-lzoverb 3</code></pre><p>故障处理</p><pre><code>故障描述：运行openvpn客户端后，VPN连接正常，但无法上网和Ping公司内网</code></pre><pre><code>解决方法：  1. 打开Openvpn服务端配置文件   # vi /etc/openvpn/server.conf  添加如下静态路由(填写服务器这边的网络)  push &quot;route 10.0.8.0 255.255.254.0 net_gateway&quot;  push &quot;route 10.0.0.0 255.255.254.0 net_gateway&quot;  #push &quot;route 10.0.16.0 255.255.248.0 net_gateway&quot;  push &quot;route 0.0.0.0 0.0.0.0 net_gateway&quot;重启openvpn服务，再进行测试即可 </code></pre><h5 id="证书吊销"><a href="#证书吊销" class="headerlink" title="证书吊销"></a>证书吊销</h5><pre><code>OpenVPN证书吊销# cd  /etc/openvpn/easy-rsa/easyrsa3/# ./easyrsa revoke  clientName              //name输入需要注销的用户名称# ./easyrsa  gen-crl此时会在/etc/openvpn/easy-rsa/easyrsa3/pki目录下生成crl.pem文件# cp  ./etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem    /etc/openvpn# cd   /etc/openvpn# vim  server.conf添加如下内容：crl-verify  /etc/openvpn/crl.pem重启OpenVPN服务,使配置生效</code></pre><h6 id="关于客户端逻辑负载均衡"><a href="#关于客户端逻辑负载均衡" class="headerlink" title="关于客户端逻辑负载均衡"></a>关于客户端逻辑负载均衡</h6><pre><code>为什么说客户端负载均衡是逻辑上的呢？实现逻辑是这样：部署多台独立的openvpn服务端，然后客户端配置多台server ip地址，客户端每次连接都会选择不同的server进行连接，如果失败，则自动连接下一个server。客户端轮询部分配置如下：remote server1 1194remote server2 1194remote server3 1194remote-randomresolv-retry 2那么问题来了，如何保证多台server的配置文件和用户key能保持一致呢？解决方案：以其中一台server作为逻辑主server，也就是说所有的keys用户创建，都只在这个主server上进行，然后，将/etc/openvpn目录下的所有文件【注意：不包括server.conf主配置文件】覆盖到server2、server3上面【注意：不要覆盖server2和server3的主配置文件: server.conf,否则你就呵呵吧】，并重启他们的openvpn服务即可。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;整理下OpenVPN编译安装+部署过程，尤其是向客户端push路由、证书创建与吊销等相关技术。最后还会说明下客户端如何高可用实现逻辑负载均衡。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ovpn" scheme="https://wuyanteng.github.io/tags/ovpn/"/>
    
      <category term="openvpn" scheme="https://wuyanteng.github.io/tags/openvpn/"/>
    
      <category term="vpn" scheme="https://wuyanteng.github.io/tags/vpn/"/>
    
      <category term="easy-rsa3" scheme="https://wuyanteng.github.io/tags/easy-rsa3/"/>
    
  </entry>
  
  <entry>
    <title>Bind9主从同步部署</title>
    <link href="https://wuyanteng.github.io/2018/08/17/Bind9%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/08/17/Bind9主从同步部署/</id>
    <published>2018-08-17T09:20:09.000Z</published>
    <updated>2018-08-22T03:12:34.726Z</updated>
    
    <content type="html"><![CDATA[<pre><code>之前没有独立写过Bind主从同步，只有与LVS相结合的文章，故今天给补充完善。本次测试版本：bind-9.10.8-P1.tar.gz     </code></pre><a id="more"></a><h2 id="部署Bind主DNS"><a href="#部署Bind主DNS" class="headerlink" title="部署Bind主DNS"></a>部署Bind主DNS</h2><p>编译安装</p><pre><code>tar -zxvf bind-9.10.8-P1.tar.gzcd  bind-9.10.8-P1mkdir -p /etc/bind./configure --enable-threads --with-libtool --with-ecdsa --prefix=/usr/local/web2016/bind  \     --sysconfdir=/etc/bindmakemake install</code></pre><pre><code>编译参数，释义：--enable-threads    #开启多线程支持--with-libtool      #使用GNU libtool--with-ecdsa        #开启ECDSA算法支持</code></pre><p>命令软链</p><pre><code>ln -sv /usr/local/web2016/bind/sbin/* /sbin/</code></pre><p>创建傀儡用户named</p><pre><code>useradd -r -m  -d /var/named -s /sbin/nologin named</code></pre><p>创建rndc key</p><pre><code>伪造数据，便于生成keyecho &quot;1111111111qqqqqqqqqqqqwwwwwwwwwwwwwwddddddddddffffffhjFD21AAAAAAAAAAA&quot; &gt;/root/random生成keyrndc-confgen -r /root/random -s 127.0.0.1 -p 953 &gt;/etc/bind/rndc.conf</code></pre><p>手动创建named.conf</p><pre><code>vim /etc/bind/named.conf</code></pre><h4 id="named-conf配置文件"><a href="#named-conf配置文件" class="headerlink" title="named.conf配置文件"></a>named.conf配置文件</h4><pre><code>options {   listen-on port 53 { any; };      //定义DNS监听在哪个端口上   directory &quot;/etc/bind/zone&quot;;   //指定DNS区域文件存放目录   pid-file &quot;/etc/bind/var/named.pid&quot;;   //指定named进程pid文件路径   allow-query { any; };          //允许哪些主机可以使用该DNS来解析   Dump-file &quot;/etc/bind/var/binddump.db&quot;;     //缓存转储位置   Statistics-file &quot;/etc/bind/stats/named_stats&quot;;   //记录统计信息的文件   zone-statistics yes;  //收集在服务器所有域的统计数据, 这些统计数据可以通过使用rndc stats来访问   memstatistics-file &quot;/etc/bind/stats/mem_stats&quot;;     //记录内存使用的统计信息   empty-zones-enable yes;      forwarders {114.114.114.114;8.8.8.8;};   //定义上游DNS[需要配置root hint顶级域]};key &quot;rndc-key&quot; {               //注：这个key部分是通过rndc-confgen命令生成的配置，贴过来        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};controls {              //配置rndc权限与端口       inet 127.0.0.1 port 953       allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };};logging {  channel warning {        //warnning可以改为default_debug（默认）。     file &quot;/var/log/named/named.log&quot; versions 10 size 10m;    //日志文件路径/版本/大小     severity warning;     //如果warnning改为default_debug后，此处可以改为severity dynamic     print-category yes;   //日志中是否需要写入日志类别     print-severity yes;   //日志中是否需要写入消息级别     print-time yes;       //日志中是否需要写入时间    };     channel general_dns {               //绑定其他log channel通道，以下保持默认即可。     file &quot;/var/log/named/named2.log&quot; versions 10 size 100m;     severity info;         print-category yes;      print-severity yes;     print-time yes;    };  category default {    warning;  };  category queries {    general_dns;  };};include &quot;/etc/bind/view/*.conf&quot;;   #加载Bind视图文件</code></pre><p>创建相关目录并授权</p><pre><code>mkdir -p /etc/bind/zonemkdir -p /etc/bind/varmkdir -p /etc/bind/statsmkdir -p /etc/bind/viewmkdir -p /var/log/namedwget https://www.internic.net/domain/named.rootchown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>配置Bind视图</p><pre><code>vim /etc/bind/view/view.conf</code></pre><pre><code>view &quot;View&quot; {                  //配置bind视图功能  zone &quot;test.org&quot; {        type    master;             file    &quot;test.org.zone&quot;;    //定义zone区域文件        allow-transfer {            //允许本区域传输给特定的从DNS服务器                10.0.10.102;      //slave IP,可以存在多个slave        };        notify  yes;          also-notify {               10.0.10.102;        };  };  zone &quot;10.0.10.in-addr.arpa&quot; {     //定义反向zone区域文件        type    master;        file    &quot;10.0.10.zone&quot;;             allow-transfer {               //允许本区域传输给特定的从DNS服务器                10.0.10.102;         //slave IP,可以存在多个slave                       };        notify  yes;        also-notify {                10.0.10.102;        };   };   zone &quot;.&quot; in {         type hint;         file &quot;/etc/bind/named.root&quot;   }};注：参数释义(1)区域类型有type：｛hint（根）| master（主dns）| slave（辅助DNS）| forward（转发）｝(2)notify如果是yes（默认），当一个授权的服务器修改了一个域后，DNS NOTIFY信息被发送给列在also-notify选项中的服务器。</code></pre><p>正向区域和反向区域文件配置-略</p><pre><code>需要在zone子目录定义，因为配置文件zone目录是这么写的zone配置文件语法检查named-checkzone test.org /etc/bind/zone/test.org.zone </code></pre><p>最后再次修改目录权限</p><pre><code>chown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>启动服务</p><pre><code>named.conf配置文件检查named-checkconf /etc/bind/named.conf</code></pre><p>named启动脚本[建议使用supervisor]</p><pre><code>/etc/init.d/named</code></pre><pre><code>#!/bin/bash # named a network name service. # chkconfig: 345 35 75 # description: a name serverif [ `id -u` -ne 0 ];then   echo &quot;ERROR:For bind to port 53,must run as root.&quot;    exit 1ficase &quot;$1&quot; instart)        if [ -x /usr/sbin/named ]; then  /usr/sbin/named -c /etc/bind/named.conf -u named &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server started&#39;         fi      ;;stop)       kill `cat /etc/named/var/named.pid` &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server stopped&#39;        ;;restart)       echo .        echo &quot;Restart BIND9.10 server&quot;        $0 stop       sleep 10       $0 start       ;;reload)      /usr/sbin/rndc reload      ;;status)     /usr/sbin/rndc status     ;;*)     echo &quot;$0 start | stop | restart |reload |status&quot;      ;;esac</code></pre><pre><code>chmod  755  /etc/init.d/namedchkconfig --add namedchkconfig named on/etc/init.d/named start /etc/init.d/named status</code></pre><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><pre><code>[root@ns1 ~]# netstat -lntup|grep 53tcp    0     0 10.0.10.101:53          0.0.0.0:*       LISTEN      2361/named          tcp    0     0 127.0.0.1:53            0.0.0.0:*       LISTEN      2361/named          tcp    0     0 127.0.0.1:953           0.0.0.0:*       LISTEN      2361/named          tcp6   0     0 :::53                   :::*            LISTEN      2361/named          udp    0     0 10.0.10.101:53          0.0.0.0:*      2361/named          udp    0     0 127.0.0.1:53            0.0.0.0:*      2361/named          udp6   0     0 :::53                   :::*           2361/named</code></pre><h4 id="日常管理"><a href="#日常管理" class="headerlink" title="日常管理"></a>日常管理</h4><pre><code>/etc/init.d/named start 启动服务rndc status  查看服务运行情况rndc reload  重新加载区域文件rndc stop    停止DNS服务</code></pre><h2 id="部署bind从DNS"><a href="#部署bind从DNS" class="headerlink" title="部署bind从DNS"></a>部署bind从DNS</h2><p>编译安装</p><pre><code>略</code></pre><p>主配置文件/etc/bind/named.conf</p><pre><code>options {   listen-on port 53 { any; };      //定义DNS监听在哪个端口上   directory &quot;/etc/bind/zone&quot;;   //指定DNS区域文件存放目录   pid-file &quot;/etc/bind/var/named.pid&quot;;   //指定named进程pid文件路径   allow-query { any; };          //允许哪些主机可以使用该DNS来解析   Dump-file &quot;/etc/bind/var/binddump.db&quot;;     //缓存转储位置   Statistics-file &quot;/etc/bind/stats/named_stats&quot;;   //记录统计信息的文件   zone-statistics yes;  //收集在服务器所有域的统计数据, 这些统计数据可以通过使用rndc stats来访问   memstatistics-file &quot;/etc/bind/stats/mem_stats&quot;;     //记录内存使用的统计信息   empty-zones-enable yes;      forwarders {114.114.114.114;8.8.8.8;};   //定义上游DNS[需要配置root hint顶级域]};key &quot;rndc-key&quot; {               //注：这个key部分是通过rndc-confgen命令生成的配置，贴过来        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};controls {              //配置rndc权限与端口       inet 127.0.0.1 port 953       allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };};logging {  channel warning {        //warnning可以改为default_debug（默认）。     file &quot;/var/log/named/named.log&quot; versions 10 size 10m;    //日志文件路径/版本/大小     severity warning;     //如果warnning改为default_debug后，此处可以改为severity dynamic     print-category yes;   //日志中是否需要写入日志类别     print-severity yes;   //日志中是否需要写入消息级别     print-time yes;       //日志中是否需要写入时间    };     channel general_dns {               //绑定其他log channel通道，以下保持默认即可。     file &quot;/var/log/named/named2.log&quot; versions 10 size 100m;     severity info;         print-category yes;      print-severity yes;     print-time yes;    };  category default {    warning;  };  category queries {    general_dns;  };};include &quot;/etc/bind/view/*.conf&quot;;   #加载Bind视图文件</code></pre><p>编辑/etc/bind/rndc.key</p><pre><code>key &quot;rndc-key&quot; {               //与主DNS保持一致        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};</code></pre><p>编辑/etc/bind/rndc.conf</p><pre><code>key &quot;rndc-key&quot; {               //与主DNS保持一致        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};options {        default-key &quot;rndc-key&quot;;        default-server 127.0.0.1;        default-port 953;};</code></pre><p>创建相关目录并授权</p><pre><code>mkdir -p /etc/bind/zonemkdir -p /etc/bind/varmkdir -p /etc/bind/statsmkdir -p /etc/bind/viewmkdir -p /var/log/namedwget https://www.internic.net/domain/named.rootchown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>配置Bind视图</p><pre><code>vim /etc/bind/view/view.conf</code></pre><pre><code>view &quot;View&quot; {                  //配置bind视图功能  zone &quot;test.org&quot; {        type    slave;          //正向区域文件配置为slave模式        masters { 10.0.10.101; };  //此处要指定masterIP，可以添加多个        file    &quot;slave.test.org.zone&quot;;  //不需要对其创建，服务启动后，会自动同步过来  };  zone &quot;10.0.10.in-addr.arpa&quot; {             type    slave;                 //反向区域文件配置为slave模式        masters { 10.0.10.101; };    //此处要指定masterIP，可以添加多个        file    &quot;slave.10.0.10.zone&quot;;     //不需要对其创建，服务启动后，会自动同步过来   };   zone &quot;.&quot; in {         type hint;         file &quot;/etc/bind/named.root&quot;;   }};注：参数释义(1)区域类型有type：｛hint（根）| master（主dns）| slave（辅助DNS）| forward（转发）｝(2)file 可以指定一个文件路径</code></pre><p>最后再次修改目录权限</p><pre><code>chown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>启动服务</p><pre><code>named.conf配置文件检查named-checkconf /etc/bind/named.conf</code></pre><p>named启动脚本[建议使用supervisor]</p><pre><code>/etc/init.d/named</code></pre><pre><code>#!/bin/bash # named a network name service. # chkconfig: 345 35 75 # description: a name serverif [ `id -u` -ne 0 ];then   echo &quot;ERROR:For bind to port 53,must run as root.&quot;    exit 1ficase &quot;$1&quot; instart)        if [ -x /usr/sbin/named ]; then  /usr/sbin/named -c /etc/bind/named.conf -u named &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server started&#39;         fi      ;;stop)       kill `cat /etc/named/var/named.pid` &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server stopped&#39;        ;;restart)       echo .        echo &quot;Restart BIND9.10 server&quot;        $0 stop       sleep 10       $0 start       ;;reload)      /usr/sbin/rndc reload      ;;status)     /usr/sbin/rndc status     ;;*)     echo &quot;$0 start | stop | restart |reload |status&quot;      ;;esac</code></pre><pre><code>chmod  755  /etc/init.d/namedchkconfig --add namedchkconfig named on/etc/init.d/named start /etc/init.d/named status</code></pre><h4 id="进程查看-1"><a href="#进程查看-1" class="headerlink" title="进程查看"></a>进程查看</h4><pre><code>[root@ns2 ~]# netstat -lntup|grep 53</code></pre><h4 id="日常管理-1"><a href="#日常管理-1" class="headerlink" title="日常管理"></a>日常管理</h4><pre><code>/etc/init.d/named start 启动服务rndc status  查看服务运行情况rndc reload  重新加载区域文件rndc stop    停止DNS服务</code></pre><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><pre><code>dig 分别测试主从DNS解析是否正常。接下来就可以进行压力测试了，工具很多，不进行列举</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>正向区域zone-格式参考</p><pre><code>$ORIGIN test.org.     ; //设置默认域$TTL 38404         ; default time to live@   IN   SOA     web.moxiu. admin.moxiu. (    20180814        10800        3600        604800        38400 )        NS      10.0.10.101.      ; 主DNS IP或域名        IN      NS      ns1.moxiu.        IN      NS      ns2.moxiu.ns1     IN      A       10.0.10.101ns2     IN      A       10.0.10.102cname   IN      CNAME   www.baidu.com.cwl     IN      A       1.1.1.1cwl2    IN      A       7.7.7.7</code></pre><pre><code>其中:  $ORIGIN test.org.     ; //设置默认域这样的话，域名解析的时候需要：dig  cw1.test.org ; 当然默认域，也可以设置为&quot;teet.&quot;, 解析的时候这样：dig  cw1.teet.  也就是说解析二级域是由自己在这里控制的【顶级域是.】</code></pre><h2 id="关于优化"><a href="#关于优化" class="headerlink" title="关于优化"></a>关于优化</h2><pre><code>此配置文件能满足基本需求，如果需要将Bind效率提升，需要对参数进行优化。不在本篇讨论范围，Google解决。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;之前没有独立写过Bind主从同步，只有与LVS相结合的文章，故今天给补充完善。
本次测试版本：bind-9.10.8-P1.tar.gz     
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="bind" scheme="https://wuyanteng.github.io/tags/bind/"/>
    
      <category term="bind9" scheme="https://wuyanteng.github.io/tags/bind9/"/>
    
      <category term="bind主从" scheme="https://wuyanteng.github.io/tags/bind%E4%B8%BB%E4%BB%8E/"/>
    
      <category term="DNS" scheme="https://wuyanteng.github.io/tags/DNS/"/>
    
      <category term="迭代DNS" scheme="https://wuyanteng.github.io/tags/%E8%BF%AD%E4%BB%A3DNS/"/>
    
      <category term="root hint" scheme="https://wuyanteng.github.io/tags/root-hint/"/>
    
  </entry>
  
  <entry>
    <title>编写expect交互类脚本</title>
    <link href="https://wuyanteng.github.io/2018/08/09/%E7%BC%96%E5%86%99expect%E4%BA%A4%E4%BA%92%E7%B1%BB%E8%84%9A%E6%9C%AC/"/>
    <id>https://wuyanteng.github.io/2018/08/09/编写expect交互类脚本/</id>
    <published>2018-08-09T08:36:31.000Z</published>
    <updated>2018-08-09T11:35:55.054Z</updated>
    
    <content type="html"><![CDATA[<pre><code>有时候业务中免不了编写交互式输入账号密码的脚本，今天正好有需求，特意记录下</code></pre><h5 id="expect作用介绍"><a href="#expect作用介绍" class="headerlink" title="expect作用介绍"></a>expect作用介绍</h5><pre><code>expect就是用来做交互用的，基本任何交互登录的场合都能使用，不过需要安装expect包</code></pre><a id="more"></a><h5 id="expect包安装"><a href="#expect包安装" class="headerlink" title="expect包安装"></a>expect包安装</h5><pre><code>yum install -y tcl expect expect-devel</code></pre><h5 id="确认expect路径"><a href="#确认expect路径" class="headerlink" title="确认expect路径"></a>确认expect路径</h5><pre><code>[root@localhost]# which expect/usr/bin/expect</code></pre><h5 id="脚本语法-示例"><a href="#脚本语法-示例" class="headerlink" title="脚本语法,示例"></a>脚本语法,示例</h5><pre><code>[root@localhost]# cat test.et#!/usr/bin/expect                      #与bash类似,声明脚本类型set timeout 30                         #设定超时时间为30sspawn ssh garywu@192.168.1.1 -p 7113   #spawn后面接要执行的命令expect &quot;password:&quot;                     #捕捉交互返回的 password：关键字send &quot;garywu123\r&quot;                     #发送一个密码字符串interact                            #表示执行完留在远程控制台；不加这句则执行完后返回本地控制台 </code></pre><h5 id="给脚本增加执行权限"><a href="#给脚本增加执行权限" class="headerlink" title="给脚本增加执行权限"></a>给脚本增加执行权限</h5><pre><code>chmod +x test.et</code></pre><h5 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="!需要注意的点"></a>!需要注意的点</h5><pre><code>不能按照习惯来用sh autosu.sh来这行expect的程序，会提示找不到命令，如下：autosu.sh: line 3: spawn: command not foundcouldn&#39;t read file &quot;password:&quot;: no such file or directoryautosu.sh: line 5: send: command not foundautosu.sh: line 6: interact: command not found因为expect用的不是bash所以会报错。执行的时候直接./autosu.sh就可以了。～切记！</code></pre><h5 id="使用ssh和expect监控RouterOS—生产环境示例："><a href="#使用ssh和expect监控RouterOS—生产环境示例：" class="headerlink" title="使用ssh和expect监控RouterOS—生产环境示例："></a>使用ssh和expect监控RouterOS—生产环境示例：</h5><pre><code>#!/bin/bashHOSTNAME=&quot;192.168.1.1&quot;PORT=&quot;22&quot;USER=&quot;xxx&quot;PASS=&quot;xxxxx&quot;TMP=$(mktemp)#创建expect脚本cat &gt; $TMP &lt;&lt; EOF set timeout -1spawn ssh -p$PORT $USER@$HOSTNAMEmatch_max 100000expect -exact &quot;password:&quot;send -- &quot;$PASS\r&quot;sleep 1expect &quot; &gt; &quot;send -- &quot;/system resource print\r&quot;expect &quot; &gt; &quot;send -- &quot;quit\r&quot;expect eofEOF#运行expect脚本stat_file=/tmp/ros_status.log/usr/bin/expect -f $TMP &gt;$stat_filerm $TMP</code></pre><pre><code>注: 脚本运行完毕，RouterOS运行状态信息会出现在/tmp/ros_status.log中，通过grep或awk取出想要的值，然后自定义zabbix key即可，也可以在zabbix中配置图形展示。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;有时候业务中免不了编写交互式输入账号密码的脚本，今天正好有需求，特意记录下
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;expect作用介绍&quot;&gt;&lt;a href=&quot;#expect作用介绍&quot; class=&quot;headerlink&quot; title=&quot;expect作用介绍&quot;&gt;&lt;/a&gt;expect作用介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;expect就是用来做交互用的，基本任何交互登录的场合都能使用，不过需要安装expect包
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://wuyanteng.github.io/tags/ssh/"/>
    
      <category term="expect" scheme="https://wuyanteng.github.io/tags/expect/"/>
    
      <category term="自动输入密码" scheme="https://wuyanteng.github.io/tags/%E8%87%AA%E5%8A%A8%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/"/>
    
      <category term="交互式" scheme="https://wuyanteng.github.io/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
      <category term="非交互" scheme="https://wuyanteng.github.io/tags/%E9%9D%9E%E4%BA%A4%E4%BA%92/"/>
    
      <category term="使用ssh和expect监控RouterOS" scheme="https://wuyanteng.github.io/tags/%E4%BD%BF%E7%94%A8ssh%E5%92%8Cexpect%E7%9B%91%E6%8E%A7RouterOS/"/>
    
  </entry>
  
  <entry>
    <title>DNS TLS Public</title>
    <link href="https://wuyanteng.github.io/2018/08/06/DNS-TLS-Public/"/>
    <id>https://wuyanteng.github.io/2018/08/06/DNS-TLS-Public/</id>
    <published>2018-08-06T07:57:13.000Z</published>
    <updated>2018-08-06T08:08:45.668Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Public DNS(TLS) </code></pre><h4 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h4><pre><code>1.1.1.1@8531.0.0.1@8532606:4700:4700::1111@8532606:4700:4700::1001@853</code></pre><a id="more"></a><h4 id="Quad9"><a href="#Quad9" class="headerlink" title="Quad9"></a>Quad9</h4><pre><code>9.9.9.9@853149.112.112.112@8532620:fe::fe@8532620:fe::9@853</code></pre><h4 id="CleanBrowsing"><a href="#CleanBrowsing" class="headerlink" title="CleanBrowsing"></a>CleanBrowsing</h4><pre><code>185.228.168.168@853185.228.168.169@8532a0d:2a00:1::@8532a0d:2a00:2::@853</code></pre><h4 id="Taipei"><a href="#Taipei" class="headerlink" title="Taipei"></a>Taipei</h4><pre><code>101.101.101.101@853101.102.103.104@853</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Public DNS(TLS) 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Cloudflare&quot;&gt;&lt;a href=&quot;#Cloudflare&quot; class=&quot;headerlink&quot; title=&quot;Cloudflare&quot;&gt;&lt;/a&gt;Cloudflare&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.1.1.1@853
1.0.0.1@853

2606:4700:4700::1111@853
2606:4700:4700::1001@853
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="DNS TLS" scheme="https://wuyanteng.github.io/tags/DNS-TLS/"/>
    
      <category term="Public DNS" scheme="https://wuyanteng.github.io/tags/Public-DNS/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump数据导入导出-详解</title>
    <link href="https://wuyanteng.github.io/2018/07/25/mysqldump%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wuyanteng.github.io/2018/07/25/mysqldump数据导入导出-详解/</id>
    <published>2018-07-25T09:17:36.000Z</published>
    <updated>2018-07-27T10:04:32.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><pre><code>在日常维护工作当中经常会需要对数据进行导出操作，而mysqldump是导出数据过程中使用非常频繁的一个工具；它自带的功能参数非常多，可以轻松完成看似很复杂的需求。</code></pre><p>本文摘选自：<a href="http://www.cnblogs.com/chenmh/p/5300370.html" target="_blank" rel="noopener">Pursuer.chen</a></p><a id="more"></a><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>Usage: mysqldump [OPTIONS] database [tables]OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]OR     mysqldump [OPTIONS] --all-databases [OPTIONS]</code></pre><h4 id="1-导出所有数据库"><a href="#1-导出所有数据库" class="headerlink" title="1.导出所有数据库"></a>1.导出所有数据库</h4><pre><code>mysqldump -uroot -proot --all-databases &gt;/tmp/all.sql</code></pre><h4 id="2-导出db1、db2两个数据库的所有数据"><a href="#2-导出db1、db2两个数据库的所有数据" class="headerlink" title="2.导出db1、db2两个数据库的所有数据"></a>2.导出db1、db2两个数据库的所有数据</h4><pre><code>mysqldump -uroot -proot --databases db1 db2 &gt;/tmp/user.sql</code></pre><h4 id="3-导出db1中的a1、a2表"><a href="#3-导出db1中的a1、a2表" class="headerlink" title="3.导出db1中的a1、a2表"></a>3.导出db1中的a1、a2表</h4><pre><code>mysqldump -uroot -proot db1 table1 table2  &gt;/tmp/db1.sql注意: 导出指定表只能针对一个数据库进行导出;恢复时，需要确保目标库中没有该表数据，否则可能出现主键冲突等。</code></pre><h4 id="4-条件导出"><a href="#4-条件导出" class="headerlink" title="4.条件导出"></a>4.条件导出</h4><pre><code>(1)当字段是整数，使用如下命令：mysqldump -uroot -proot db1 table1 -w &#39;id=1&#39; &gt;/tmp/a1.sql(2)当字段是字符串,使用如下命令：mysqldump -uroot -proot db1 table1 -w &#39;id=&#39;a&#39;&#39;  &gt;/tmp/a1.sql(3)当字段在shell中作为变量调用mysqldump -uroot -proot db1 table1 -w &#39;DATE&gt;=&#39;${days31_ago}&#39;&#39; &gt;/tmp/a1.sql注：如果多个表的条件相同可以一次性导出多个表</code></pre><p>附录：一次查询或删除同一个库的多张表</p><pre><code>mysql -uroot -p  -e &quot;use ${remote_db2}; DELETE FROM ${table2_1} WHERE DATE&gt;=&#39;${days31_ago}&#39;;DELETE FROM ${table2_2} WHERE DATE&gt;=&#39;${days31_ago}&#39;;DELETE FROM ${table2_3} WHERE DATE&gt;=&#39;${days31_ago}&#39;;&quot;</code></pre><h4 id="5-生成新的binlog文件"><a href="#5-生成新的binlog文件" class="headerlink" title="5.生成新的binlog文件"></a>5.生成新的binlog文件</h4><pre><code>有时候会希望导出数据之后生成一个新的binlog文件,只需要加上-F参数即可mysqldump -uroot -proot --databases db1 -F &gt;/tmp/db1.sql</code></pre><h4 id="6-只导出表结构不导出数据，–no-data"><a href="#6-只导出表结构不导出数据，–no-data" class="headerlink" title="6.只导出表结构不导出数据，–no-data"></a>6.只导出表结构不导出数据，–no-data</h4><pre><code>mysqldump -uroot -proot --no-data --databases db1 &gt;/tmp/db1.sql</code></pre><h4 id="7-跨服务器导出导入数据"><a href="#7-跨服务器导出导入数据" class="headerlink" title="7.跨服务器导出导入数据"></a>7.跨服务器导出导入数据</h4><pre><code>mysqldump --host=h1 -uroot -proot --databases db1 |mysql --host=h2 -uroot -proot db2注：将h1服务器中的db1数据库的所有数据导入到h2中的db2数据库中，db2的数据库必须存在否则会报错</code></pre><pre><code>mysqldump --host=h1 -uroot -proot -C --databases db1 |mysql --host=h2 -uroot -proot db2加上-C参数启用压缩传递</code></pre><h4 id="8-将主库的binlog位置和文件名追加到导出数据的文件中-–dump-slave"><a href="#8-将主库的binlog位置和文件名追加到导出数据的文件中-–dump-slave" class="headerlink" title="8.将主库的binlog位置和文件名追加到导出数据的文件中,–dump-slave"></a>8.将主库的binlog位置和文件名追加到导出数据的文件中,–dump-slave</h4><pre><code>注意：如果当前服务器是slave服务器那么使用该命令会执行stop slave来获取master binlog的文件和位置，等备份完后会自动执行start slave启动该slave服务器。但是如果是大的数据量备份会给slave和master的延时变的更大，使用--dump-slave获取到的只是当前的从服务器的数据执行到的主的binglog的位置是（relay_mater_log_file,exec_master_log_pos),而不是主服务器当前的binlog执行的位置，主要是取决于主从的数据延时。</code></pre><pre><code>当该参数在slave服务器上执行时，相当于执行show slave status。当设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。mysqldump -uroot -proot --dump-slave=1 --databases db1 &gt;/tmp/db1.sqlmysqldump -uroot -proot --dump-slave=2 --database db1 &gt;/tmp/db1.sql</code></pre><h4 id="9-将当前服务器的binlog的位置和文件名追加输出到文件，–master-data"><a href="#9-将当前服务器的binlog的位置和文件名追加输出到文件，–master-data" class="headerlink" title="9.将当前服务器的binlog的位置和文件名追加输出到文件，–master-data"></a>9.将当前服务器的binlog的位置和文件名追加输出到文件，–master-data</h4><pre><code>该参数和--dump-slave方法一样，只是它是记录的是当前服务器的binlog，相当于执行show master status，状态（file,position)的值。注意：--master-data不会停止当前服务器的主从服务</code></pre><h4 id="10-–opt和–skip-opt"><a href="#10-–opt和–skip-opt" class="headerlink" title="10.–opt和–skip-opt"></a>10.–opt和–skip-opt</h4><pre><code>等同于--add-drop-table, --add-locks, --create-options, --quick, --extended-insert, --lock-tables, --set-charset, --disable-keys 该选项默认开启, 可以用--skip-opt禁用，来避免锁表。#避免备份过程中锁表mysqldump -uroot -p --host=h1 --all-databases --skip-opt</code></pre><h4 id="11-保证导出的一致性状态-–single-transaction"><a href="#11-保证导出的一致性状态-–single-transaction" class="headerlink" title="11.保证导出的一致性状态, –single-transaction"></a>11.保证导出的一致性状态, –single-transaction</h4><pre><code>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎（它不显示加锁通过判断版本来对比数据），仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。</code></pre><pre><code>--quick, -q不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。</code></pre><h4 id="12-开始导出前，锁定所有表-–lock-tables-l"><a href="#12-开始导出前，锁定所有表-–lock-tables-l" class="headerlink" title="12.开始导出前，锁定所有表, –lock-tables,-l"></a>12.开始导出前，锁定所有表, –lock-tables,-l</h4><pre><code>用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。</code></pre><h4 id="13-导出存储过程和自定义函数-–routines-R"><a href="#13-导出存储过程和自定义函数-–routines-R" class="headerlink" title="13.导出存储过程和自定义函数, –routines, -R"></a>13.导出存储过程和自定义函数, –routines, -R</h4><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --routines</code></pre><h4 id="14-压缩备份-还原"><a href="#14-压缩备份-还原" class="headerlink" title="14.压缩备份+还原"></a>14.压缩备份+还原</h4><pre><code>压缩备份mysqldump -uroot -p -P3306 -q -Q --default-character-set=utf8 --hex-blob --skip-lock-tables --databases abc 2&gt;/abc.err |gzip &gt;/abc.sql.gz注：-q或--quick :不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。-Q或--quote-names: 使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。--default-character-set: 设置默认字符集,默认为utf-8--hex-blob:使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。</code></pre><pre><code>还原gunzip -c abc.sql.gz |mysql -uroot -p -vvv -P3306 --default-character-set=utf8 abc 1&gt; abc.log 2&gt;abc.err</code></pre><h2 id="附录：参数说明："><a href="#附录：参数说明：" class="headerlink" title="附录：参数说明："></a>附录：参数说明：</h2><pre><code>--all-databases  , -A: 导出全部数据库。mysqldump  -uroot -p --all-databases--all-tablespaces  , -Y: 导出全部表空间。mysqldump  -uroot -p --all-databases --all-tablespaces--no-tablespaces  , -y: 不导出任何表空间信息。mysqldump  -uroot -p --all-databases --no-tablespaces--add-drop-database: 每个数据库创建之前添加drop数据库语句。mysqldump  -uroot -p --all-databases --add-drop-database --add-drop-table每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用--skip-add-drop-table取消选项)mysqldump  -uroot -p --all-databases  (默认添加drop语句)mysqldump  -uroot -p --all-databases –skip-add-drop-table  (取消drop语句)--add-locks: 在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用--skip-add-locks取消选项)mysqldump  -uroot -p --all-databases  (默认添加LOCK语句)mysqldump  -uroot -p --all-databases –skip-add-locks   (取消LOCK语句)--allow-keywords: 允许创建是关键词的列名字。这由表名前缀于每个列名做到。mysqldump  -uroot -p --all-databases --allow-keywords--apply-slave-statements: 在&#39;CHANGE MASTER&#39;前添加&#39;STOP SLAVE&#39;，并且在导出的最后添加&#39;START SLAVE&#39;。mysqldump  -uroot -p --all-databases --apply-slave-statements--character-sets-dir:字符集文件的目录mysqldump  -uroot -p --all-databases  --character-sets-dir=/usr/local/mysql/share/mysql/charsets--comments: 附加注释信息。默认为打开，可以用--skip-comments取消mysqldump  -uroot -p --all-databases  (默认记录注释)mysqldump  -uroot -p --all-databases --skip-comments   (取消注释)--compatible: 导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。mysqldump  -uroot -p --all-databases --compatible=ansi--compact: 导出更少的输出信息(用于调试)。去掉注释和头尾等结构。mysqldump  -uroot -p --all-databases --compact--complete-insert,  -c使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。mysqldump  -uroot -p --all-databases --complete-insert--compress, -C :在客户端和服务器之间启用压缩传递所有信息mysqldump  -uroot -p --all-databases --compress--create-options,-a :在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)mysqldump  -uroot -p --all-databases--databases,-B:导出几个数据库。参数后面所有名字参量都被看作数据库名。mysqldump  -uroot -p --databases test mysql--debug: 输出debug信息，用于调试。默认值为：d:t,/tmp/mysqldump.tracemysqldump  -uroot -p --all-databases --debugmysqldump  -uroot -p --all-databases --debug=” d:t,/tmp/debug.trace”--debug-check: 检查内存和打开文件使用说明并退出。mysqldump  -uroot -p --all-databases --debug-check--debug-info: 输出调试信息并退出mysqldump  -uroot -p --all-databases --debug-info--default-character-set: 设置默认字符集，默认值为utf8mysqldump  -uroot -p --all-databases --default-character-set=utf8--delayed-insert: 采用延时插入方式（INSERT DELAYED）导出数据mysqldump  -uroot -p --all-databases --delayed-insert--delete-master-logs: master备份后删除日志. 这个参数将自动激活--master-data。mysqldump  -uroot -p --all-databases --delete-master-logs--disable-keys对于每个表，用/*!40000 ALTER TABLE tbl_name DISABLE KEYS */;和/*!40000 ALTER TABLE tbl_name ENABLE KEYS */;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。mysqldump  -uroot -p --all-databases --dump-slave该选项将主的binlog位置和文件名追加到导出数据的文件中(show slave status)。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。该选项将会打开--lock-all-tables，除非--single-transaction被指定。该选项会自动关闭--lock-tables选项。默认值为0。mysqldump  -uroot -p --all-databases --dump-slave=1mysqldump  -uroot -p --all-databases --dump-slave=2--master-data该选项将当前服务器的binlog的位置和文件名追加到输出文件中(show master status)。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开--lock-all-tables 选项，除非--single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的--single-transaction选项）。该选项自动关闭--lock-tables选项。mysqldump  -uroot -p --host=localhost --all-databases --master-data=1;mysqldump  -uroot -p --host=localhost --all-databases --master-data=2;--events, -E : 导出事件。mysqldump  -uroot -p --all-databases --events--extended-insert,  -e使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用--skip-extended-insert取消选项。mysqldump  -uroot -p --all-databasesmysqldump  -uroot -p --all-databases--skip-extended-insert   (取消选项)--fields-terminated-by导出文件中忽略给定字段。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-terminated-by=”#”--fields-enclosed-by输出文件中的各个字段用给定字符包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=”#”--fields-optionally-enclosed-by输出文件中的各个字段用给定字符选择性包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p test test --tab=”/home/mysql”  --fields-enclosed-by=”#” --fields-optionally-enclosed-by=”#”--fields-escaped-by输出文件中的各个字段忽略给定字符。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p mysql user --tab=”/home/mysql” --fields-escaped-by=”#”--flush-logs : 开始导出之前刷新日志。请注意：假如一次导出多个数据库(使用选项--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--lock-all-tables或者--master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用--lock-all-tables 或者--master-data 和--flush-logs。mysqldump  -uroot -p --all-databases --flush-logs--flush-privileges在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。mysqldump  -uroot -p --all-databases --flush-privileges--force: 在导出过程中忽略出现的SQL错误。mysqldump  -uroot -p --all-databases --force--help: 显示帮助信息并退出。mysqldump  --help--hex-blob使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。mysqldump  -uroot -p --all-databases --hex-blob--host, -h : 需要导出的主机信息mysqldump  -uroot -p --host=localhost --all-databases--ignore-table不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：--ignore-table=database.table1 --ignore-table=database.table2 ……mysqldump  -uroot -p --host=localhost --all-databases --ignore-table=mysql.user--include-master-host-port在--dump-slave产生的&#39;CHANGE  MASTER TO..&#39;语句中增加&#39;MASTER_HOST=&lt;host&gt;，MASTER_PORT=&lt;port&gt;&#39;  mysqldump  -uroot -p --host=localhost --all-databases --include-master-host-port--insert-ignore: 在插入行时使用INSERT IGNORE语句.mysqldump  -uroot -p --host=localhost --all-databases --insert-ignore--lines-terminated-by输出文件的每行用给定字符串划分。与--tab选项一起使用，不能用于--databases和--all-databases选项。mysqldump  -uroot -p --host=localhost test test --tab=”/tmp/mysql”  --lines-terminated-by=”##”--lock-all-tables,  -x提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭--single-transaction 和--lock-tables 选项。mysqldump  -uroot -p --host=localhost --all-databases --lock-all-tables--lock-tables,  -l开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。mysqldump  -uroot -p --host=localhost --all-databases --lock-tables--log-error: 附加警告和错误信息到给定文件mysqldump  -uroot -p --host=localhost --all-databases  --log-error=/tmp/mysqldump_error_log.err--max_allowed_packet: 服务器发送和接受的最大包长度。mysqldump  -uroot -p --host=localhost --all-databases --max_allowed_packet=10240--net_buffer_length : TCP/IP和socket连接的缓存大小。mysqldump  -uroot -p --host=localhost --all-databases --net_buffer_length=1024--no-autocommit: 使用autocommit/commit 语句包裹表。mysqldump  -uroot -p --host=localhost --all-databases --no-autocommit--no-create-db,  -n: 只导出数据，而不添加CREATE DATABASE 语句。mysqldump  -uroot -p --host=localhost --all-databases --no-create-db--no-create-info,-t :只导出数据，而不添加CREATE TABLE 语句。mysqldump  -uroot -p --host=localhost --all-databases --no-create-info--no-data, -d : 不导出任何数据，只导出数据库表结构。mysqldump  -uroot -p --host=localhost --all-databases --no-data--no-set-names,-N :等同于--skip-set-charsetmysqldump  -uroot -p --host=localhost --all-databases --no-set-names--opt等同于--add-drop-table,  --add-locks, --create-options, --quick, --extended-insert, --lock-tables,  --set-charset, --disable-keys 该选项默认开启,  可以用--skip-opt禁用.mysqldump  -uroot -p --host=localhost --all-databases --opt--order-by-primary如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。 mysqldump  -uroot -p --host=localhost --all-databases --order-by-primary--password, -p :连接数据库密码--port, -P :连接数据库端口号--protocol :使用的连接协议，包括：tcp, socket, pipe, memory.mysqldump  -uroot -p --host=localhost --all-databases --protocol=tcp--quick, -q :不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。mysqldump  -uroot -p --host=localhost --all-databases mysqldump  -uroot -p --host=localhost --all-databases --skip-quick--quote-names,-Q :使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-quote-names--replace :使用REPLACE INTO 取代INSERT INTO.mysqldump  -uroot -p --host=localhost --all-databases --replace--result-file,  -r直接输出到指定文件中。该选项应该用在使用回车换行对（\\r\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。mysqldump  -uroot -p --host=localhost --all-databases --result-file=/tmp/mysqldump_result_file.txt--routines, -R :导出存储过程以及自定义函数。mysqldump  -uroot -p --host=localhost --all-databases --routines--set-charset添加&#39;SET NAMES  default_character_set&#39;到输出文件。默认为打开状态，使用--skip-set-charset关闭选项。mysqldump  -uroot -p --host=localhost --all-databases mysqldump  -uroot -p --host=localhost --all-databases --skip-set-charset--single-transaction该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。mysqldump  -uroot -p --host=localhost --all-databases --single-transaction--dump-date :将导出时间添加到输出文件中。默认为打开状态，使用--skip-dump-date关闭选项。mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-dump-date--skip-opt: 禁用–opt选项.mysqldump  -uroot -p --host=localhost --all-databases --skip-opt--socket,-S指定连接mysql的socket文件位置，默认路径/tmp/mysql.sockmysqldump  -uroot -p --host=localhost --all-databases --socket=/tmp/mysqld.sock--tab,-T为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。注意使用--tab不能指定--databases参数mysqldump  -uroot -p --host=localhost test test --tab=&quot;/home/mysql&quot;--tables覆盖--databases (-B)参数，指定需要导出的表名，在后面的版本会使用table取代tables。mysqldump  -uroot -p --host=localhost --databases test --tables test--triggers: 导出触发器。该选项默认启用，用--skip-triggers禁用它。mysqldump  -uroot -p --host=localhost --all-databases --triggers--tz-utc在导出顶部设置时区TIME_ZONE=&#39;+00:00&#39; ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。mysqldump  -uroot -p --host=localhost --all-databases --tz-utc--user, -u :指定连接的用户名。--verbose, --v :输出多种平台信息。--version, -V  :输出mysqldump版本信息并退出--where, -w只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。mysqldump  -uroot -p --host=localhost --all-databases --where=” user=’root’”--xml, -X :导出XML格式.mysqldump  -uroot -p --host=localhost --all-databases --xml--plugin_dir :客户端插件的目录，用于兼容不同的插件版本。mysqldump  -uroot -p --host=localhost --all-databases --plugin_dir=”/usr/local/lib/plugin”--default_auth :客户端插件默认使用权限。mysqldump  -uroot -p --host=localhost --all-databases --default-auth=”/usr/local/lib/plugin/&lt;PLUGIN&gt;”</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在日常维护工作当中经常会需要对数据进行导出操作，而mysqldump是导出数据过程中使用非常频繁的一个工具；它自带的功能参数非常多，可以轻松完成看似很复杂的需求。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文摘选自：&lt;a href=&quot;http://www.cnblogs.com/chenmh/p/5300370.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pursuer.chen&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mysql" scheme="https://wuyanteng.github.io/tags/mysql/"/>
    
      <category term="mysqldump详解" scheme="https://wuyanteng.github.io/tags/mysqldump%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="mysql导入导出" scheme="https://wuyanteng.github.io/tags/mysql%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>mysql用户远程登录失败--Host is not allowed to connect to this MySQL server</title>
    <link href="https://wuyanteng.github.io/2018/07/25/mysql%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/"/>
    <id>https://wuyanteng.github.io/2018/07/25/mysql用户远程登录失败/</id>
    <published>2018-07-25T02:13:55.000Z</published>
    <updated>2018-07-25T02:31:00.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h4><pre><code>mysql远程登录失败，错误如下：Host &#39;X.X.X.X&#39; is not allowed to connect to this MySQL server.</code></pre><a id="more"></a><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><pre><code>当前使用的用户不允许从远程登录</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>方案1：更改用户表</p><pre><code>mysql &gt; use mysql;mysql &gt; update user set host = &#39;%&#39; where user = &#39;usr_name&#39;;;其中， usr_name 用户名； 而 &#39;%&#39; 为通配符，表示匹配所有主机。</code></pre><p>方案2：命令行授权</p><pre><code>mysql &gt; grant all privileges on db_name.* to usr_name@&#39;%&#39; identified by &#39;user_password&#39;;mysql &gt; flush privileges ;其中，db_name 是数据库名， usr_name 用户名， pwd 密码。&#39;%&#39; 为通配符。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;故障描述&quot;&gt;&lt;a href=&quot;#故障描述&quot; class=&quot;headerlink&quot; title=&quot;故障描述&quot;&gt;&lt;/a&gt;故障描述&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;mysql远程登录失败，错误如下：
Host &amp;#39;X.X.X.X&amp;#39; is not allowed to connect to this MySQL server.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mysql" scheme="https://wuyanteng.github.io/tags/mysql/"/>
    
      <category term="root远程登录" scheme="https://wuyanteng.github.io/tags/root%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>vim打开文件中文乱码问题</title>
    <link href="https://wuyanteng.github.io/2018/07/12/vim%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://wuyanteng.github.io/2018/07/12/vim打开文件中文乱码问题/</id>
    <published>2018-07-12T04:16:26.000Z</published>
    <updated>2018-07-12T06:24:36.119Z</updated>
    
    <content type="html"><![CDATA[<pre><code>vim ~/.vimrc</code></pre><pre><code>set encoding=utf-8set fenc=utf-8set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gbk2312,cp936</code></pre><pre><code>现在试试中文乱码就消失了</code></pre><p>GitHub参考：<a href="https://gist.github.com/jhezjkp/3405319" target="_blank" rel="noopener">.vimrc配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;vim ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;set encoding=utf-8
set fenc=utf-8
set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gbk2312,cp936
&lt;
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="vim" scheme="https://wuyanteng.github.io/tags/vim/"/>
    
      <category term="中文乱码" scheme="https://wuyanteng.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6部署bugzilla</title>
    <link href="https://wuyanteng.github.io/2018/07/11/CentOS6%E9%83%A8%E7%BD%B2bugzilla/"/>
    <id>https://wuyanteng.github.io/2018/07/11/CentOS6部署bugzilla/</id>
    <published>2018-07-11T06:17:03.000Z</published>
    <updated>2018-07-11T10:32:20.679Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Bugzilla介绍"><a href="#Bugzilla介绍" class="headerlink" title="Bugzilla介绍"></a>Bugzilla介绍</h5><pre><code>Bugzilla 是一个开源的缺陷跟踪系统（Bug-Tracking System），它可以管理软件开发中缺陷的提交（new），修复（resolve），关闭（close）等整个生命周期。它可以使我们更好的在软件开发过程中跟踪软件错误的处理过程，为开发和测试工作以及产品质量的度量提供数据支持。并能够为你建立一个完善的 Bug 跟踪体系, 包括报告Bug、查询Bug记录并产生报表。</code></pre><a id="more"></a><h4 id="部署Bugzilla"><a href="#部署Bugzilla" class="headerlink" title="部署Bugzilla"></a>部署Bugzilla</h4><pre><code>系统环境：CentOS6.9由于需要使用其提供的自动化脚本安装很多依赖库，故不建议使用小众Linux</code></pre><h5 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h5><pre><code>关闭防火墙service iptables stop关闭selinuxsetenforce 0</code></pre><h5 id="安装Apache-MySQL及相关依赖"><a href="#安装Apache-MySQL及相关依赖" class="headerlink" title="安装Apache|MySQL及相关依赖"></a>安装Apache|MySQL及相关依赖</h5><pre><code>yum -y install httpd mod_ssl mysql-server mysql php-mysql gcc perl* mod_perl-develservice httpd startchkconfig httpd onservice mysqld startservice mysqld on</code></pre><h5 id="设置mysql-root密码"><a href="#设置mysql-root密码" class="headerlink" title="设置mysql root密码"></a>设置mysql root密码</h5><pre><code>mysql密码默认为空，需修改如下：mysqladmin -uroot -p password &quot;123456&quot;登陆测试mysql -uroot -p123456创建数据库名为bugscreate database bugs;grant all on bugs.* to root@localhost identified by &quot;123456&quot;;flush privileges; </code></pre><h5 id="下载安装bugzilla"><a href="#下载安装bugzilla" class="headerlink" title="下载安装bugzilla"></a>下载安装bugzilla</h5><pre><code>官网:https://www.bugzilla.org/download/或https://archive.mozilla.org/pub/webtools/</code></pre><pre><code>以bugzilla-5.0.3.tar.gz为例：解压tar xf bugzilla-5.0.3.tar.gz -C /var/www/html/重命名源码目录cd /var/www/htmlmv bugzilla-5.0.3 bugzilla检查缺少的组件cd /var/www/html/bugzilla./checksetup.pl --check-modules自动化安装缺少的组件perl install-module.pl --all运行以下这条命令，它会在/var/www/html/bugzilla路径下自动生成一个名为localconfig的文件。./checksetup.pl主要修改以下数据库相关信息vim localconfig$db_driver = &#39;mysql&#39;;$db_host = &#39;localhost&#39;;$db_name = &#39;bugs&#39;;$db_user = &#39;root&#39;;$db_pass = &#39;123456&#39;;$db_port = 3306;最后，再次执行以下命令根据提示输入管理员邮箱及密码./checksetup.pl </code></pre><h5 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h5><pre><code>vi /etc/httpd/conf/httpd.conf   在配置文件底部添加如下内容：&lt;VirtualHost *:80&gt;     DocumentRoot /var/www/html/bugzilla/&lt;/VirtualHost&gt;&lt;Directory /var/www/html/bugzilla&gt;     AddHandler cgi-script .cgi     Options +Indexes +ExecCGI     DirectoryIndex index.cgi     AllowOverride Limit FileInfo Indexes&lt;/Directory&gt;</code></pre><pre><code>接着需要编辑.htacess文件，注释掉以下内容,保存：vim /var/www/html/bugzilla/.htaccess#Options -Indexes</code></pre><pre><code>重启Apache服务，浏览器测试访问service httpd restart浏览器： http://server-ip</code></pre><p><img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/bugzilla.jpg" alt="bugzilla"></p><h4 id="关于Bugzilla源码和数据库迁移"><a href="#关于Bugzilla源码和数据库迁移" class="headerlink" title="关于Bugzilla源码和数据库迁移"></a>关于Bugzilla源码和数据库迁移</h4><pre><code>注意事项：1. 首先在新机器上按照如上步骤完整部署一套，目的是安装完所有依赖。2. 将原数据库中的bugs通过mysqldump导出一份sql文件3. 将原bugs.sql导入到新库名为bugzilla数据库中，并修改新部署的一套源码中localconfig文件，修改数据库设置，重启apache服务，如果能正常使用，则迁移完毕。4. 若无法登陆，可能之前版本嵌入了LDAP账号，此时就需要把原bugzilla代码目录整个压缩拷贝过来，并修改localconfig文件为最新mysql数据库信息，重启mysql，访问并测试。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Bugzilla介绍&quot;&gt;&lt;a href=&quot;#Bugzilla介绍&quot; class=&quot;headerlink&quot; title=&quot;Bugzilla介绍&quot;&gt;&lt;/a&gt;Bugzilla介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Bugzilla 是一个开源的缺陷跟踪系统（Bug-Tracking System），它可以管理软件开发中缺陷的提交（new），修复（resolve），关闭（close）等整个生命周期。

它可以使我们更好的在软件开发过程中跟踪软件错误的处理过程，为开发和测试工作以及产品质量的度量提供数据支持。并能够为你建立一个完善的 Bug 跟踪体系, 包括报告Bug、查询Bug记录并产生报表。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="bugzilla" scheme="https://wuyanteng.github.io/tags/bugzilla/"/>
    
      <category term="bugs" scheme="https://wuyanteng.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>Mongo Slave节点无法show dbs</title>
    <link href="https://wuyanteng.github.io/2018/07/09/Mongo-Slave%E8%8A%82%E7%82%B9%E6%97%A0%E6%B3%95show-dbs/"/>
    <id>https://wuyanteng.github.io/2018/07/09/Mongo-Slave节点无法show-dbs/</id>
    <published>2018-07-09T08:00:54.000Z</published>
    <updated>2018-07-09T08:08:30.880Z</updated>
    
    <content type="html"><![CDATA[<p>在SECONDARY节点无法show dbs</p><pre><code>主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:QUERY  Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }</code></pre><a id="more"></a><p>解决方法</p><pre><code>在报错的slave机器上执行 rs.slaveOk()  再执行show dbs即可</code></pre><p>官网解释</p><pre><code>Provides a shorthand for the following operation:db.getMongo().setSlaveOk()This allows the current connection to allow read operations to run on secondary members. See the readPref() method for more fine-grained control over read preference in the mongo shell.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SECONDARY节点无法show dbs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:

QUERY  Error: listDatabases failed:{ &amp;quot;note&amp;quot; : &amp;quot;from execCommand&amp;quot;, &amp;quot;ok&amp;quot; : 0, &amp;quot;errmsg&amp;quot; : &amp;quot;not master&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="SECONDARY" scheme="https://wuyanteng.github.io/tags/SECONDARY/"/>
    
      <category term="PRIMARY" scheme="https://wuyanteng.github.io/tags/PRIMARY/"/>
    
      <category term="MongoDB" scheme="https://wuyanteng.github.io/tags/MongoDB/"/>
    
      <category term="slave" scheme="https://wuyanteng.github.io/tags/slave/"/>
    
      <category term="show dbs" scheme="https://wuyanteng.github.io/tags/show-dbs/"/>
    
  </entry>
  
</feed>
