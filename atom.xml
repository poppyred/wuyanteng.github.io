<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gary Wu</title>
  
  <subtitle>运维架构师 - 从入门到放弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyanteng.github.io/"/>
  <updated>2018-09-03T08:28:21.277Z</updated>
  <id>https://wuyanteng.github.io/</id>
  
  <author>
    <name>Gary Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于OpenSSL自建CA和颁发SSL证书</title>
    <link href="https://wuyanteng.github.io/2018/09/03/%E5%9F%BA%E4%BA%8EOpenSSL%E8%87%AA%E5%BB%BACA%E5%92%8C%E9%A2%81%E5%8F%91SSL%E8%AF%81%E4%B9%A6/"/>
    <id>https://wuyanteng.github.io/2018/09/03/基于OpenSSL自建CA和颁发SSL证书/</id>
    <published>2018-09-03T07:46:16.000Z</published>
    <updated>2018-09-03T08:28:21.277Z</updated>
    
    <content type="html"><![CDATA[<h5 id="编译安装openssl"><a href="#编译安装openssl" class="headerlink" title="编译安装openssl"></a>编译安装openssl</h5><pre><code>官网：https://www.openssl.org/source/</code></pre><pre><code>wget https://www.openssl.org/source/openssl-1.1.1-pre9.tar.gztar -zxvf openssl-1.1.1-pre9.tar.gz cd openssl-1.1.1-pre9/./configmakemake testmake install</code></pre><a id="more"></a><pre><code>whereis opensslecho &quot;export LD_LIBRARY_PATH=/usr/local/lib&quot; &gt;&gt;/etc/profilesource /etc/profileroot@lohost:~# openssl versionOpenSSL 1.1.1-pre9 (beta) 21 Aug 2018</code></pre><h2 id="颁发证书"><a href="#颁发证书" class="headerlink" title="颁发证书"></a>颁发证书</h2><h5 id="生成根密钥"><a href="#生成根密钥" class="headerlink" title="生成根密钥"></a>生成根密钥</h5><pre><code>CA要给别人颁发证书，首先自己得有一个作为根证书cd /data/caopenssl genrsa -out cakey.pem 4096</code></pre><h5 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h5><pre><code>使用req命令生成自签证书：openssl req -new -x509 -key cakey.pem -out cacert.pem会提示输入一些信息：Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:BJOrganization Name (eg, company) [Internet Widgits Pty Ltd]:AloneOrganizational Unit Name (eg, section) []:AloneCommon Name (e.g. server FQDN or YOUR name) []:xx.xx.xx.xx     Email Address []:xxx@gmail.com</code></pre><h5 id="以上CA证书创建完毕-下面来给程序颁发SSL证书"><a href="#以上CA证书创建完毕-下面来给程序颁发SSL证书" class="headerlink" title="以上CA证书创建完毕,下面来给程序颁发SSL证书"></a>以上CA证书创建完毕,下面来给程序颁发SSL证书</h5><pre><code>mkdir -p /data/ca/sslcd /data/ca/ssl#生成ssl密钥openssl genrsa -out server.key 4096#生成csropenssl req -new -key server.key -out server.csr同样会提示输入一些内容，除了Commone Name字段一定要是你要授予证书的服务器域名或主机名，challenge password不填。#最后使用CA签署证书openssl x509 -req -in /data/ca/ssl/server.csr -CA /data/ca/cacert.pem -CAkey /data/ca/cakey.pem -CAcreateserial -out /data/ca/ssl/server.crt</code></pre><pre><code>生成以后，/data/ca/ssl目录下的crt和key文件就可以被程序使用了</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;编译安装openssl&quot;&gt;&lt;a href=&quot;#编译安装openssl&quot; class=&quot;headerlink&quot; title=&quot;编译安装openssl&quot;&gt;&lt;/a&gt;编译安装openssl&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;官网：https://www.openssl.org/source/
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;wget https://www.openssl.org/source/openssl-1.1.1-pre9.tar.gz
tar -zxvf openssl-1.1.1-pre9.tar.gz 
cd openssl-1.1.1-pre9/
./config
make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="OpenSSL" scheme="https://wuyanteng.github.io/tags/OpenSSL/"/>
    
      <category term="CA" scheme="https://wuyanteng.github.io/tags/CA/"/>
    
      <category term="SSL证书" scheme="https://wuyanteng.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"/>
    
      <category term="pem" scheme="https://wuyanteng.github.io/tags/pem/"/>
    
      <category term="csr" scheme="https://wuyanteng.github.io/tags/csr/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本中嵌入ssh无密钥登陆</title>
    <link href="https://wuyanteng.github.io/2018/08/31/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%B5%8C%E5%85%A5ssh%E6%97%A0%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/"/>
    <id>https://wuyanteng.github.io/2018/08/31/shell脚本中嵌入ssh无密钥登陆/</id>
    <published>2018-08-31T06:17:21.000Z</published>
    <updated>2018-08-31T07:36:19.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><pre><code>有这样一个生产场景: zabbix-agent只在server1服务器有安装并提供监控服务，想使用这一台server1服务器通过编写shell脚本去监控其他服务器运行的服务，比如：服务运行状态、log日志统计并发等等。如何做？</code></pre><a id="more"></a><p>场景分析</p><pre><code>server1需要与其他server创建SSH互信，shell中通过ssh来远程登陆到其他服务器来执行命令。那么问题来了？命令执行完成，如何在shell中退出并将命令执行后的结果返回到server1中，并让zabbix去监控呢？</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h4 id="将server1的密钥上传到101服务器实现ssh互信"><a href="#将server1的密钥上传到101服务器实现ssh互信" class="headerlink" title="将server1的密钥上传到101服务器实现ssh互信"></a>将server1的密钥上传到101服务器实现ssh互信</h4><pre><code>首先在server1以root命令生成SSH密钥[root@web01 ~]# ssh-keygen -t dsaGenerating public/private dsa key pair.Enter file in which to save the key (/root/.ssh/id_dsa):Created directory &#39;/root/.ssh&#39;.Enter passphrase (empty for no passphrase):Enter same passphrase again: Your identification has been saved in /root/.ssh/id_dsa.Your public key has been saved in /root/.ssh/id_dsa.pub.The key fingerprint is:25:93:78:e9:01:2d:82:db:cb:0b:34:f7:0c:a9:1b:11 root@web01The key&#39;s randomart image is:+--[ DSA 1024]----+|   .  ..         ||  E . .o.o       ||   + o..B .      ||  = =  o =       || . * =  S        ||  + o o          ||   + .           ||  . .            ||                 |+-----------------+#检查密钥文件[root@web01 ~]# ll /root/.ssh/total 8-rw------- 1 root root 736 2017-08-06 15:17 id_dsa-rw-r--r-- 1 root root 600 2017-08-06 15:17 id_dsa.pub#将生成的.pub密钥上传到所需的服务器上（比如：101），实现ssh免密登陆 ssh-copy-id -i ~/.ssh/id_dsa.pub root@10.10.10.101#确认远端101服务器密钥上传成功[root@101 ~]# ll /root/.ssh/total 8-rw------- 1 root root 600 2017-08-06 15:29 authorized_keys-rw-r--r-- 1 root root 393 2017-08-05 11:03 known_hosts#在server1服务器无密码远程登录测试[root@web01 ~]# ssh root@10.10.10.101注意：如果远程登录失败,需要配置ssh允许root登录，并重启ssh服务。</code></pre><h4 id="在101服务器生成密钥上传到server1服务器，实现反向ssh互信"><a href="#在101服务器生成密钥上传到server1服务器，实现反向ssh互信" class="headerlink" title="在101服务器生成密钥上传到server1服务器，实现反向ssh互信"></a>在101服务器生成密钥上传到server1服务器，实现反向ssh互信</h4><pre><code>在101服务器，生成dsa密钥，并上传到server1服务器，实现互信。</code></pre><h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h4><pre><code>接下来就可以愉快的在server1编写所需的shell脚本了，范例如下：[root@web01 ~]# cat /opt/check_service.sh</code></pre><pre><code>#!/bin/bashDNS_IP=10.0.0.101FILE1=/var/log/dns.logFILE2=/tmp/pri_dns.logNOW_UNIX=`date +%s`UNIX=`expr ${NOW_UNIX} - 60` #本地文件清理rm -f $FILE2#SSH DNS并发信息获取ssh root@${DNS_IP} &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF    egrep &quot;${UNIX}&quot; $FILE1|wc -l &gt;$FILE2    scp -r $FILE2 root@server1:/tmp/     exitEOF</code></pre><pre><code>脚本逻辑：(1)定义所需环境变量(2)通过如下方式在shell中嵌入SSH远程登录并在远程服务器执行命令   ssh root@10.10.10.101 &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF      comm1...      comm2...      comm3...      exit   EOF在上面的例子中，远端执行完毕后，通过scp方式，将结果传输到server1服务器的/tmp目录下，最后再编写zabbix自定义key来实现监控。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;有这样一个生产场景: zabbix-agent只在server1服务器有安装并提供监控服务，想使用这一台server1服务器通过编写shell脚本去监控其他服务器运行的服务，比如：服务运行状态、log日志统计并发等等。如何做？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://wuyanteng.github.io/tags/ssh/"/>
    
      <category term="shell脚本" scheme="https://wuyanteng.github.io/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>rsync限速实例</title>
    <link href="https://wuyanteng.github.io/2018/08/31/rsync%E9%99%90%E9%80%9F%E5%AE%9E%E4%BE%8B/"/>
    <id>https://wuyanteng.github.io/2018/08/31/rsync限速实例/</id>
    <published>2018-08-31T03:54:35.000Z</published>
    <updated>2018-08-31T04:02:31.533Z</updated>
    
    <content type="html"><![CDATA[<h4 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h4><pre><code>生产环境有这样的需求，需要跨机房传输TB级文件，但又不想其带宽占用的太厉害而影响了其他业务，这时候就需要使用rsync的限速功能了，简单扯下</code></pre><a id="more"></a><h4 id="rsync限速参数-–bwlimit"><a href="#rsync限速参数-–bwlimit" class="headerlink" title="rsync限速参数: –bwlimit"></a>rsync限速参数: –bwlimit</h4><pre><code>--bwlimit=100   单位：KBPS, 100意思是 传输速度限制100KB/s，也就是限速大概1MB的速度。再比如：想要限速50MB的速度，那么应该设置为 --bwlimit=5000</code></pre><h4 id="rsync限速传输命令"><a href="#rsync限速传输命令" class="headerlink" title="rsync限速传输命令"></a>rsync限速传输命令</h4><pre><code>参考：time rsync --port 873 -ravPz ./2018* rsync@X.X.X.X::logfile/2018/H5/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;场景介绍&quot;&gt;&lt;a href=&quot;#场景介绍&quot; class=&quot;headerlink&quot; title=&quot;场景介绍&quot;&gt;&lt;/a&gt;场景介绍&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;生产环境有这样的需求，需要跨机房传输TB级文件，但又不想其带宽占用的太厉害而影响了其他业务，这时候就需要使用rsync的限速功能了，简单扯下
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="rsync" scheme="https://wuyanteng.github.io/tags/rsync/"/>
    
      <category term="rsync限速" scheme="https://wuyanteng.github.io/tags/rsync%E9%99%90%E9%80%9F/"/>
    
      <category term="bwlimit" scheme="https://wuyanteng.github.io/tags/bwlimit/"/>
    
  </entry>
  
  <entry>
    <title>shell数组</title>
    <link href="https://wuyanteng.github.io/2018/08/28/shell%E6%95%B0%E7%BB%84/"/>
    <id>https://wuyanteng.github.io/2018/08/28/shell数组/</id>
    <published>2018-08-28T09:24:20.000Z</published>
    <updated>2018-08-29T10:44:38.462Z</updated>
    
    <content type="html"><![CDATA[<pre><code>shell数组</code></pre><a id="more"></a><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><pre><code>在Shell中，用括号来表示数组, 数组元素使用“空格” 分隔开，如：#数组定义name=(tom jerry jackson free gary)  #读取数组读取数组元素值的一般格式是：${数组名[下标]}，注：下标是从0开始的例如：echo ${name[0]}       #获取第1个元素值echo ${name[1]}       #获取第2个元素值echo ${name[2]}       #获取第3个元素值使用“*”或“@”符号可以获取数组中的所有元素echo ${name=[*]}echo $(name=[@])</code></pre><h4 id="数组删除"><a href="#数组删除" class="headerlink" title="数组删除"></a>数组删除</h4><pre><code>直接通过：&quot;unset 数组[下标]&quot; 可以清除相应的元素；若不带下标，则清除整个数据。 只清除第1个元素a=(1 2 3 4 5)unset a[0]echo ${a[*]}2 3 4 5清除整个数组元素unset a </code></pre><h4 id="数组之分片"><a href="#数组之分片" class="headerlink" title="数组之分片"></a>数组之分片</h4><pre><code>直接通过 &quot;${数组名[@或*]:起始位置:长度}&quot; 切片原先数组,然后返回字符串。如下：a=(1 2 3 4 5)       #定义数组echo ${a[@]:0:3}    #分片 1 2 3echo ${a[@]:1:4}2 3 4 5如果加上”()”，将得到切片数组，下面例子中，c就是一个新数据。c=(${a[@]:1:4})echo ${#c[@]}      #统计新数据c的元素总个数4echo ${c[*]}       #重新打印c的新数据数组 2 3 4 5  </code></pre><h4 id="数组之替换"><a href="#数组之替换" class="headerlink" title="数组之替换"></a>数组之替换</h4><pre><code>调用方法是：&quot;${数组名[@或*]/查找字符/替换字符}&quot; 注：该操作不会改变原先数组内容，如果需要修改，可以看下面例子，重新定义数据。# name=(gary tom jerry jackson)# echo ${name[@]/jackson/green}   #查找字符jackson，替换字符为greengary tom jerry green# echo ${name[@]}                 #可以看到，数组替换不会改变原数组的内容gary tom jerry jackson# name2=(${name[@]/jackson/green})  #但可以进行重新赋值来实现数组替换# echo ${name2[@]}gary tom jerry green</code></pre><pre><code>关于数组相关shell案例，有时间补充。。。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;shell数组
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="数组" scheme="https://wuyanteng.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>OpenVPN编译安装部署</title>
    <link href="https://wuyanteng.github.io/2018/08/23/OpenVPN%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/08/23/OpenVPN编译安装部署/</id>
    <published>2018-08-23T01:43:46.000Z</published>
    <updated>2018-08-23T02:30:24.380Z</updated>
    
    <content type="html"><![CDATA[<pre><code>整理下OpenVPN编译安装+部署过程，尤其是向客户端push路由、证书创建与吊销等相关技术。最后还会说明下客户端如何高可用实现逻辑负载均衡。</code></pre><a id="more"></a><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><pre><code>启动并清空iptables规则  # iptables -F  # service iptables save  # service iptables restart关闭SELINUX  # setenforce 0  # vi /etc/sysconfig/selinux    修改为SELINUX=disabled开启服务器端路由转发功能  # vi /etc/sysctl.conf    改为 net.ipv4.ip_forward = 1  # sysctl -p设置nat转发（注：添加正确的OpenVPN客户端网络地址）  # iptables -t nat -A POSTROUTING -s 172.101.101.0/24 -o eth0 -j MASQUERADE  注：如果是VPS配置openvpn，需要把上面的“-o eth0”参数取消，否则无法上网。设置iptables开放openvpn端口：  # iptables -A INPUT -p TCP --dport 1194 -j ACCEPT  # service iptables save  # service iptables restart时间同步(重要)：  # yum install ntp  # ntpdate asia.pool.ntp.org  # vi /etc/rc.d/rc.local    添加 /usr/bin/ntpdate asia.pool.ntp.org安装编译依赖库  # yum install -y openssl openssl-devel lzo lzo-devel pam pam-devel automake pkgconfig gcc gcc++</code></pre><h5 id="下载openvpn：-官网"><a href="#下载openvpn：-官网" class="headerlink" title="下载openvpn： 官网"></a>下载openvpn： <a href="https://openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="noopener">官网</a></h5><pre><code># tar -zxvf openvpn.2.3.10.tar.gz &amp;&amp; cd openvpn.2.3.10# ./configure --prefix=/usr/local/openvpn# make &amp;&amp; make install</code></pre><pre><code>创建/etc/openvpn目录# mkdir -p /etc/openvpn# cp -rf /root/openvpn.2.3.10/sample /etc/openvpn# cp /etc/openvpn/sample/sample-config-files/server.conf /etc/openvpn</code></pre><h5 id="安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3"><a href="#安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3" class="headerlink" title="安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3"></a>安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3</h5><pre><code># wget -c https://github.com/OpenVPN/easy-rsa/archive/master.zip# unzip master.zip# mv easy-ras-master easy-rsa# cp -rf easy-rsa /etc/openvpn# cd /etc/openvpn/easy-rsa/easyrsa3# cp vars.example vars# chmod +x vars修改Vars文件内的如下字段：set_var EASYRSA_REQ_COUNTRY &quot;CN&quot; //根据自己情况更改set_var EASYRSA_REQ_PROVINCE &quot;Beijing&quot;set_var EASYRSA_REQ_CITY &quot;Tong&quot;set_var EASYRSA_REQ_ORG &quot;qingliu Certificate&quot;set_var EASYRSA_REQ_EMAIL &quot;shuiqingliu14@gmail.com&quot;set_var EASYRSA_REQ_OU &quot;My OpenVPN&quot;创建服务端证书及KeyA. 进入/etc/openvpn/easy-rsa/easyrsa3/目录初始化：   ./easyrsa init-pkiB. 创建根证书   ./easyrsa build-ca   B1. 根据提示输入PEM密码，密码为：P**4 【务必要记住改密码，否则以后不能为证书签名】   B2. 还需要输入common name 通用名，配置为Moxiu。  C. 创建服务器端证书    ./easyrsa gen-req server nopassD. 签约服务端证书   ./easyrsa sign server server   根据提示输入”yes ” ,再输入刚才设置的PEM密码D. 创建Diffie-Hellman，确保key穿越不安全网络的命令   ./easyrsa gen-dh</code></pre><h5 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h5><pre><code>A. 在/root目录下，创建openvpn_users文件夹来存储所有客户端证书文件。   # mkdir  /root/openvpn_users &amp;&amp; cd openvpn_users   # cp -R /root/easy-rsa  ./   # cd easy-rsa/easyrsa3/   # cp vars.example  varsB. 初始化   # ./easyrsa init-pkiC. 创建客户端key以及生成证书（记住生成是自己输入的密码）   # ./easyrsa  gen-req  test   //名字自己定义D. 切换到Server证书目录下，将得到的test.req导入，然后签约证书# cd  /etc/openvpn/easy-rsa/easyrsa3/# ./easyrsa  import-req /root/openvpn_users/easy-rsa/easyrsa3/pki/reqs/test.req testD. 用户签约，根据提示输入服务端CA密码   # ./easyrsa sign client testE. 这一步很重要，看看生成的全部文件    (1)Server:  [目录：/etc/openvpn/easy-rsa/文件夹]    /etc/openvpn/easy-rsa/easyrsa3/pki/ca.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/reqs/server.req    /etc/openvpn/easy-rsa/easyrsa3/pki/reqs/test.req    /etc/openvpn/easy-rsa/easyrsa3/pki/private/ca.key    /etc/openvpn/easy-rsa/easyrsa3/pki/private/server.key    /etc/openvpn/easy-rsa/easyrsa3/pki/issued/server.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/issued/test.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/dh.pem    (2) Client: [目录：/etc/openvpn/clients/easy-rsa/文件夹]      /root/openvpn_users/easy-rsa/easyrsa3/pki/private/test.key      /root/openvpn_users/easy-rsa/easyrsa3/pki/reqs/test.req         这个文件被我们导入到了服务端文件所以那里也有F. 拷贝服务器证书文件放到/etc/openvpn目录   进入/etc/openvpn/easy-rsa/easyrsa3目录   #cp pki/ca.crt  /etc/openvpn   #cp pki/private/server.key  /etc/openvpn   #cp pki/issued/server.crt  /etc/openvpn   #cp pki/dh.pem  /etc/openvpnG. Client证书（集中放到一个文件夹下，给VPN用户使用）   # mkdir /root/users   # mkdir /root/users/test //内部文件夹以姓名全拼命名，方便下载这些密钥文件   # cd /root/users/test/   # cp /etc/openvpn/ca.crt ./              拷贝CA证书到test目录下   # cp /etc/openvpn/easy-rsa/easyrsa3/pki/issued/test.crt ./          拷贝（服务端路径）用户crt文件   # cp /root/openvpn_users/easy-rsa/easyrsa3/pki/private/test.key ./　　拷贝（客户端路径）用户key文件   查看   [root@OpenVPN test]# ls   ca.crt  test.crt  test.key</code></pre><h5 id="生成ta-key【为了安全】"><a href="#生成ta-key【为了安全】" class="headerlink" title="生成ta.key【为了安全】"></a>生成ta.key【为了安全】</h5><pre><code>配置服务之前，需要生成配置文件需要的ta.key文件，并将ta.key放入/etc/openvpn目录下【注：客户端连接也要使用有此文件】# cd /root/# /usr/local/openvpn/sbin/openvpn --genkey --secret ta.key# ls# cp  ta.key  /etc/openvpn/# cp ta.key /root/users/test</code></pre><h5 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h5><pre><code># vi /etc/openvpn/server.conf       local 10.0.8.28     #申明本机使用的IP地址，也可以不说明     port 1194     #申明使用的端口，默认1194     proto tcp     #申明使用的协议，默认使用UDP，如果使用HTTP proxy，必须使用TCP协议     dev tun     #申明使用的设备可选tap和tun，tap是二层设备，支持链路层协议。     ca /etc/openvpn/ca.crt     #指定ca证书的路径     cert /etc/openvpn/server.crt     #指定server.crt路径     key /etc/openvpn/server.key     #指定server.key路径     dh /etc/openvpn/dh.pem     #指定dh.pem路径     server 172.101.101.0 255.255.255.0     #为VPN客户端指定分配的网络地址（自己根据规划分配）     ifconfig-pool-persist ipp.txt     push &quot;redirect-gateway&quot;           #向客户端push网关【push 网关后，客户端通过远程网络上网，作用类似NAT伪装；如果不想这么做，就需要向客户端直接push路由--后边故障解决部分有介绍】     push &quot;dhcp-option DNS 114.114.114.114&quot;  #向客户端push DNS     client-to-client  #让客户端彼此可以互相访问     tls-auth   /etc/openvpn/ta.key 0       #注：此处客户端配置文件中该参数需要改为 tls-auth ta.key 1     comp-lzo     auth md5      cipher AES-256-CBC      max-clients 100      keepalive 10 120      persist-key      persist-tun      status openvpn-status.log      verb 3</code></pre><h5 id="启动openvpn"><a href="#启动openvpn" class="headerlink" title="启动openvpn"></a>启动openvpn</h5><pre><code>/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &amp;加入开机启动项【手动创建开机启动脚本文件】# vi  /etc/init.d/openvpn 输入以下内容，保存：#!/bin/bash# chkconfig: 2345 67 33# description: ntpd is the NTPv4 daemon.nohup /usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &gt; /tmp/open.log 2&gt;&amp;1 &amp;</code></pre><pre><code># chmod  755  openvpn             //添加执行权限# chkconfig --add openvpn# chkconfig openvpn on           //加入开机启动项# netstat -ln                   //查看端口是否正确启动</code></pre><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><pre><code>此处以windows客户端为例：安装Openvpn客户端并以管理员身份运行</code></pre><p>配置创建client.ovpn文件</p><pre><code>clientdev tunproto udpremote 10.0.8.28   #主要这里修改成自己server ipresolv-retry infinitenobindpersist-keypersist-tunca ca.crt               #这里需要证书cert test.crtkey  test.keyauth md5cipher AES-256-CBCtls-auth ta.key 1comp-lzoverb 3</code></pre><p>故障处理</p><pre><code>故障描述：运行openvpn客户端后，VPN连接正常，但无法上网和Ping公司内网</code></pre><pre><code>解决方法：  1. 打开Openvpn服务端配置文件   # vi /etc/openvpn/server.conf  添加如下静态路由(填写服务器这边的网络)  push &quot;route 10.0.8.0 255.255.254.0 net_gateway&quot;  push &quot;route 10.0.0.0 255.255.254.0 net_gateway&quot;  #push &quot;route 10.0.16.0 255.255.248.0 net_gateway&quot;  push &quot;route 0.0.0.0 0.0.0.0 net_gateway&quot;重启openvpn服务，再进行测试即可 </code></pre><h5 id="证书吊销"><a href="#证书吊销" class="headerlink" title="证书吊销"></a>证书吊销</h5><pre><code>OpenVPN证书吊销# cd  /etc/openvpn/easy-rsa/easyrsa3/# ./easyrsa revoke  clientName              //name输入需要注销的用户名称# ./easyrsa  gen-crl此时会在/etc/openvpn/easy-rsa/easyrsa3/pki目录下生成crl.pem文件# cp  ./etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem    /etc/openvpn# cd   /etc/openvpn# vim  server.conf添加如下内容：crl-verify  /etc/openvpn/crl.pem重启OpenVPN服务,使配置生效</code></pre><h6 id="关于客户端逻辑负载均衡"><a href="#关于客户端逻辑负载均衡" class="headerlink" title="关于客户端逻辑负载均衡"></a>关于客户端逻辑负载均衡</h6><pre><code>为什么说客户端负载均衡是逻辑上的呢？实现逻辑是这样：部署多台独立的openvpn服务端，然后客户端配置多台server ip地址，客户端每次连接都会选择不同的server进行连接，如果失败，则自动连接下一个server。客户端轮询部分配置如下：remote server1 1194remote server2 1194remote server3 1194remote-randomresolv-retry 2那么问题来了，如何保证多台server的配置文件和用户key能保持一致呢？解决方案：以其中一台server作为逻辑主server，也就是说所有的keys用户创建，都只在这个主server上进行，然后，将/etc/openvpn目录下的所有文件【注意：不包括server.conf主配置文件】覆盖到server2、server3上面【注意：不要覆盖server2和server3的主配置文件: server.conf,否则你就呵呵吧】，并重启他们的openvpn服务即可。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;整理下OpenVPN编译安装+部署过程，尤其是向客户端push路由、证书创建与吊销等相关技术。最后还会说明下客户端如何高可用实现逻辑负载均衡。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ovpn" scheme="https://wuyanteng.github.io/tags/ovpn/"/>
    
      <category term="openvpn" scheme="https://wuyanteng.github.io/tags/openvpn/"/>
    
      <category term="vpn" scheme="https://wuyanteng.github.io/tags/vpn/"/>
    
      <category term="easy-rsa3" scheme="https://wuyanteng.github.io/tags/easy-rsa3/"/>
    
  </entry>
  
  <entry>
    <title>Bind9主从同步部署</title>
    <link href="https://wuyanteng.github.io/2018/08/17/Bind9%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/08/17/Bind9主从同步部署/</id>
    <published>2018-08-17T09:20:09.000Z</published>
    <updated>2018-08-22T03:12:34.726Z</updated>
    
    <content type="html"><![CDATA[<pre><code>之前没有独立写过Bind主从同步，只有与LVS相结合的文章，故今天给补充完善。本次测试版本：bind-9.10.8-P1.tar.gz     </code></pre><a id="more"></a><h2 id="部署Bind主DNS"><a href="#部署Bind主DNS" class="headerlink" title="部署Bind主DNS"></a>部署Bind主DNS</h2><p>编译安装</p><pre><code>tar -zxvf bind-9.10.8-P1.tar.gzcd  bind-9.10.8-P1mkdir -p /etc/bind./configure --enable-threads --with-libtool --with-ecdsa --prefix=/usr/local/web2016/bind  \     --sysconfdir=/etc/bindmakemake install</code></pre><pre><code>编译参数，释义：--enable-threads    #开启多线程支持--with-libtool      #使用GNU libtool--with-ecdsa        #开启ECDSA算法支持</code></pre><p>命令软链</p><pre><code>ln -sv /usr/local/web2016/bind/sbin/* /sbin/</code></pre><p>创建傀儡用户named</p><pre><code>useradd -r -m  -d /var/named -s /sbin/nologin named</code></pre><p>创建rndc key</p><pre><code>伪造数据，便于生成keyecho &quot;1111111111qqqqqqqqqqqqwwwwwwwwwwwwwwddddddddddffffffhjFD21AAAAAAAAAAA&quot; &gt;/root/random生成keyrndc-confgen -r /root/random -s 127.0.0.1 -p 953 &gt;/etc/bind/rndc.conf</code></pre><p>手动创建named.conf</p><pre><code>vim /etc/bind/named.conf</code></pre><h4 id="named-conf配置文件"><a href="#named-conf配置文件" class="headerlink" title="named.conf配置文件"></a>named.conf配置文件</h4><pre><code>options {   listen-on port 53 { any; };      //定义DNS监听在哪个端口上   directory &quot;/etc/bind/zone&quot;;   //指定DNS区域文件存放目录   pid-file &quot;/etc/bind/var/named.pid&quot;;   //指定named进程pid文件路径   allow-query { any; };          //允许哪些主机可以使用该DNS来解析   Dump-file &quot;/etc/bind/var/binddump.db&quot;;     //缓存转储位置   Statistics-file &quot;/etc/bind/stats/named_stats&quot;;   //记录统计信息的文件   zone-statistics yes;  //收集在服务器所有域的统计数据, 这些统计数据可以通过使用rndc stats来访问   memstatistics-file &quot;/etc/bind/stats/mem_stats&quot;;     //记录内存使用的统计信息   empty-zones-enable yes;      forwarders {114.114.114.114;8.8.8.8;};   //定义上游DNS[需要配置root hint顶级域]};key &quot;rndc-key&quot; {               //注：这个key部分是通过rndc-confgen命令生成的配置，贴过来        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};controls {              //配置rndc权限与端口       inet 127.0.0.1 port 953       allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };};logging {  channel warning {        //warnning可以改为default_debug（默认）。     file &quot;/var/log/named/named.log&quot; versions 10 size 10m;    //日志文件路径/版本/大小     severity warning;     //如果warnning改为default_debug后，此处可以改为severity dynamic     print-category yes;   //日志中是否需要写入日志类别     print-severity yes;   //日志中是否需要写入消息级别     print-time yes;       //日志中是否需要写入时间    };     channel general_dns {               //绑定其他log channel通道，以下保持默认即可。     file &quot;/var/log/named/named2.log&quot; versions 10 size 100m;     severity info;         print-category yes;      print-severity yes;     print-time yes;    };  category default {    warning;  };  category queries {    general_dns;  };};include &quot;/etc/bind/view/*.conf&quot;;   #加载Bind视图文件</code></pre><p>创建相关目录并授权</p><pre><code>mkdir -p /etc/bind/zonemkdir -p /etc/bind/varmkdir -p /etc/bind/statsmkdir -p /etc/bind/viewmkdir -p /var/log/namedwget https://www.internic.net/domain/named.rootchown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>配置Bind视图</p><pre><code>vim /etc/bind/view/view.conf</code></pre><pre><code>view &quot;View&quot; {                  //配置bind视图功能  zone &quot;test.org&quot; {        type    master;             file    &quot;test.org.zone&quot;;    //定义zone区域文件        allow-transfer {            //允许本区域传输给特定的从DNS服务器                10.0.10.102;      //slave IP,可以存在多个slave        };        notify  yes;          also-notify {               10.0.10.102;        };  };  zone &quot;10.0.10.in-addr.arpa&quot; {     //定义反向zone区域文件        type    master;        file    &quot;10.0.10.zone&quot;;             allow-transfer {               //允许本区域传输给特定的从DNS服务器                10.0.10.102;         //slave IP,可以存在多个slave                       };        notify  yes;        also-notify {                10.0.10.102;        };   };   zone &quot;.&quot; in {         type hint;         file &quot;/etc/bind/named.root&quot;   }};注：参数释义(1)区域类型有type：｛hint（根）| master（主dns）| slave（辅助DNS）| forward（转发）｝(2)notify如果是yes（默认），当一个授权的服务器修改了一个域后，DNS NOTIFY信息被发送给列在also-notify选项中的服务器。</code></pre><p>正向区域和反向区域文件配置-略</p><pre><code>需要在zone子目录定义，因为配置文件zone目录是这么写的zone配置文件语法检查named-checkzone test.org /etc/bind/zone/test.org.zone </code></pre><p>最后再次修改目录权限</p><pre><code>chown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>启动服务</p><pre><code>named.conf配置文件检查named-checkconf /etc/bind/named.conf</code></pre><p>named启动脚本[建议使用supervisor]</p><pre><code>/etc/init.d/named</code></pre><pre><code>#!/bin/bash # named a network name service. # chkconfig: 345 35 75 # description: a name serverif [ `id -u` -ne 0 ];then   echo &quot;ERROR:For bind to port 53,must run as root.&quot;    exit 1ficase &quot;$1&quot; instart)        if [ -x /usr/sbin/named ]; then  /usr/sbin/named -c /etc/bind/named.conf -u named &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server started&#39;         fi      ;;stop)       kill `cat /etc/named/var/named.pid` &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server stopped&#39;        ;;restart)       echo .        echo &quot;Restart BIND9.10 server&quot;        $0 stop       sleep 10       $0 start       ;;reload)      /usr/sbin/rndc reload      ;;status)     /usr/sbin/rndc status     ;;*)     echo &quot;$0 start | stop | restart |reload |status&quot;      ;;esac</code></pre><pre><code>chmod  755  /etc/init.d/namedchkconfig --add namedchkconfig named on/etc/init.d/named start /etc/init.d/named status</code></pre><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><pre><code>[root@ns1 ~]# netstat -lntup|grep 53tcp    0     0 10.0.10.101:53          0.0.0.0:*       LISTEN      2361/named          tcp    0     0 127.0.0.1:53            0.0.0.0:*       LISTEN      2361/named          tcp    0     0 127.0.0.1:953           0.0.0.0:*       LISTEN      2361/named          tcp6   0     0 :::53                   :::*            LISTEN      2361/named          udp    0     0 10.0.10.101:53          0.0.0.0:*      2361/named          udp    0     0 127.0.0.1:53            0.0.0.0:*      2361/named          udp6   0     0 :::53                   :::*           2361/named</code></pre><h4 id="日常管理"><a href="#日常管理" class="headerlink" title="日常管理"></a>日常管理</h4><pre><code>/etc/init.d/named start 启动服务rndc status  查看服务运行情况rndc reload  重新加载区域文件rndc stop    停止DNS服务</code></pre><h2 id="部署bind从DNS"><a href="#部署bind从DNS" class="headerlink" title="部署bind从DNS"></a>部署bind从DNS</h2><p>编译安装</p><pre><code>略</code></pre><p>主配置文件/etc/bind/named.conf</p><pre><code>options {   listen-on port 53 { any; };      //定义DNS监听在哪个端口上   directory &quot;/etc/bind/zone&quot;;   //指定DNS区域文件存放目录   pid-file &quot;/etc/bind/var/named.pid&quot;;   //指定named进程pid文件路径   allow-query { any; };          //允许哪些主机可以使用该DNS来解析   Dump-file &quot;/etc/bind/var/binddump.db&quot;;     //缓存转储位置   Statistics-file &quot;/etc/bind/stats/named_stats&quot;;   //记录统计信息的文件   zone-statistics yes;  //收集在服务器所有域的统计数据, 这些统计数据可以通过使用rndc stats来访问   memstatistics-file &quot;/etc/bind/stats/mem_stats&quot;;     //记录内存使用的统计信息   empty-zones-enable yes;      forwarders {114.114.114.114;8.8.8.8;};   //定义上游DNS[需要配置root hint顶级域]};key &quot;rndc-key&quot; {               //注：这个key部分是通过rndc-confgen命令生成的配置，贴过来        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};controls {              //配置rndc权限与端口       inet 127.0.0.1 port 953       allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };};logging {  channel warning {        //warnning可以改为default_debug（默认）。     file &quot;/var/log/named/named.log&quot; versions 10 size 10m;    //日志文件路径/版本/大小     severity warning;     //如果warnning改为default_debug后，此处可以改为severity dynamic     print-category yes;   //日志中是否需要写入日志类别     print-severity yes;   //日志中是否需要写入消息级别     print-time yes;       //日志中是否需要写入时间    };     channel general_dns {               //绑定其他log channel通道，以下保持默认即可。     file &quot;/var/log/named/named2.log&quot; versions 10 size 100m;     severity info;         print-category yes;      print-severity yes;     print-time yes;    };  category default {    warning;  };  category queries {    general_dns;  };};include &quot;/etc/bind/view/*.conf&quot;;   #加载Bind视图文件</code></pre><p>编辑/etc/bind/rndc.key</p><pre><code>key &quot;rndc-key&quot; {               //与主DNS保持一致        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};</code></pre><p>编辑/etc/bind/rndc.conf</p><pre><code>key &quot;rndc-key&quot; {               //与主DNS保持一致        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};options {        default-key &quot;rndc-key&quot;;        default-server 127.0.0.1;        default-port 953;};</code></pre><p>创建相关目录并授权</p><pre><code>mkdir -p /etc/bind/zonemkdir -p /etc/bind/varmkdir -p /etc/bind/statsmkdir -p /etc/bind/viewmkdir -p /var/log/namedwget https://www.internic.net/domain/named.rootchown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>配置Bind视图</p><pre><code>vim /etc/bind/view/view.conf</code></pre><pre><code>view &quot;View&quot; {                  //配置bind视图功能  zone &quot;test.org&quot; {        type    slave;          //正向区域文件配置为slave模式        masters { 10.0.10.101; };  //此处要指定masterIP，可以添加多个        file    &quot;slave.test.org.zone&quot;;  //不需要对其创建，服务启动后，会自动同步过来  };  zone &quot;10.0.10.in-addr.arpa&quot; {             type    slave;                 //反向区域文件配置为slave模式        masters { 10.0.10.101; };    //此处要指定masterIP，可以添加多个        file    &quot;slave.10.0.10.zone&quot;;     //不需要对其创建，服务启动后，会自动同步过来   };   zone &quot;.&quot; in {         type hint;         file &quot;/etc/bind/named.root&quot;;   }};注：参数释义(1)区域类型有type：｛hint（根）| master（主dns）| slave（辅助DNS）| forward（转发）｝(2)file 可以指定一个文件路径</code></pre><p>最后再次修改目录权限</p><pre><code>chown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>启动服务</p><pre><code>named.conf配置文件检查named-checkconf /etc/bind/named.conf</code></pre><p>named启动脚本[建议使用supervisor]</p><pre><code>/etc/init.d/named</code></pre><pre><code>#!/bin/bash # named a network name service. # chkconfig: 345 35 75 # description: a name serverif [ `id -u` -ne 0 ];then   echo &quot;ERROR:For bind to port 53,must run as root.&quot;    exit 1ficase &quot;$1&quot; instart)        if [ -x /usr/sbin/named ]; then  /usr/sbin/named -c /etc/bind/named.conf -u named &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server started&#39;         fi      ;;stop)       kill `cat /etc/named/var/named.pid` &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server stopped&#39;        ;;restart)       echo .        echo &quot;Restart BIND9.10 server&quot;        $0 stop       sleep 10       $0 start       ;;reload)      /usr/sbin/rndc reload      ;;status)     /usr/sbin/rndc status     ;;*)     echo &quot;$0 start | stop | restart |reload |status&quot;      ;;esac</code></pre><pre><code>chmod  755  /etc/init.d/namedchkconfig --add namedchkconfig named on/etc/init.d/named start /etc/init.d/named status</code></pre><h4 id="进程查看-1"><a href="#进程查看-1" class="headerlink" title="进程查看"></a>进程查看</h4><pre><code>[root@ns2 ~]# netstat -lntup|grep 53</code></pre><h4 id="日常管理-1"><a href="#日常管理-1" class="headerlink" title="日常管理"></a>日常管理</h4><pre><code>/etc/init.d/named start 启动服务rndc status  查看服务运行情况rndc reload  重新加载区域文件rndc stop    停止DNS服务</code></pre><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><pre><code>dig 分别测试主从DNS解析是否正常。接下来就可以进行压力测试了，工具很多，不进行列举</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>正向区域zone-格式参考</p><pre><code>$ORIGIN test.org.     ; //设置默认域$TTL 38404         ; default time to live@   IN   SOA     web.moxiu. admin.moxiu. (    20180814        10800        3600        604800        38400 )        NS      10.0.10.101.      ; 主DNS IP或域名        IN      NS      ns1.moxiu.        IN      NS      ns2.moxiu.ns1     IN      A       10.0.10.101ns2     IN      A       10.0.10.102cname   IN      CNAME   www.baidu.com.cwl     IN      A       1.1.1.1cwl2    IN      A       7.7.7.7</code></pre><pre><code>其中:  $ORIGIN test.org.     ; //设置默认域这样的话，域名解析的时候需要：dig  cw1.test.org ; 当然默认域，也可以设置为&quot;teet.&quot;, 解析的时候这样：dig  cw1.teet.  也就是说解析二级域是由自己在这里控制的【顶级域是.】</code></pre><h2 id="关于优化"><a href="#关于优化" class="headerlink" title="关于优化"></a>关于优化</h2><pre><code>此配置文件能满足基本需求，如果需要将Bind效率提升，需要对参数进行优化。不在本篇讨论范围，Google解决。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;之前没有独立写过Bind主从同步，只有与LVS相结合的文章，故今天给补充完善。
本次测试版本：bind-9.10.8-P1.tar.gz     
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="bind" scheme="https://wuyanteng.github.io/tags/bind/"/>
    
      <category term="bind9" scheme="https://wuyanteng.github.io/tags/bind9/"/>
    
      <category term="bind主从" scheme="https://wuyanteng.github.io/tags/bind%E4%B8%BB%E4%BB%8E/"/>
    
      <category term="DNS" scheme="https://wuyanteng.github.io/tags/DNS/"/>
    
      <category term="迭代DNS" scheme="https://wuyanteng.github.io/tags/%E8%BF%AD%E4%BB%A3DNS/"/>
    
      <category term="root hint" scheme="https://wuyanteng.github.io/tags/root-hint/"/>
    
  </entry>
  
  <entry>
    <title>编写expect交互类脚本</title>
    <link href="https://wuyanteng.github.io/2018/08/09/%E7%BC%96%E5%86%99expect%E4%BA%A4%E4%BA%92%E7%B1%BB%E8%84%9A%E6%9C%AC/"/>
    <id>https://wuyanteng.github.io/2018/08/09/编写expect交互类脚本/</id>
    <published>2018-08-09T08:36:31.000Z</published>
    <updated>2018-08-09T11:35:55.054Z</updated>
    
    <content type="html"><![CDATA[<pre><code>有时候业务中免不了编写交互式输入账号密码的脚本，今天正好有需求，特意记录下</code></pre><h5 id="expect作用介绍"><a href="#expect作用介绍" class="headerlink" title="expect作用介绍"></a>expect作用介绍</h5><pre><code>expect就是用来做交互用的，基本任何交互登录的场合都能使用，不过需要安装expect包</code></pre><a id="more"></a><h5 id="expect包安装"><a href="#expect包安装" class="headerlink" title="expect包安装"></a>expect包安装</h5><pre><code>yum install -y tcl expect expect-devel</code></pre><h5 id="确认expect路径"><a href="#确认expect路径" class="headerlink" title="确认expect路径"></a>确认expect路径</h5><pre><code>[root@localhost]# which expect/usr/bin/expect</code></pre><h5 id="脚本语法-示例"><a href="#脚本语法-示例" class="headerlink" title="脚本语法,示例"></a>脚本语法,示例</h5><pre><code>[root@localhost]# cat test.et#!/usr/bin/expect                      #与bash类似,声明脚本类型set timeout 30                         #设定超时时间为30sspawn ssh garywu@192.168.1.1 -p 7113   #spawn后面接要执行的命令expect &quot;password:&quot;                     #捕捉交互返回的 password：关键字send &quot;garywu123\r&quot;                     #发送一个密码字符串interact                            #表示执行完留在远程控制台；不加这句则执行完后返回本地控制台 </code></pre><h5 id="给脚本增加执行权限"><a href="#给脚本增加执行权限" class="headerlink" title="给脚本增加执行权限"></a>给脚本增加执行权限</h5><pre><code>chmod +x test.et</code></pre><h5 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="!需要注意的点"></a>!需要注意的点</h5><pre><code>不能按照习惯来用sh autosu.sh来这行expect的程序，会提示找不到命令，如下：autosu.sh: line 3: spawn: command not foundcouldn&#39;t read file &quot;password:&quot;: no such file or directoryautosu.sh: line 5: send: command not foundautosu.sh: line 6: interact: command not found因为expect用的不是bash所以会报错。执行的时候直接./autosu.sh就可以了。～切记！</code></pre><h5 id="使用ssh和expect监控RouterOS—生产环境示例："><a href="#使用ssh和expect监控RouterOS—生产环境示例：" class="headerlink" title="使用ssh和expect监控RouterOS—生产环境示例："></a>使用ssh和expect监控RouterOS—生产环境示例：</h5><pre><code>#!/bin/bashHOSTNAME=&quot;192.168.1.1&quot;PORT=&quot;22&quot;USER=&quot;xxx&quot;PASS=&quot;xxxxx&quot;TMP=$(mktemp)#创建expect脚本cat &gt; $TMP &lt;&lt; EOF set timeout -1spawn ssh -p$PORT $USER@$HOSTNAMEmatch_max 100000expect -exact &quot;password:&quot;send -- &quot;$PASS\r&quot;sleep 1expect &quot; &gt; &quot;send -- &quot;/system resource print\r&quot;expect &quot; &gt; &quot;send -- &quot;quit\r&quot;expect eofEOF#运行expect脚本stat_file=/tmp/ros_status.log/usr/bin/expect -f $TMP &gt;$stat_filerm $TMP</code></pre><pre><code>注: 脚本运行完毕，RouterOS运行状态信息会出现在/tmp/ros_status.log中，通过grep或awk取出想要的值，然后自定义zabbix key即可，也可以在zabbix中配置图形展示。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;有时候业务中免不了编写交互式输入账号密码的脚本，今天正好有需求，特意记录下
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;expect作用介绍&quot;&gt;&lt;a href=&quot;#expect作用介绍&quot; class=&quot;headerlink&quot; title=&quot;expect作用介绍&quot;&gt;&lt;/a&gt;expect作用介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;expect就是用来做交互用的，基本任何交互登录的场合都能使用，不过需要安装expect包
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://wuyanteng.github.io/tags/ssh/"/>
    
      <category term="expect" scheme="https://wuyanteng.github.io/tags/expect/"/>
    
      <category term="自动输入密码" scheme="https://wuyanteng.github.io/tags/%E8%87%AA%E5%8A%A8%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/"/>
    
      <category term="交互式" scheme="https://wuyanteng.github.io/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
      <category term="非交互" scheme="https://wuyanteng.github.io/tags/%E9%9D%9E%E4%BA%A4%E4%BA%92/"/>
    
      <category term="使用ssh和expect监控RouterOS" scheme="https://wuyanteng.github.io/tags/%E4%BD%BF%E7%94%A8ssh%E5%92%8Cexpect%E7%9B%91%E6%8E%A7RouterOS/"/>
    
  </entry>
  
  <entry>
    <title>DNS TLS Public</title>
    <link href="https://wuyanteng.github.io/2018/08/06/DNS-TLS-Public/"/>
    <id>https://wuyanteng.github.io/2018/08/06/DNS-TLS-Public/</id>
    <published>2018-08-06T07:57:13.000Z</published>
    <updated>2018-08-06T08:08:45.668Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Public DNS(TLS) </code></pre><h4 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h4><pre><code>1.1.1.1@8531.0.0.1@8532606:4700:4700::1111@8532606:4700:4700::1001@853</code></pre><a id="more"></a><h4 id="Quad9"><a href="#Quad9" class="headerlink" title="Quad9"></a>Quad9</h4><pre><code>9.9.9.9@853149.112.112.112@8532620:fe::fe@8532620:fe::9@853</code></pre><h4 id="CleanBrowsing"><a href="#CleanBrowsing" class="headerlink" title="CleanBrowsing"></a>CleanBrowsing</h4><pre><code>185.228.168.168@853185.228.168.169@8532a0d:2a00:1::@8532a0d:2a00:2::@853</code></pre><h4 id="Taipei"><a href="#Taipei" class="headerlink" title="Taipei"></a>Taipei</h4><pre><code>101.101.101.101@853101.102.103.104@853</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Public DNS(TLS) 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Cloudflare&quot;&gt;&lt;a href=&quot;#Cloudflare&quot; class=&quot;headerlink&quot; title=&quot;Cloudflare&quot;&gt;&lt;/a&gt;Cloudflare&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.1.1.1@853
1.0.0.1@853

2606:4700:4700::1111@853
2606:4700:4700::1001@853
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="DNS TLS" scheme="https://wuyanteng.github.io/tags/DNS-TLS/"/>
    
      <category term="Public DNS" scheme="https://wuyanteng.github.io/tags/Public-DNS/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump数据导入导出-详解</title>
    <link href="https://wuyanteng.github.io/2018/07/25/mysqldump%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wuyanteng.github.io/2018/07/25/mysqldump数据导入导出-详解/</id>
    <published>2018-07-25T09:17:36.000Z</published>
    <updated>2018-07-27T10:04:32.576Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><pre><code>在日常维护工作当中经常会需要对数据进行导出操作，而mysqldump是导出数据过程中使用非常频繁的一个工具；它自带的功能参数非常多，可以轻松完成看似很复杂的需求。</code></pre><p>本文摘选自：<a href="http://www.cnblogs.com/chenmh/p/5300370.html" target="_blank" rel="noopener">Pursuer.chen</a></p><a id="more"></a><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>Usage: mysqldump [OPTIONS] database [tables]OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]OR     mysqldump [OPTIONS] --all-databases [OPTIONS]</code></pre><h4 id="1-导出所有数据库"><a href="#1-导出所有数据库" class="headerlink" title="1.导出所有数据库"></a>1.导出所有数据库</h4><pre><code>mysqldump -uroot -proot --all-databases &gt;/tmp/all.sql</code></pre><h4 id="2-导出db1、db2两个数据库的所有数据"><a href="#2-导出db1、db2两个数据库的所有数据" class="headerlink" title="2.导出db1、db2两个数据库的所有数据"></a>2.导出db1、db2两个数据库的所有数据</h4><pre><code>mysqldump -uroot -proot --databases db1 db2 &gt;/tmp/user.sql</code></pre><h4 id="3-导出db1中的a1、a2表"><a href="#3-导出db1中的a1、a2表" class="headerlink" title="3.导出db1中的a1、a2表"></a>3.导出db1中的a1、a2表</h4><pre><code>mysqldump -uroot -proot db1 table1 table2  &gt;/tmp/db1.sql注意: 导出指定表只能针对一个数据库进行导出;恢复时，需要确保目标库中没有该表数据，否则可能出现主键冲突等。</code></pre><h4 id="4-条件导出"><a href="#4-条件导出" class="headerlink" title="4.条件导出"></a>4.条件导出</h4><pre><code>(1)当字段是整数，使用如下命令：mysqldump -uroot -proot db1 table1 -w &#39;id=1&#39; &gt;/tmp/a1.sql(2)当字段是字符串,使用如下命令：mysqldump -uroot -proot db1 table1 -w &#39;id=&#39;a&#39;&#39;  &gt;/tmp/a1.sql(3)当字段在shell中作为变量调用mysqldump -uroot -proot db1 table1 -w &#39;DATE&gt;=&#39;${days31_ago}&#39;&#39; &gt;/tmp/a1.sql注：如果多个表的条件相同可以一次性导出多个表</code></pre><p>附录：一次查询或删除同一个库的多张表</p><pre><code>mysql -uroot -p  -e &quot;use ${remote_db2}; DELETE FROM ${table2_1} WHERE DATE&gt;=&#39;${days31_ago}&#39;;DELETE FROM ${table2_2} WHERE DATE&gt;=&#39;${days31_ago}&#39;;DELETE FROM ${table2_3} WHERE DATE&gt;=&#39;${days31_ago}&#39;;&quot;</code></pre><h4 id="5-生成新的binlog文件"><a href="#5-生成新的binlog文件" class="headerlink" title="5.生成新的binlog文件"></a>5.生成新的binlog文件</h4><pre><code>有时候会希望导出数据之后生成一个新的binlog文件,只需要加上-F参数即可mysqldump -uroot -proot --databases db1 -F &gt;/tmp/db1.sql</code></pre><h4 id="6-只导出表结构不导出数据，–no-data"><a href="#6-只导出表结构不导出数据，–no-data" class="headerlink" title="6.只导出表结构不导出数据，–no-data"></a>6.只导出表结构不导出数据，–no-data</h4><pre><code>mysqldump -uroot -proot --no-data --databases db1 &gt;/tmp/db1.sql</code></pre><h4 id="7-跨服务器导出导入数据"><a href="#7-跨服务器导出导入数据" class="headerlink" title="7.跨服务器导出导入数据"></a>7.跨服务器导出导入数据</h4><pre><code>mysqldump --host=h1 -uroot -proot --databases db1 |mysql --host=h2 -uroot -proot db2注：将h1服务器中的db1数据库的所有数据导入到h2中的db2数据库中，db2的数据库必须存在否则会报错</code></pre><pre><code>mysqldump --host=h1 -uroot -proot -C --databases db1 |mysql --host=h2 -uroot -proot db2加上-C参数启用压缩传递</code></pre><h4 id="8-将主库的binlog位置和文件名追加到导出数据的文件中-–dump-slave"><a href="#8-将主库的binlog位置和文件名追加到导出数据的文件中-–dump-slave" class="headerlink" title="8.将主库的binlog位置和文件名追加到导出数据的文件中,–dump-slave"></a>8.将主库的binlog位置和文件名追加到导出数据的文件中,–dump-slave</h4><pre><code>注意：如果当前服务器是slave服务器那么使用该命令会执行stop slave来获取master binlog的文件和位置，等备份完后会自动执行start slave启动该slave服务器。但是如果是大的数据量备份会给slave和master的延时变的更大，使用--dump-slave获取到的只是当前的从服务器的数据执行到的主的binglog的位置是（relay_mater_log_file,exec_master_log_pos),而不是主服务器当前的binlog执行的位置，主要是取决于主从的数据延时。</code></pre><pre><code>当该参数在slave服务器上执行时，相当于执行show slave status。当设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。mysqldump -uroot -proot --dump-slave=1 --databases db1 &gt;/tmp/db1.sqlmysqldump -uroot -proot --dump-slave=2 --database db1 &gt;/tmp/db1.sql</code></pre><h4 id="9-将当前服务器的binlog的位置和文件名追加输出到文件，–master-data"><a href="#9-将当前服务器的binlog的位置和文件名追加输出到文件，–master-data" class="headerlink" title="9.将当前服务器的binlog的位置和文件名追加输出到文件，–master-data"></a>9.将当前服务器的binlog的位置和文件名追加输出到文件，–master-data</h4><pre><code>该参数和--dump-slave方法一样，只是它是记录的是当前服务器的binlog，相当于执行show master status，状态（file,position)的值。注意：--master-data不会停止当前服务器的主从服务</code></pre><h4 id="10-–opt和–skip-opt"><a href="#10-–opt和–skip-opt" class="headerlink" title="10.–opt和–skip-opt"></a>10.–opt和–skip-opt</h4><pre><code>等同于--add-drop-table, --add-locks, --create-options, --quick, --extended-insert, --lock-tables, --set-charset, --disable-keys 该选项默认开启, 可以用--skip-opt禁用，来避免锁表。#避免备份过程中锁表mysqldump -uroot -p --host=h1 --all-databases --skip-opt</code></pre><h4 id="11-保证导出的一致性状态-–single-transaction"><a href="#11-保证导出的一致性状态-–single-transaction" class="headerlink" title="11.保证导出的一致性状态, –single-transaction"></a>11.保证导出的一致性状态, –single-transaction</h4><pre><code>该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎（它不显示加锁通过判断版本来对比数据），仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。</code></pre><pre><code>--quick, -q不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。</code></pre><h4 id="12-开始导出前，锁定所有表-–lock-tables-l"><a href="#12-开始导出前，锁定所有表-–lock-tables-l" class="headerlink" title="12.开始导出前，锁定所有表, –lock-tables,-l"></a>12.开始导出前，锁定所有表, –lock-tables,-l</h4><pre><code>用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。</code></pre><h4 id="13-导出存储过程和自定义函数-–routines-R"><a href="#13-导出存储过程和自定义函数-–routines-R" class="headerlink" title="13.导出存储过程和自定义函数, –routines, -R"></a>13.导出存储过程和自定义函数, –routines, -R</h4><pre><code>mysqldump  -uroot -p --host=localhost --all-databases --routines</code></pre><h4 id="14-压缩备份-还原"><a href="#14-压缩备份-还原" class="headerlink" title="14.压缩备份+还原"></a>14.压缩备份+还原</h4><pre><code>压缩备份mysqldump -uroot -p -P3306 -q -Q --default-character-set=utf8 --hex-blob --skip-lock-tables --databases abc 2&gt;/abc.err |gzip &gt;/abc.sql.gz注：-q或--quick :不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。-Q或--quote-names: 使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。--default-character-set: 设置默认字符集,默认为utf-8--hex-blob:使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。</code></pre><pre><code>还原gunzip -c abc.sql.gz |mysql -uroot -p -vvv -P3306 --default-character-set=utf8 abc 1&gt; abc.log 2&gt;abc.err</code></pre><h2 id="附录：参数说明："><a href="#附录：参数说明：" class="headerlink" title="附录：参数说明："></a>附录：参数说明：</h2><pre><code>--all-databases  , -A: 导出全部数据库。mysqldump  -uroot -p --all-databases--all-tablespaces  , -Y: 导出全部表空间。mysqldump  -uroot -p --all-databases --all-tablespaces--no-tablespaces  , -y: 不导出任何表空间信息。mysqldump  -uroot -p --all-databases --no-tablespaces--add-drop-database: 每个数据库创建之前添加drop数据库语句。mysqldump  -uroot -p --all-databases --add-drop-database --add-drop-table每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用--skip-add-drop-table取消选项)mysqldump  -uroot -p --all-databases  (默认添加drop语句)mysqldump  -uroot -p --all-databases –skip-add-drop-table  (取消drop语句)--add-locks: 在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用--skip-add-locks取消选项)mysqldump  -uroot -p --all-databases  (默认添加LOCK语句)mysqldump  -uroot -p --all-databases –skip-add-locks   (取消LOCK语句)--allow-keywords: 允许创建是关键词的列名字。这由表名前缀于每个列名做到。mysqldump  -uroot -p --all-databases --allow-keywords--apply-slave-statements: 在&#39;CHANGE MASTER&#39;前添加&#39;STOP SLAVE&#39;，并且在导出的最后添加&#39;START SLAVE&#39;。mysqldump  -uroot -p --all-databases --apply-slave-statements--character-sets-dir:字符集文件的目录mysqldump  -uroot -p --all-databases  --character-sets-dir=/usr/local/mysql/share/mysql/charsets--comments: 附加注释信息。默认为打开，可以用--skip-comments取消mysqldump  -uroot -p --all-databases  (默认记录注释)mysqldump  -uroot -p --all-databases --skip-comments   (取消注释)--compatible: 导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。mysqldump  -uroot -p --all-databases --compatible=ansi--compact: 导出更少的输出信息(用于调试)。去掉注释和头尾等结构。mysqldump  -uroot -p --all-databases --compact--complete-insert,  -c使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。mysqldump  -uroot -p --all-databases --complete-insert--compress, -C :在客户端和服务器之间启用压缩传递所有信息mysqldump  -uroot -p --all-databases --compress--create-options,-a :在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)mysqldump  -uroot -p --all-databases--databases,-B:导出几个数据库。参数后面所有名字参量都被看作数据库名。mysqldump  -uroot -p --databases test mysql--debug: 输出debug信息，用于调试。默认值为：d:t,/tmp/mysqldump.tracemysqldump  -uroot -p --all-databases --debugmysqldump  -uroot -p --all-databases --debug=” d:t,/tmp/debug.trace”--debug-check: 检查内存和打开文件使用说明并退出。mysqldump  -uroot -p --all-databases --debug-check--debug-info: 输出调试信息并退出mysqldump  -uroot -p --all-databases --debug-info--default-character-set: 设置默认字符集，默认值为utf8mysqldump  -uroot -p --all-databases --default-character-set=utf8--delayed-insert: 采用延时插入方式（INSERT DELAYED）导出数据mysqldump  -uroot -p --all-databases --delayed-insert--delete-master-logs: master备份后删除日志. 这个参数将自动激活--master-data。mysqldump  -uroot -p --all-databases --delete-master-logs--disable-keys对于每个表，用/*!40000 ALTER TABLE tbl_name DISABLE KEYS */;和/*!40000 ALTER TABLE tbl_name ENABLE KEYS */;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。mysqldump  -uroot -p --all-databases --dump-slave该选项将主的binlog位置和文件名追加到导出数据的文件中(show slave status)。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。该选项将会打开--lock-all-tables，除非--single-transaction被指定。该选项会自动关闭--lock-tables选项。默认值为0。mysqldump  -uroot -p --all-databases --dump-slave=1mysqldump  -uroot -p --all-databases --dump-slave=2--master-data该选项将当前服务器的binlog的位置和文件名追加到输出文件中(show master status)。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开--lock-all-tables 选项，除非--single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的--single-transaction选项）。该选项自动关闭--lock-tables选项。mysqldump  -uroot -p --host=localhost --all-databases --master-data=1;mysqldump  -uroot -p --host=localhost --all-databases --master-data=2;--events, -E : 导出事件。mysqldump  -uroot -p --all-databases --events--extended-insert,  -e使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用--skip-extended-insert取消选项。mysqldump  -uroot -p --all-databasesmysqldump  -uroot -p --all-databases--skip-extended-insert   (取消选项)--fields-terminated-by导出文件中忽略给定字段。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-terminated-by=”#”--fields-enclosed-by输出文件中的各个字段用给定字符包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=”#”--fields-optionally-enclosed-by输出文件中的各个字段用给定字符选择性包裹。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p test test --tab=”/home/mysql”  --fields-enclosed-by=”#” --fields-optionally-enclosed-by=”#”--fields-escaped-by输出文件中的各个字段忽略给定字符。与--tab选项一起使用，不能用于--databases和--all-databases选项mysqldump  -uroot -p mysql user --tab=”/home/mysql” --fields-escaped-by=”#”--flush-logs : 开始导出之前刷新日志。请注意：假如一次导出多个数据库(使用选项--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--lock-all-tables或者--master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用--lock-all-tables 或者--master-data 和--flush-logs。mysqldump  -uroot -p --all-databases --flush-logs--flush-privileges在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。mysqldump  -uroot -p --all-databases --flush-privileges--force: 在导出过程中忽略出现的SQL错误。mysqldump  -uroot -p --all-databases --force--help: 显示帮助信息并退出。mysqldump  --help--hex-blob使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。mysqldump  -uroot -p --all-databases --hex-blob--host, -h : 需要导出的主机信息mysqldump  -uroot -p --host=localhost --all-databases--ignore-table不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：--ignore-table=database.table1 --ignore-table=database.table2 ……mysqldump  -uroot -p --host=localhost --all-databases --ignore-table=mysql.user--include-master-host-port在--dump-slave产生的&#39;CHANGE  MASTER TO..&#39;语句中增加&#39;MASTER_HOST=&lt;host&gt;，MASTER_PORT=&lt;port&gt;&#39;  mysqldump  -uroot -p --host=localhost --all-databases --include-master-host-port--insert-ignore: 在插入行时使用INSERT IGNORE语句.mysqldump  -uroot -p --host=localhost --all-databases --insert-ignore--lines-terminated-by输出文件的每行用给定字符串划分。与--tab选项一起使用，不能用于--databases和--all-databases选项。mysqldump  -uroot -p --host=localhost test test --tab=”/tmp/mysql”  --lines-terminated-by=”##”--lock-all-tables,  -x提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭--single-transaction 和--lock-tables 选项。mysqldump  -uroot -p --host=localhost --all-databases --lock-all-tables--lock-tables,  -l开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。mysqldump  -uroot -p --host=localhost --all-databases --lock-tables--log-error: 附加警告和错误信息到给定文件mysqldump  -uroot -p --host=localhost --all-databases  --log-error=/tmp/mysqldump_error_log.err--max_allowed_packet: 服务器发送和接受的最大包长度。mysqldump  -uroot -p --host=localhost --all-databases --max_allowed_packet=10240--net_buffer_length : TCP/IP和socket连接的缓存大小。mysqldump  -uroot -p --host=localhost --all-databases --net_buffer_length=1024--no-autocommit: 使用autocommit/commit 语句包裹表。mysqldump  -uroot -p --host=localhost --all-databases --no-autocommit--no-create-db,  -n: 只导出数据，而不添加CREATE DATABASE 语句。mysqldump  -uroot -p --host=localhost --all-databases --no-create-db--no-create-info,-t :只导出数据，而不添加CREATE TABLE 语句。mysqldump  -uroot -p --host=localhost --all-databases --no-create-info--no-data, -d : 不导出任何数据，只导出数据库表结构。mysqldump  -uroot -p --host=localhost --all-databases --no-data--no-set-names,-N :等同于--skip-set-charsetmysqldump  -uroot -p --host=localhost --all-databases --no-set-names--opt等同于--add-drop-table,  --add-locks, --create-options, --quick, --extended-insert, --lock-tables,  --set-charset, --disable-keys 该选项默认开启,  可以用--skip-opt禁用.mysqldump  -uroot -p --host=localhost --all-databases --opt--order-by-primary如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。 mysqldump  -uroot -p --host=localhost --all-databases --order-by-primary--password, -p :连接数据库密码--port, -P :连接数据库端口号--protocol :使用的连接协议，包括：tcp, socket, pipe, memory.mysqldump  -uroot -p --host=localhost --all-databases --protocol=tcp--quick, -q :不缓冲查询，直接导出到标准输出。默认为打开状态，使用--skip-quick取消该选项。mysqldump  -uroot -p --host=localhost --all-databases mysqldump  -uroot -p --host=localhost --all-databases --skip-quick--quote-names,-Q :使用（`）引起表和列名。默认为打开状态，使用--skip-quote-names取消该选项。mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-quote-names--replace :使用REPLACE INTO 取代INSERT INTO.mysqldump  -uroot -p --host=localhost --all-databases --replace--result-file,  -r直接输出到指定文件中。该选项应该用在使用回车换行对（\\r\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。mysqldump  -uroot -p --host=localhost --all-databases --result-file=/tmp/mysqldump_result_file.txt--routines, -R :导出存储过程以及自定义函数。mysqldump  -uroot -p --host=localhost --all-databases --routines--set-charset添加&#39;SET NAMES  default_character_set&#39;到输出文件。默认为打开状态，使用--skip-set-charset关闭选项。mysqldump  -uroot -p --host=localhost --all-databases mysqldump  -uroot -p --host=localhost --all-databases --skip-set-charset--single-transaction该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和--lock-tables 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--quick 选项。mysqldump  -uroot -p --host=localhost --all-databases --single-transaction--dump-date :将导出时间添加到输出文件中。默认为打开状态，使用--skip-dump-date关闭选项。mysqldump  -uroot -p --host=localhost --all-databasesmysqldump  -uroot -p --host=localhost --all-databases --skip-dump-date--skip-opt: 禁用–opt选项.mysqldump  -uroot -p --host=localhost --all-databases --skip-opt--socket,-S指定连接mysql的socket文件位置，默认路径/tmp/mysql.sockmysqldump  -uroot -p --host=localhost --all-databases --socket=/tmp/mysqld.sock--tab,-T为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。注意使用--tab不能指定--databases参数mysqldump  -uroot -p --host=localhost test test --tab=&quot;/home/mysql&quot;--tables覆盖--databases (-B)参数，指定需要导出的表名，在后面的版本会使用table取代tables。mysqldump  -uroot -p --host=localhost --databases test --tables test--triggers: 导出触发器。该选项默认启用，用--skip-triggers禁用它。mysqldump  -uroot -p --host=localhost --all-databases --triggers--tz-utc在导出顶部设置时区TIME_ZONE=&#39;+00:00&#39; ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。mysqldump  -uroot -p --host=localhost --all-databases --tz-utc--user, -u :指定连接的用户名。--verbose, --v :输出多种平台信息。--version, -V  :输出mysqldump版本信息并退出--where, -w只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。mysqldump  -uroot -p --host=localhost --all-databases --where=” user=’root’”--xml, -X :导出XML格式.mysqldump  -uroot -p --host=localhost --all-databases --xml--plugin_dir :客户端插件的目录，用于兼容不同的插件版本。mysqldump  -uroot -p --host=localhost --all-databases --plugin_dir=”/usr/local/lib/plugin”--default_auth :客户端插件默认使用权限。mysqldump  -uroot -p --host=localhost --all-databases --default-auth=”/usr/local/lib/plugin/&lt;PLUGIN&gt;”</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在日常维护工作当中经常会需要对数据进行导出操作，而mysqldump是导出数据过程中使用非常频繁的一个工具；它自带的功能参数非常多，可以轻松完成看似很复杂的需求。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文摘选自：&lt;a href=&quot;http://www.cnblogs.com/chenmh/p/5300370.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pursuer.chen&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mysql" scheme="https://wuyanteng.github.io/tags/mysql/"/>
    
      <category term="mysqldump详解" scheme="https://wuyanteng.github.io/tags/mysqldump%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="mysql导入导出" scheme="https://wuyanteng.github.io/tags/mysql%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>mysql用户远程登录失败--Host is not allowed to connect to this MySQL server</title>
    <link href="https://wuyanteng.github.io/2018/07/25/mysql%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/"/>
    <id>https://wuyanteng.github.io/2018/07/25/mysql用户远程登录失败/</id>
    <published>2018-07-25T02:13:55.000Z</published>
    <updated>2018-07-25T02:31:00.541Z</updated>
    
    <content type="html"><![CDATA[<h4 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h4><pre><code>mysql远程登录失败，错误如下：Host &#39;X.X.X.X&#39; is not allowed to connect to this MySQL server.</code></pre><a id="more"></a><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><pre><code>当前使用的用户不允许从远程登录</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>方案1：更改用户表</p><pre><code>mysql &gt; use mysql;mysql &gt; update user set host = &#39;%&#39; where user = &#39;usr_name&#39;;;其中， usr_name 用户名； 而 &#39;%&#39; 为通配符，表示匹配所有主机。</code></pre><p>方案2：命令行授权</p><pre><code>mysql &gt; grant all privileges on db_name.* to usr_name@&#39;%&#39; identified by &#39;user_password&#39;;mysql &gt; flush privileges ;其中，db_name 是数据库名， usr_name 用户名， pwd 密码。&#39;%&#39; 为通配符。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;故障描述&quot;&gt;&lt;a href=&quot;#故障描述&quot; class=&quot;headerlink&quot; title=&quot;故障描述&quot;&gt;&lt;/a&gt;故障描述&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;mysql远程登录失败，错误如下：
Host &amp;#39;X.X.X.X&amp;#39; is not allowed to connect to this MySQL server.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mysql" scheme="https://wuyanteng.github.io/tags/mysql/"/>
    
      <category term="root远程登录" scheme="https://wuyanteng.github.io/tags/root%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>vim打开文件中文乱码问题</title>
    <link href="https://wuyanteng.github.io/2018/07/12/vim%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://wuyanteng.github.io/2018/07/12/vim打开文件中文乱码问题/</id>
    <published>2018-07-12T04:16:26.000Z</published>
    <updated>2018-07-12T06:24:36.119Z</updated>
    
    <content type="html"><![CDATA[<pre><code>vim ~/.vimrc</code></pre><pre><code>set encoding=utf-8set fenc=utf-8set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gbk2312,cp936</code></pre><pre><code>现在试试中文乱码就消失了</code></pre><p>GitHub参考：<a href="https://gist.github.com/jhezjkp/3405319" target="_blank" rel="noopener">.vimrc配置</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;vim ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;set encoding=utf-8
set fenc=utf-8
set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gbk2312,cp936
&lt;
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="vim" scheme="https://wuyanteng.github.io/tags/vim/"/>
    
      <category term="中文乱码" scheme="https://wuyanteng.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6部署bugzilla</title>
    <link href="https://wuyanteng.github.io/2018/07/11/CentOS6%E9%83%A8%E7%BD%B2bugzilla/"/>
    <id>https://wuyanteng.github.io/2018/07/11/CentOS6部署bugzilla/</id>
    <published>2018-07-11T06:17:03.000Z</published>
    <updated>2018-07-11T10:32:20.679Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Bugzilla介绍"><a href="#Bugzilla介绍" class="headerlink" title="Bugzilla介绍"></a>Bugzilla介绍</h5><pre><code>Bugzilla 是一个开源的缺陷跟踪系统（Bug-Tracking System），它可以管理软件开发中缺陷的提交（new），修复（resolve），关闭（close）等整个生命周期。它可以使我们更好的在软件开发过程中跟踪软件错误的处理过程，为开发和测试工作以及产品质量的度量提供数据支持。并能够为你建立一个完善的 Bug 跟踪体系, 包括报告Bug、查询Bug记录并产生报表。</code></pre><a id="more"></a><h4 id="部署Bugzilla"><a href="#部署Bugzilla" class="headerlink" title="部署Bugzilla"></a>部署Bugzilla</h4><pre><code>系统环境：CentOS6.9由于需要使用其提供的自动化脚本安装很多依赖库，故不建议使用小众Linux</code></pre><h5 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h5><pre><code>关闭防火墙service iptables stop关闭selinuxsetenforce 0</code></pre><h5 id="安装Apache-MySQL及相关依赖"><a href="#安装Apache-MySQL及相关依赖" class="headerlink" title="安装Apache|MySQL及相关依赖"></a>安装Apache|MySQL及相关依赖</h5><pre><code>yum -y install httpd mod_ssl mysql-server mysql php-mysql gcc perl* mod_perl-develservice httpd startchkconfig httpd onservice mysqld startservice mysqld on</code></pre><h5 id="设置mysql-root密码"><a href="#设置mysql-root密码" class="headerlink" title="设置mysql root密码"></a>设置mysql root密码</h5><pre><code>mysql密码默认为空，需修改如下：mysqladmin -uroot -p password &quot;123456&quot;登陆测试mysql -uroot -p123456创建数据库名为bugscreate database bugs;grant all on bugs.* to root@localhost identified by &quot;123456&quot;;flush privileges; </code></pre><h5 id="下载安装bugzilla"><a href="#下载安装bugzilla" class="headerlink" title="下载安装bugzilla"></a>下载安装bugzilla</h5><pre><code>官网:https://www.bugzilla.org/download/或https://archive.mozilla.org/pub/webtools/</code></pre><pre><code>以bugzilla-5.0.3.tar.gz为例：解压tar xf bugzilla-5.0.3.tar.gz -C /var/www/html/重命名源码目录cd /var/www/htmlmv bugzilla-5.0.3 bugzilla检查缺少的组件cd /var/www/html/bugzilla./checksetup.pl --check-modules自动化安装缺少的组件perl install-module.pl --all运行以下这条命令，它会在/var/www/html/bugzilla路径下自动生成一个名为localconfig的文件。./checksetup.pl主要修改以下数据库相关信息vim localconfig$db_driver = &#39;mysql&#39;;$db_host = &#39;localhost&#39;;$db_name = &#39;bugs&#39;;$db_user = &#39;root&#39;;$db_pass = &#39;123456&#39;;$db_port = 3306;最后，再次执行以下命令根据提示输入管理员邮箱及密码./checksetup.pl </code></pre><h5 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h5><pre><code>vi /etc/httpd/conf/httpd.conf   在配置文件底部添加如下内容：&lt;VirtualHost *:80&gt;     DocumentRoot /var/www/html/bugzilla/&lt;/VirtualHost&gt;&lt;Directory /var/www/html/bugzilla&gt;     AddHandler cgi-script .cgi     Options +Indexes +ExecCGI     DirectoryIndex index.cgi     AllowOverride Limit FileInfo Indexes&lt;/Directory&gt;</code></pre><pre><code>接着需要编辑.htacess文件，注释掉以下内容,保存：vim /var/www/html/bugzilla/.htaccess#Options -Indexes</code></pre><pre><code>重启Apache服务，浏览器测试访问service httpd restart浏览器： http://server-ip</code></pre><p><img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/bugzilla.jpg" alt="bugzilla"></p><h4 id="关于Bugzilla源码和数据库迁移"><a href="#关于Bugzilla源码和数据库迁移" class="headerlink" title="关于Bugzilla源码和数据库迁移"></a>关于Bugzilla源码和数据库迁移</h4><pre><code>注意事项：1. 首先在新机器上按照如上步骤完整部署一套，目的是安装完所有依赖。2. 将原数据库中的bugs通过mysqldump导出一份sql文件3. 将原bugs.sql导入到新库名为bugzilla数据库中，并修改新部署的一套源码中localconfig文件，修改数据库设置，重启apache服务，如果能正常使用，则迁移完毕。4. 若无法登陆，可能之前版本嵌入了LDAP账号，此时就需要把原bugzilla代码目录整个压缩拷贝过来，并修改localconfig文件为最新mysql数据库信息，重启mysql，访问并测试。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Bugzilla介绍&quot;&gt;&lt;a href=&quot;#Bugzilla介绍&quot; class=&quot;headerlink&quot; title=&quot;Bugzilla介绍&quot;&gt;&lt;/a&gt;Bugzilla介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Bugzilla 是一个开源的缺陷跟踪系统（Bug-Tracking System），它可以管理软件开发中缺陷的提交（new），修复（resolve），关闭（close）等整个生命周期。

它可以使我们更好的在软件开发过程中跟踪软件错误的处理过程，为开发和测试工作以及产品质量的度量提供数据支持。并能够为你建立一个完善的 Bug 跟踪体系, 包括报告Bug、查询Bug记录并产生报表。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="bugzilla" scheme="https://wuyanteng.github.io/tags/bugzilla/"/>
    
      <category term="bugs" scheme="https://wuyanteng.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>Mongo Slave节点无法show dbs</title>
    <link href="https://wuyanteng.github.io/2018/07/09/Mongo-Slave%E8%8A%82%E7%82%B9%E6%97%A0%E6%B3%95show-dbs/"/>
    <id>https://wuyanteng.github.io/2018/07/09/Mongo-Slave节点无法show-dbs/</id>
    <published>2018-07-09T08:00:54.000Z</published>
    <updated>2018-07-09T08:08:30.880Z</updated>
    
    <content type="html"><![CDATA[<p>在SECONDARY节点无法show dbs</p><pre><code>主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:QUERY  Error: listDatabases failed:{ &quot;note&quot; : &quot;from execCommand&quot;, &quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;not master&quot; }</code></pre><a id="more"></a><p>解决方法</p><pre><code>在报错的slave机器上执行 rs.slaveOk()  再执行show dbs即可</code></pre><p>官网解释</p><pre><code>Provides a shorthand for the following operation:db.getMongo().setSlaveOk()This allows the current connection to allow read operations to run on secondary members. See the readPref() method for more fine-grained control over read preference in the mongo shell.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SECONDARY节点无法show dbs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;主从启动之后，连接slave可以成功连上，但是在slave中执行 show dbs 的时候就报错了:

QUERY  Error: listDatabases failed:{ &amp;quot;note&amp;quot; : &amp;quot;from execCommand&amp;quot;, &amp;quot;ok&amp;quot; : 0, &amp;quot;errmsg&amp;quot; : &amp;quot;not master&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="SECONDARY" scheme="https://wuyanteng.github.io/tags/SECONDARY/"/>
    
      <category term="PRIMARY" scheme="https://wuyanteng.github.io/tags/PRIMARY/"/>
    
      <category term="MongoDB" scheme="https://wuyanteng.github.io/tags/MongoDB/"/>
    
      <category term="slave" scheme="https://wuyanteng.github.io/tags/slave/"/>
    
      <category term="show dbs" scheme="https://wuyanteng.github.io/tags/show-dbs/"/>
    
  </entry>
  
  <entry>
    <title>mysql从库-只同步某些库</title>
    <link href="https://wuyanteng.github.io/2018/07/06/mysql%E4%BB%8E%E5%BA%93-%E5%8F%AA%E5%90%8C%E6%AD%A5%E6%9F%90%E4%BA%9B%E5%BA%93/"/>
    <id>https://wuyanteng.github.io/2018/07/06/mysql从库-只同步某些库/</id>
    <published>2018-07-06T09:54:12.000Z</published>
    <updated>2018-07-06T10:09:38.923Z</updated>
    
    <content type="html"><![CDATA[<pre><code>生产环境需求：从库同步时，限定只同步某些数据库，而非全部同步，如何优雅逆袭？</code></pre><p>配置</p><pre><code>vim /etc/my.cnf[mysqld]......replicate_wild_do_table=db1.%replicate_wild_do_table=db2.%replicate_wild_do_table=db3.%db1到db3是需要同步的数据库名，如果复制多个数据库，重复设置这个选项即可。</code></pre><pre><code>重启mysql</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;生产环境需求：从库同步时，限定只同步某些数据库，而非全部同步，如何优雅逆袭？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/my.cnf

[mysqld]
......
replicate_wild_do_table
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mysql从库" scheme="https://wuyanteng.github.io/tags/mysql%E4%BB%8E%E5%BA%93/"/>
    
      <category term="同步个别库" scheme="https://wuyanteng.github.io/tags/%E5%90%8C%E6%AD%A5%E4%B8%AA%E5%88%AB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump备份避免锁表</title>
    <link href="https://wuyanteng.github.io/2018/07/02/mysqldump%E5%A4%87%E4%BB%BD%E9%81%BF%E5%85%8D%E9%94%81%E8%A1%A8/"/>
    <id>https://wuyanteng.github.io/2018/07/02/mysqldump备份避免锁表/</id>
    <published>2018-07-02T04:09:26.000Z</published>
    <updated>2018-07-02T04:26:27.768Z</updated>
    
    <content type="html"><![CDATA[<pre><code>生产环境中,场景难免会遇到对正在运行的数据库进行备份，而mysqldump备份会有锁表风险，导致数据在备份期间无法写入数据，所以对正在运行的数据库备份需要慎重。下面就聊聊如何解决锁表？</code></pre><a id="more"></a><h5 id="mysqldump命令备份Mysql数据库的参数说明"><a href="#mysqldump命令备份Mysql数据库的参数说明" class="headerlink" title="mysqldump命令备份Mysql数据库的参数说明"></a>mysqldump命令备份Mysql数据库的参数说明</h5><pre><code>-q       采用快速的dump方式(提高导出性能)-e       采用多重insert语句形式(提高还原性能)-R       导出存储过程，函数，和触发器--events        如果是5.1以上的版本使用，包含事件--skip-opt      避免锁表--create-option            添加create相关的选项--single-transaction       一致性备份--no-autocommit      采用批量提交方式(提高还原性能)--master-data   如果有写log-bin且版本为5.0以上的版本，则再加上 --master-data=2</code></pre><h5 id="改良mysqldump备份命令"><a href="#改良mysqldump备份命令" class="headerlink" title="改良mysqldump备份命令"></a>改良mysqldump备份命令</h5><pre><code>我的版本是MySQL-5.7.11,启用了binlog，所以应使用如下命令备份数据库mysqldump -uroot -p --events --single-transaction --master-data=2 --skip-opt --databases db1 db2 &gt;/root/mysql.sql</code></pre><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><pre><code>mysqldump命令适用于对数据库相对较小的MySQL进行备份，一般数据量约50GB以内，大于50GB强烈建议使用xtrabackup工具。</code></pre><p>参考：<a href="https://wuyanteng.github.io/2018/01/23/MySql-xtrabackup%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/">MySql xtrabackup大数据量备份与还原</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;生产环境中,场景难免会遇到对正在运行的数据库进行备份，而mysqldump备份会有锁表风险，导致数据在备份期间无法写入数据，所以对正在运行的数据库备份需要慎重。下面就聊聊如何解决锁表？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="MySQL" scheme="https://wuyanteng.github.io/tags/MySQL/"/>
    
      <category term="xtrabackup" scheme="https://wuyanteng.github.io/tags/xtrabackup/"/>
    
      <category term="mysqldump" scheme="https://wuyanteng.github.io/tags/mysqldump/"/>
    
      <category term="innobackup" scheme="https://wuyanteng.github.io/tags/innobackup/"/>
    
      <category term="锁表" scheme="https://wuyanteng.github.io/tags/%E9%94%81%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>shell变量传参</title>
    <link href="https://wuyanteng.github.io/2018/06/22/shell%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82/"/>
    <id>https://wuyanteng.github.io/2018/06/22/shell变量传参/</id>
    <published>2018-06-22T07:54:54.000Z</published>
    <updated>2018-06-22T08:53:43.784Z</updated>
    
    <content type="html"><![CDATA[<pre><code>有时候经常会写传参脚本，下面是一个zabbix自定义key传参案例</code></pre><h5 id="zabbix配置文件"><a href="#zabbix配置文件" class="headerlink" title="zabbix配置文件"></a>zabbix配置文件</h5><pre><code>UnsafeUserParameters=1#mysql slave监控UserParameter=mysql.slave[*],/var/lib/mysql/check_mysql_slave.sh $1注：留意下这个key值，后面是*表示所有</code></pre><a id="more"></a><h5 id="自定义key传参脚本"><a href="#自定义key传参脚本" class="headerlink" title="自定义key传参脚本"></a>自定义key传参脚本</h5><pre><code>vim  check_mysql.sh</code></pre><pre><code>#!/bin/bashUSER=xxxPASS=xxxxxxio_status(){    IoStatus=`mysql -u${USER} -p${PASS} -e &quot;show slave status\G;&quot; |grep -i running|sed -n 1p|awk &#39;{print $NF}&#39;`    if [ $IoStatus == &quot;Yes&quot; ];then        IoStatus=1    else        IoStatus=0    fi    echo  $IoStatus}sql_status(){    SqlStatus=`mysql -u${USER} -p${PASS} -e &quot;show slave status\G;&quot; |grep -i running|sed -n 2p|awk &#39;{print $NF}&#39;`    if [ $SqlStatus == &quot;Yes&quot; ];then        SqlStatus=1    else        SqlStatus=0    fi    echo $SqlStatus}lag_status(){    DelayStatus=`mysql -u${USER} -p${PASS} -e &quot;show slave status\G;&quot; |grep &quot;Seconds_Behind_Master&quot;|awk &#39;{print $NF}&#39;`    echo $DelayStatus}$1</code></pre><pre><code>如何快速理解脚本传参逻辑？(1)可以看到整个脚本使用了3个函数,要知道，写了函数需要在脚本调用才会生效，而本脚本中是使用$1来进行调用的。(2)从脚本中可以看到，对应的传参值分别为io_status、sql_status和lag_status, 其他传参值将不会被调用。(3)zabbix mysql模板中自定义key名称与脚本函数名称相同，所以可以被正确赋值给$1并正确取值。</code></pre><h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><pre><code>如果zabbix mysql模板中自定义key名称不是 io_status、sql_status和lag_status，依然能被正确调用？</code></pre><pre><code>需要在脚本中, 加入判断。如果$1等于zabbix mysql模板中的某个值，则执行脚本中其中一个函数。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;有时候经常会写传参脚本，下面是一个zabbix自定义key传参案例
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;zabbix配置文件&quot;&gt;&lt;a href=&quot;#zabbix配置文件&quot; class=&quot;headerlink&quot; title=&quot;zabbix配置文件&quot;&gt;&lt;/a&gt;zabbix配置文件&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;UnsafeUserParameters=1

#mysql slave监控
UserParameter=mysql.slave[*],/var/lib/mysql/check_mysql_slave.sh $1

注：留意下这个key值，后面是*表示所有
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="zabbix" scheme="https://wuyanteng.github.io/tags/zabbix/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="变量传参" scheme="https://wuyanteng.github.io/tags/%E5%8F%98%E9%87%8F%E4%BC%A0%E5%8F%82/"/>
    
      <category term="shell传参" scheme="https://wuyanteng.github.io/tags/shell%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>Telegram群组-Linux</title>
    <link href="https://wuyanteng.github.io/2018/06/19/Telegram%E7%BE%A4%E7%BB%84-Linux/"/>
    <id>https://wuyanteng.github.io/2018/06/19/Telegram群组-Linux/</id>
    <published>2018-06-19T03:19:18.000Z</published>
    <updated>2018-08-07T06:14:31.184Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Linux-Telegram-群组："><a href="#Linux-Telegram-群组：" class="headerlink" title="Linux Telegram 群组："></a>Linux Telegram 群组：</h5><p>(1) 运维中国  <a href="https://t.me/om_china" target="_blank" rel="noopener">https://t.me/om_china</a></p><p>​    邀请链接：<a href="https://t.me/joinchat/IdnHKE2181qDcfciXYyhVw" target="_blank" rel="noopener">https://t.me/joinchat/IdnHKE2181qDcfciXYyhVw</a></p><p>(2) 运维中国-电报0101兆赫 <a href="https://t.me/om_china_0101" target="_blank" rel="noopener">https://t.me/om_china_0101</a></p><h5 id="群组简介"><a href="#群组简介" class="headerlink" title="群组简介"></a>群组简介</h5><p>正经Linux技术讨论群, 不开车，不扯蛋。交流范围：从底层(OSI7层模型)到OpenStack/K8S等虚拟化,再到Ceph/Swift等分布式存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Linux-Telegram-群组：&quot;&gt;&lt;a href=&quot;#Linux-Telegram-群组：&quot; class=&quot;headerlink&quot; title=&quot;Linux Telegram 群组：&quot;&gt;&lt;/a&gt;Linux Telegram 群组：&lt;/h5&gt;&lt;p&gt;(1) 运维
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://wuyanteng.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Telegram" scheme="https://wuyanteng.github.io/tags/Telegram/"/>
    
      <category term="Telegram Groups" scheme="https://wuyanteng.github.io/tags/Telegram-Groups/"/>
    
      <category term="Telegram群组" scheme="https://wuyanteng.github.io/tags/Telegram%E7%BE%A4%E7%BB%84/"/>
    
      <category term="Telegram群组linux" scheme="https://wuyanteng.github.io/tags/Telegram%E7%BE%A4%E7%BB%84linux/"/>
    
      <category term="TG" scheme="https://wuyanteng.github.io/tags/TG/"/>
    
      <category term="TG X" scheme="https://wuyanteng.github.io/tags/TG-X/"/>
    
  </entry>
  
  <entry>
    <title>MariaDB Galera Cluster部署</title>
    <link href="https://wuyanteng.github.io/2018/06/14/MariaDB-Galera-Cluster%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/06/14/MariaDB-Galera-Cluster部署/</id>
    <published>2018-06-14T08:46:11.000Z</published>
    <updated>2018-06-14T10:24:29.444Z</updated>
    
    <content type="html"><![CDATA[<pre><code>MariaDB作为Mysql的一个分支，在开源项目中已经广泛使用，例如大热的openstack，所以，为了保证服务的高可用性，同时提高系统的负载能力，集群部署是必不可少的。</code></pre><h5 id="MariaDB-Galera-Cluster-介绍"><a href="#MariaDB-Galera-Cluster-介绍" class="headerlink" title="MariaDB Galera Cluster 介绍"></a>MariaDB Galera Cluster 介绍</h5><pre><code>MariaDB集群是MariaDB同步多主机集群。它仅支持XtraDB/ InnoDB存储引擎（虽然有对MyISAM实验支持 - 看wsrep_replicate_myisam系统变量）。</code></pre><a id="more"></a><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><pre><code>- 同步复制- 真正的multi-master，即所有节点可以同时读写数据库- 自动的节点成员控制，失效节点自动被清除- 新节点加入数据自动复制- 真正的并行复制，行级- 用户可以直接连接集群，使用感受上与MySQL完全一致</code></pre><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><pre><code>因为是多主，所以不存在Slavelag(延迟)不存在丢失事务的情况同时具有读和写的扩展能力更小的客户端延迟节点间数据是同步的,而Master/Slave模式是异步的,不同slave上的binlog可能是不同的</code></pre><h5 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h5><pre><code>Galera集群的复制功能基于Galeralibrary实现,为了让MySQL与Galera library通讯，特别针对MySQL开发了wsrep API。Galera插件保证集群同步数据，保持数据的一致性，靠的就是可认证的复制，工作原理如下图： </code></pre><p><img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/mariadb-galera-cluster.png" alt="mariadb cluster"></p><pre><code>当客户端发出一个commit的指令，在事务被提交之前，所有对数据库的更改都会被 write-set 收集起来,并且将 write-set 记录的内容发送给其他节点。write-set 将在每个节点进行认证测试，测试结果决定着节点是否应用write-set更改数据。如果认证测试失败，节点将丢弃 write-set ；如果认证测试成功，则事务提交。</code></pre><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><h5 id="安装环境准备"><a href="#安装环境准备" class="headerlink" title="安装环境准备"></a>安装环境准备</h5><pre><code>安装MariaDB集群至少需要3台服务器（如果只有两台的话需要特殊配置，请参照官方文档）</code></pre><p>官方文档：<a href="http://galeracluster.com/documentation-webpages/twonode.html" target="_blank" rel="noopener">链接</a></p><pre><code>操作系统版本：CentOS7node1:10.128.20.16 node2:10.128.20.17 node3:10.128.20.18</code></pre><p>3节点配置hosts</p><pre><code>10.128.20.16 node110.128.20.17 node210.128.20.18 node3</code></pre><p>禁用防火墙和selinux</p><pre><code>(1)为了保证节点间相互通信，需要禁用防火墙设置（如果需要防火墙，则参照官方网站增加防火墙信息设置）(2)禁用selinux</code></pre><h5 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h5><p>配置MariaDB YUM源</p><pre><code>官方源配置向导：https://link.jianshu.com/?t=https://downloads.mariadb.org/mariadb/repositories</code></pre><pre><code>官方源vim /etc/yum.repos.d/mariadb.repo# MariaDB 10.0 CentOS repository list - created 2018-06-14 08:14 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = http://yum.mariadb.org/10.0/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1</code></pre><pre><code>国内源vim /etc/yum.repos.d/mariadb.repo[mariadb]name = MariaDBbaseurl = http://mirrors.ustc.edu.cn/mariadb/yum/10.2/centos7-amd64/gpgkey=http://mirrors.ustc.edu.cn/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck=1</code></pre><p>安装MariaDB-10.0</p><pre><code>yum install -y mariadb mariadb-galera-server mariadb-galera-common galera rsync</code></pre><p>初始化服务(只在node1节点执行)</p><pre><code>systemctl start mariadbmysql_secure_installation</code></pre><p>关闭node1节点数据库，修改 <code>/etc/my.cnf.d/galera.cnf</code></p><pre><code>systemctl stop mariadbvim /etc/my.cnf.d/galera.cnf     #修改内容如下</code></pre><pre><code>[mysqld]......wsrep_provider = /usr/lib64/galera/libgalera_smm.sowsrep_cluster_address = &quot;gcomm://node1,node2,node3&quot;wsrep_node_name = node1wsrep_node_address=10.128.20.16#wsrep_provider_options=&quot;socket.ssl_key=/etc/pki/galera/galera.key; socket.ssl_cert=/etc/pki/galera/galera.crt;&quot;提示：如果不用ssl的方式认证的话，请把 wsrep_provider_options 注释掉。</code></pre><pre><code>将此文件复制到node2、node3，注意要把 wsrep_node_name 和 wsrep_node_address 改成相应节点的 hostname 和 ip。</code></pre><h5 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h5><pre><code>node1 启动 MariaDB Galera Cluster 服务/usr/libexec/mysqld --wsrep-new-cluster --user=root &amp;</code></pre><pre><code>观察日志：[root@node4 ~]# tail -f /var/log/mariadb/mariadb.log150701 19:54:17 [Note] WSREP: wsrep_load(): loading provider library &#39;none&#39;150701 19:54:17 [Note] /usr/libexec/mysqld: ready for connections.Version: &#39;5.5.40-MariaDB-wsrep&#39;  socket: &#39;/var/lib/mysql/mysql.sock&#39;  port: 3306  MariaDB Server, wsrep_25.11.r4026当出现 ready for connections ,证明我们启动成功</code></pre><p>继续启动node2和node3节点</p><pre><code>systemctl start mariadb可以查看 /var/log/mariadb/mariadb.log，在日志可以看到节点均加入了集群中。警告⚠：--wsrep-new-cluster 这个参数只能在初始化集群使用，且只能在一个节点使用。</code></pre><h5 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h5><pre><code>mysql -uroot -p&gt;SHOW STATUS LIKE `wsrep_%`;</code></pre><p><img src="https://raw.githubusercontent.com/wuyanteng/wuyanteng.github.io/master/images/galera-status.png" alt="galera-status"></p><pre><code>我们可以关注几个关键的参数：wsrep_connected = on 链接已开启wsrep_local_index = 1 在集群中的索引值wsrep_cluster_size =3 集群中节点的数量wsrep_incoming_addresses = 10.128.20.17:3306,10.128.20.16:3306,10.128.20.18:3306 集群中节点的访问地址</code></pre><h5 id="验证数据同步"><a href="#验证数据同步" class="headerlink" title="验证数据同步"></a>验证数据同步</h5><pre><code>我们在 node1 上新建数据库 galera_test ,然后在 node2 和 node3 上查询，如果可以查询到 galera_test 这个库，说明数据同步成功，集群运行正常。</code></pre><pre><code>[root@node1 ~]# mysql  -uroot  -proot  -e  &quot;create database galera_test&quot;</code></pre><pre><code>[root@node2 ~]# mysql  -uroot  -proot  -e  &quot;show databases&quot;+--------------------+| Database           |+--------------------+| information_schema || galera_test        || mysql              || performance_schema |+--------------------+</code></pre><pre><code>[root@node3 ~]# mysql  -uroot  -proot  -e  &quot;show databases&quot;+--------------------+| Database           |+--------------------+| information_schema || galera_test        || mysql              || performance_schema |+--------------------+</code></pre><p>至此，我们的 MariaDB Galera Cluster 已经成功部署。</p><p>参考：<a href="http://code.oneapm.com/database/2015/07/02/mariadb-galera-cluster/" target="_blank" rel="noopener">OpenARM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;MariaDB作为Mysql的一个分支，在开源项目中已经广泛使用，例如大热的openstack，所以，为了保证服务的高可用性，同时提高系统的负载能力，集群部署是必不可少的。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;MariaDB-Galera-Cluster-介绍&quot;&gt;&lt;a href=&quot;#MariaDB-Galera-Cluster-介绍&quot; class=&quot;headerlink&quot; title=&quot;MariaDB Galera Cluster 介绍&quot;&gt;&lt;/a&gt;MariaDB Galera Cluster 介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;MariaDB集群是MariaDB同步多主机集群。它仅支持XtraDB/ InnoDB存储引擎（虽然有对MyISAM实验支持 - 看wsrep_replicate_myisam系统变量）。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="MariaDB" scheme="https://wuyanteng.github.io/tags/MariaDB/"/>
    
      <category term="Galera" scheme="https://wuyanteng.github.io/tags/Galera/"/>
    
      <category term="Cluster" scheme="https://wuyanteng.github.io/tags/Cluster/"/>
    
      <category term="MySQL" scheme="https://wuyanteng.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>nginx日志配合iptables封IP防CC攻击</title>
    <link href="https://wuyanteng.github.io/2018/06/12/nginx%E6%97%A5%E5%BF%97%E9%85%8D%E5%90%88iptables%E5%B0%81IP%E9%98%B2CC%E6%94%BB%E5%87%BB/"/>
    <id>https://wuyanteng.github.io/2018/06/12/nginx日志配合iptables封IP防CC攻击/</id>
    <published>2018-06-12T07:30:44.000Z</published>
    <updated>2018-06-12T08:30:07.776Z</updated>
    
    <content type="html"><![CDATA[<pre><code>通过分析nginx日志找出请求数较大的IP，并用iptables封掉。</code></pre><p>编写脚本</p><pre><code>#!/bin/bash#定义访问次数上限100num=100LOG_DIR=/var/log/nginxcd $LOG_DIR#定义筛选访问量＞100的IP地址IP=`tail access.log -n 1000|awk &#39;{print $1}&#39;|sort|uniq -c|sort -rn|awk &#39;{if ($1&gt;&#39;$num&#39;){print $2}}&#39;`for i in $IP#读取最新1000条记录，如果单IP超过100条就封掉。do      iptables -I INPUT -p tcp -s $i --dport 80 -j DROPdone</code></pre><a id="more"></a><p>配置crontab</p><pre><code>#5分钟执行一次*/5 * * * * sh /path/deny.sh   </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;通过分析nginx日志找出请求数较大的IP，并用iptables封掉。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编写脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash

#定义访问次数上限100
num=100
LOG_DIR=/var/log/nginx
cd $LOG_DIR

#定义筛选访问量＞100的IP地址
IP=`tail access.log -n 1000|awk &amp;#39;{print $1}&amp;#39;|sort|uniq -c|sort -rn|awk &amp;#39;{if ($1&amp;gt;&amp;#39;$num&amp;#39;){print $2}}&amp;#39;`

for i in $IP
#读取最新1000条记录，如果单IP超过100条就封掉。
do
      iptables -I INPUT -p tcp -s $i --dport 80 -j DROP
done
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="CC" scheme="https://wuyanteng.github.io/tags/CC/"/>
    
      <category term="Ddos" scheme="https://wuyanteng.github.io/tags/Ddos/"/>
    
      <category term="nginx日志" scheme="https://wuyanteng.github.io/tags/nginx%E6%97%A5%E5%BF%97/"/>
    
      <category term="高积运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%A7%AF%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反爬虫</title>
    <link href="https://wuyanteng.github.io/2018/06/12/Nginx%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    <id>https://wuyanteng.github.io/2018/06/12/Nginx反爬虫/</id>
    <published>2018-06-12T03:09:14.000Z</published>
    <updated>2018-06-12T04:03:46.602Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Nginx被爬虫的服务器，会在某个时间点CPU占用骤增, 不同时间段CPU占用较高（也可能会出现内存溢出等问题）。如果服务器有web业务，那么基本可以确定被爬虫了...</code></pre><a id="more"></a><h4 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h4><h5 id="首先对爬虫IP进行屏蔽"><a href="#首先对爬虫IP进行屏蔽" class="headerlink" title="首先对爬虫IP进行屏蔽"></a>首先对爬虫IP进行屏蔽</h5><pre><code>策略: 通过awk筛选日志，找出访问量较高的可以IP地址进行屏蔽。(1)查找要禁止的IP:awk &#39;{print $1}&#39; /var/log/nginx/access.log|sort |uniq -c|sort -rn(2)屏蔽IP或IP段在nginx server区段添加如下即可：deny 5.188.211.72;或deny 5.188.211.70/32;</code></pre><h5 id="Nginx判断UA处理反爬虫"><a href="#Nginx判断UA处理反爬虫" class="headerlink" title="Nginx判断UA处理反爬虫"></a>Nginx判断UA处理反爬虫</h5><pre><code>这个时候就有充足的时间通过一些手段进行反爬虫处理了...</code></pre><p>将下面的if语句放在nginx配置文件的server或者location代码区域内【不能放在http区域】。</p><pre><code>#禁止指定UA及UA为空的访问(常见UA列表详见附录)if ($http_user_agent ~* &quot;Applebot|SEOkicks-Robot|DotBot|YunGuanCe|Exabot|spiderman|Scrapy|HttpClient|Teleport|TeleportPro|SiteExplorer|WBSearchBot|Elefent|psbot|TurnitinBot|wsAnalyzer|ichiro|ezooms|FeedDemon|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|CoolpadWebkit|Java|Feedly|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|HttpClient|MJ12bot|heritrix|EasouSpider|Ezooms|^$&quot;) {  return 403;} </code></pre><p>生效</p><pre><code>添加此配置之后，验证语法：nginx -t 无误后,重载Nginx配置: nginx -s reload</code></pre><p>测试</p><pre><code>curl -I -A &quot;spiderman&quot; https://xx.xxx.com或curl -I -A &quot;YunGuanCe&quot; https://xx.xxx.com如果返回403的输出，则说明配置已经生效了</code></pre><h5 id="自行筛选屏蔽UA"><a href="#自行筛选屏蔽UA" class="headerlink" title="自行筛选屏蔽UA"></a>自行筛选屏蔽UA</h5><pre><code>log筛选命令：cat access.log|awk -F &#39;&quot;&#39; &#39;{print $6}&#39;|sort|uniq -c |sort -rn|head -20将可疑的UA加入以上屏蔽列表即可。</code></pre><h5 id="附录：常见的爬虫UA"><a href="#附录：常见的爬虫UA" class="headerlink" title="附录：常见的爬虫UA"></a>附录：常见的爬虫UA</h5><p>常见搜索引擎爬虫的User-Agent</p><pre><code>百度爬虫Baiduspider+(+http://www.baidu.com/search/spider.htm”)Google爬虫Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)Googlebot/2.1 (+http://www.googlebot.com/bot.html)Googlebot/2.1 (+http://www.google.com/bot.html)雅虎爬虫(分别是雅虎中国和美国总部的爬虫)Mozilla/5.0 (compatible; Yahoo! Slurp China; http://misc.yahoo.com.cn/help.html”)Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp”)新浪爱问爬虫iaskspider/2.0(+http://iask.com/help/help_index.html”)Mozilla/5.0 (compatible; iaskspider/1.0; MSIE 6.0)搜狗爬虫Sogou web spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07″)Sogou Push Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07″)网易爬虫Mozilla/5.0 (compatible; YodaoBot/1.0; http://www.yodao.com/help/webmaster/spider/”; )MSN爬虫msnbot/1.0 (+http://search.msn.com/msnbot.htm”)</code></pre><p>网络上常见的垃圾UA列表</p><pre><code>内容采集：      FeedDemon      Java 内容采集      Jullo 内容采集      Feedly 内容采集      UniversalFeedParser 内容采集SQL注入：      BOT/0.1 (BOT for JCE)      CrawlDaddy无用爬虫:      EasouSpider      Swiftbot      YandexBot      AhrefsBot      jikeSpider      MJ12bot      YYSpider      oBotCC攻击器:      ApacheBench      WinHttpTCP攻击:      HttpClient扫描:      Microsoft URL Control      ZmEu phpmyadmin      jaunty</code></pre><p>参考：<a href="https://www.hi-linux.com/posts/5492.html" target="_blank" rel="noopener">运维之美</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Nginx被爬虫的服务器，会在某个时间点CPU占用骤增, 不同时间段CPU占用较高（也可能会出现内存溢出等问题）。如果服务器有web业务，那么基本可以确定被爬虫了...
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="nginx反爬虫" scheme="https://wuyanteng.github.io/tags/nginx%E5%8F%8D%E7%88%AC%E8%99%AB/"/>
    
      <category term="蜘蛛" scheme="https://wuyanteng.github.io/tags/%E8%9C%98%E8%9B%9B/"/>
    
      <category term="User Agent" scheme="https://wuyanteng.github.io/tags/User-Agent/"/>
    
      <category term="垃圾UA" scheme="https://wuyanteng.github.io/tags/%E5%9E%83%E5%9C%BEUA/"/>
    
  </entry>
  
</feed>
