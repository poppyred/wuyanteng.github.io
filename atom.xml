<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gary Wu</title>
  
  <subtitle>运维架构师 - 从入门到放弃</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wuyanteng.github.io/"/>
  <updated>2018-10-18T07:19:43.591Z</updated>
  <id>https://wuyanteng.github.io/</id>
  
  <author>
    <name>Gary Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查询mongo数据</title>
    <link href="https://wuyanteng.github.io/2018/10/18/%E6%9F%A5%E8%AF%A2mongo%E6%95%B0%E6%8D%AE/"/>
    <id>https://wuyanteng.github.io/2018/10/18/查询mongo数据/</id>
    <published>2018-10-18T06:17:12.000Z</published>
    <updated>2018-10-18T07:19:43.591Z</updated>
    
    <content type="html"><![CDATA[<pre><code>简单整理下查询mongo数据方法</code></pre><h4 id="进入mongo数据库"><a href="#进入mongo数据库" class="headerlink" title="进入mongo数据库"></a>进入mongo数据库</h4><pre><code>mongo 10.0.0.200:27017rs.slaveOk();   让从库支持读操作show dbs; 查询数据库use video;  进入数据库show tables; 查询关系型表show collections； 查询所有表（集合）</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>SECONDARY&gt; db.表名.find()这个命令类似于mysql数据库的：select from 表名;</code></pre><p>如果表过大，需要使用limit限制行数，否则可能对库造成很大压力。</p><pre><code>SECONDARY&gt; db.表名.find().limit(10)    查看前10行数据</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;简单整理下查询mongo数据方法
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;进入mongo数据库&quot;&gt;&lt;a href=&quot;#进入mongo数据库&quot; class=&quot;headerlink&quot; title=&quot;进入mongo数据库&quot;&gt;&lt;/a&gt;进入mongo数据库&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mongo" scheme="https://wuyanteng.github.io/tags/mongo/"/>
    
      <category term="查询mongo" scheme="https://wuyanteng.github.io/tags/%E6%9F%A5%E8%AF%A2mongo/"/>
    
      <category term="limit" scheme="https://wuyanteng.github.io/tags/limit/"/>
    
  </entry>
  
  <entry>
    <title>sendmail发送邮件</title>
    <link href="https://wuyanteng.github.io/2018/10/18/sendmail%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <id>https://wuyanteng.github.io/2018/10/18/sendmail发送邮件/</id>
    <published>2018-10-18T03:01:03.000Z</published>
    <updated>2018-10-18T03:33:41.128Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Gentoo系统模板内置了ssmtp软件，可直接使用sendmail命令发送</code></pre><h2 id="安装mailx"><a href="#安装mailx" class="headerlink" title="安装mailx"></a>安装mailx</h2><pre><code>eix mailxemerge mail-client/mailx</code></pre><h2 id="邮件发送命令"><a href="#邮件发送命令" class="headerlink" title="邮件发送命令"></a>邮件发送命令</h2><pre><code>echo -e  &quot;this is test\n Is true.&quot; |mail -s &quot;test&quot; mail@qq.com</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;Gentoo系统模板内置了ssmtp软件，可直接使用sendmail命令发送
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;安装mailx&quot;&gt;&lt;a href=&quot;#安装mailx&quot; class=&quot;headerlink&quot; title=&quot;安装mailx&quot;&gt;&lt;/a&gt;安装
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="mail" scheme="https://wuyanteng.github.io/tags/mail/"/>
    
      <category term="mailx" scheme="https://wuyanteng.github.io/tags/mailx/"/>
    
      <category term="sendmail" scheme="https://wuyanteng.github.io/tags/sendmail/"/>
    
  </entry>
  
  <entry>
    <title>gentoo emerge postfix</title>
    <link href="https://wuyanteng.github.io/2018/10/15/gentoo-emerge-postfix/"/>
    <id>https://wuyanteng.github.io/2018/10/15/gentoo-emerge-postfix/</id>
    <published>2018-10-15T08:06:44.000Z</published>
    <updated>2018-10-15T08:14:34.771Z</updated>
    
    <content type="html"><![CDATA[<pre><code>gentoo系统中，安装某些包的过程中，出现blocking的情况，也就是出现了冲突。下面以安装postfix为例，简单记录下</code></pre><a id="more"></a><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><pre><code>Gentoo 安装postfix，但如果系统中默认安装了ssmtp，就会出现blocking无法安装的情况。冲突的软件会列出来。错误提示：[blocks B] mail-mta/postfix (&quot;mail-mta/postfix&quot; is blocking mail-mta/ssmtp-2.64-r2)[blocks B] &gt;=mail-mta/ssmtp-2.64-r2[mta] (&quot;&gt;=mail-mta/ssmtp-2.64-r2[mta]&quot; is blocking mail-mta/postfix-2.9.4)* Error: The above package list contains packages which cannot be* installed at the same time on the same system.</code></pre><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><pre><code>解决方法如下：emerge --ask -C ssmtp    检查系统中是否安装有ssmtp,如果有按照提示卸载emerge --ask postfix     再安装就正常了</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;gentoo系统中，安装某些包的过程中，出现blocking的情况，也就是出现了冲突。
下面以安装postfix为例，简单记录下
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="emerge" scheme="https://wuyanteng.github.io/tags/emerge/"/>
    
      <category term="gentoo" scheme="https://wuyanteng.github.io/tags/gentoo/"/>
    
      <category term="postfix" scheme="https://wuyanteng.github.io/tags/postfix/"/>
    
      <category term="install" scheme="https://wuyanteng.github.io/tags/install/"/>
    
  </entry>
  
  <entry>
    <title>查看和释放swap内存</title>
    <link href="https://wuyanteng.github.io/2018/10/12/%E6%9F%A5%E7%9C%8B%E5%92%8C%E9%87%8A%E6%94%BEswap%E5%86%85%E5%AD%98/"/>
    <id>https://wuyanteng.github.io/2018/10/12/查看和释放swap内存/</id>
    <published>2018-10-12T02:09:07.000Z</published>
    <updated>2018-10-12T02:28:30.938Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于内存耗尽总结"><a href="#关于内存耗尽总结" class="headerlink" title="关于内存耗尽总结"></a>关于内存耗尽总结</h4><pre><code>要达到释放缓存的目的，我们首先需要了解下关键的配置文件/proc/sys/vm/drop_caches。这个文件中记录了缓存释放的参数，默认值为0，也就是不释放缓存。他的值可以为0~3之间的任意数字，代表着不同的含义：0 – 不释放1 – 释放页缓存2 – 释放dentries和inodes3 – 释放所有缓存知道了参数后，我们就可以根据我们的需要，使用下面的指令来进行操作。</code></pre><h4 id="swap磁盘占用过高原因分析"><a href="#swap磁盘占用过高原因分析" class="headerlink" title="swap磁盘占用过高原因分析"></a>swap磁盘占用过高原因分析</h4><pre><code>通过此命令查看内存被哪些进程占用（单位是MByte）for i in `cd /proc;ls |grep &quot;^[0-9]&quot;|awk &#39; $0 &gt;100&#39;` ;do awk &#39;/Swap:/{a=a+$2}END{print &#39;&quot;$i&quot;&#39;,a/1024&quot;M&quot;}&#39; /proc/$i/smaps ;done 2&gt;&amp;1 |sort -k2nr |head注：以上结果输出PID与内存占用大小，通过PID可以找到对应进程</code></pre><a id="more"></a><h4 id="释放内存方案"><a href="#释放内存方案" class="headerlink" title="释放内存方案"></a>释放内存方案</h4><pre><code>方案1： 重启占用swap最高的进程方法2： 关闭swap分区       有时候并不能查看到哪些进程占用swap，则需要先关闭swap分区再开启</code></pre><h4 id="关闭swap分区注意事项和步骤"><a href="#关闭swap分区注意事项和步骤" class="headerlink" title="关闭swap分区注意事项和步骤"></a>关闭swap分区注意事项和步骤</h4><pre><code>1，确保系统空闲物理内存大于swap已用内存，否则会导致服务器宕机！2，先清理内存cache，空出足够内存   sync   echo &quot;3&quot; &gt; /proc/sys/vm/drop_caches3，关闭swap分区，这个过程需要等待   swapon -s  查看swap挂载分区   swapoff -a 或 swapoff /dev/sda54，swap分区释放后，恢复swap分区   swapon -a  或 swapon /dev/sda55，恢复内存cache的设置   echo &quot;0&quot; &gt; /proc/sys/vm/drop_caches</code></pre><pre><code>free -m   再次查看即可</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关于内存耗尽总结&quot;&gt;&lt;a href=&quot;#关于内存耗尽总结&quot; class=&quot;headerlink&quot; title=&quot;关于内存耗尽总结&quot;&gt;&lt;/a&gt;关于内存耗尽总结&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;要达到释放缓存的目的，我们首先需要了解下关键的配置文件/proc/sys/vm/drop_caches。这个文件中记录了缓存释放的参数，默认值为0，也就是不释放缓存。他的值可以为0~3之间的任意数字，代表着不同的含义：

0 – 不释放
1 – 释放页缓存
2 – 释放dentries和inodes
3 – 释放所有缓存

知道了参数后，我们就可以根据我们的需要，使用下面的指令来进行操作。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;swap磁盘占用过高原因分析&quot;&gt;&lt;a href=&quot;#swap磁盘占用过高原因分析&quot; class=&quot;headerlink&quot; title=&quot;swap磁盘占用过高原因分析&quot;&gt;&lt;/a&gt;swap磁盘占用过高原因分析&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;通过此命令查看内存被哪些进程占用（单位是MByte）

for i in `cd /proc;ls |grep &amp;quot;^[0-9]&amp;quot;|awk &amp;#39; $0 &amp;gt;100&amp;#39;` ;do awk &amp;#39;/Swap:/{a=a+$2}END{print &amp;#39;&amp;quot;$i&amp;quot;&amp;#39;,a/1024&amp;quot;M&amp;quot;}&amp;#39; /proc/$i/smaps ;done 2&amp;gt;&amp;amp;1 |sort -k2nr |head

注：以上结果输出PID与内存占用大小，通过PID可以找到对应进程
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="cache" scheme="https://wuyanteng.github.io/tags/cache/"/>
    
      <category term="swap" scheme="https://wuyanteng.github.io/tags/swap/"/>
    
      <category term="swapon" scheme="https://wuyanteng.github.io/tags/swapon/"/>
    
      <category term="swapoff" scheme="https://wuyanteng.github.io/tags/swapoff/"/>
    
      <category term="交换分区" scheme="https://wuyanteng.github.io/tags/%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ESXI安装openstack注意事项</title>
    <link href="https://wuyanteng.github.io/2018/09/26/ESXI%E5%AE%89%E8%A3%85openstack%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://wuyanteng.github.io/2018/09/26/ESXI安装openstack注意事项/</id>
    <published>2018-09-26T09:19:22.000Z</published>
    <updated>2018-09-26T09:50:59.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如在esxi中安装openstack，则esxi需要配置混杂模式，否则vm无法上网。"><a href="#如在esxi中安装openstack，则esxi需要配置混杂模式，否则vm无法上网。" class="headerlink" title="如在esxi中安装openstack，则esxi需要配置混杂模式，否则vm无法上网。"></a>如在esxi中安装openstack，则esxi需要配置混杂模式，否则vm无法上网。</h4><h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><pre><code>(1)使用 vSphere Client 登录到 ESXi/ESX 主机或 vCenter Server。(2)在清单中选择 ESXi/ESX 主机。(3)单击配置选项卡。(4)在“硬件”部分，单击网络。(5)单击要启用混杂模式的虚拟交换机的属性。(6)选择要修改的虚拟交换机或端口组，然后单击编辑。(7)单击安全选项卡。(8)从“混杂模式”下拉菜单中，单击接受。</code></pre><p>参考：<a href="https://kb.vmware.com/articleview?docid=1004099&amp;lang=zh_CN" target="_blank" rel="noopener">官网-中文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如在esxi中安装openstack，则esxi需要配置混杂模式，否则vm无法上网。&quot;&gt;&lt;a href=&quot;#如在esxi中安装openstack，则esxi需要配置混杂模式，否则vm无法上网。&quot; class=&quot;headerlink&quot; title=&quot;如在esxi中安
      
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Openstack" scheme="https://wuyanteng.github.io/tags/Openstack/"/>
    
      <category term="esxi" scheme="https://wuyanteng.github.io/tags/esxi/"/>
    
      <category term="混杂模式" scheme="https://wuyanteng.github.io/tags/%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop2.7.3完全分布式部署-大数据1</title>
    <link href="https://wuyanteng.github.io/2018/09/18/Hadoop2.7.3%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2-%E5%A4%A7%E6%95%B0%E6%8D%AE1/"/>
    <id>https://wuyanteng.github.io/2018/09/18/Hadoop2.7.3完全分布式部署-大数据1/</id>
    <published>2018-09-18T11:55:53.000Z</published>
    <updated>2018-09-19T10:44:49.210Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是大数据？"><a href="#什么是大数据？" class="headerlink" title="什么是大数据？"></a>什么是大数据？</h4><pre><code>大数据即海量数据，一般数据量在PB级别，甚至更高1T = 1024G1P = 1024T1E = 1024P1Z = 1024E1Y = 1024Z1N = 1024Y</code></pre><a id="more"></a><h4 id="大数据解决了什么问题？"><a href="#大数据解决了什么问题？" class="headerlink" title="大数据解决了什么问题？"></a>大数据解决了什么问题？</h4><pre><code>(1)存储 -- 分布式存储(2)计算 -- 分布式计算</code></pre><h4 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h4><pre><code>由分布在不同主机上的进程协同在一起，才能构成整个应用</code></pre><h4 id="什么是hadoop？"><a href="#什么是hadoop？" class="headerlink" title="什么是hadoop？"></a>什么是hadoop？</h4><pre><code>hadoop是由Apache开发的一款开源软件，它具有可靠、分布式以及可伸缩的特点官网：http://hadoop.apache.org/</code></pre><h5 id="大数据的四个V特征"><a href="#大数据的四个V特征" class="headerlink" title="大数据的四个V特征"></a>大数据的四个V特征</h5><pre><code>1. volumn    //体量大2. variety   //样式多，结构化数据(各种数据库等)、半结构化(xml/csv等)、非结构化数据（文本）3. velocity  //速度快4. valueless //价值密度低所以要使用大数据来去IOE以节约成本，即   IBM     //IBM小型机   Oracle   //oracle数据库   EMC      //EMC共享存储设备</code></pre><h4 id="hadoop四个模块"><a href="#hadoop四个模块" class="headerlink" title="hadoop四个模块"></a>hadoop四个模块</h4><pre><code>1. Hadoop Common2. Hadoop Distributed File System (即HDFS)3. Hadoop YARN4. Hadoop MapReduce</code></pre><h2 id="安装hadoop集群"><a href="#安装hadoop集群" class="headerlink" title="安装hadoop集群"></a>安装hadoop集群</h2><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><pre><code>Master/namenode  10.0.60.11Slave1/datanode  10.0.60.12slave2/datanode  10.0.60.13</code></pre><h4 id="1-安装jdk-所有节点均配置"><a href="#1-安装jdk-所有节点均配置" class="headerlink" title="(1)安装jdk(所有节点均配置)"></a>(1)安装jdk(所有节点均配置)</h4><pre><code>useradd centos &amp;&amp; su - centossudo mkdir -p /opt/jdk  &amp;&amp;  cd /opt sudo tar -zxvf jdk-8u181-linux-x64.tar.gz -C /optsudo ln -sv /opt/jdk-8u181-linux-x64 /opt/jdkcd /opt/jdk &amp;&amp; ./java --versionchown -R centos.centos /opt/jdk*配置环境变量#vim /etc/profile......export JAVA_HOME=/opt/jdkexport PATH=$PATH:$JAVA_HOME/bin注：$PATH是取出当前原来系统的PATH变量，改变成当前新的环境变量为$JAVA_HOME/binsource /etc/profilecd &amp;&amp; java -version</code></pre><h4 id="2-配置SSH免密登陆-所有节点均配置"><a href="#2-配置SSH免密登陆-所有节点均配置" class="headerlink" title="(2) 配置SSH免密登陆(所有节点均配置)"></a>(2) 配置SSH免密登陆(所有节点均配置)</h4><pre><code>要求：所有节点直接可以互相ssh免密ssh登陆master# ssh-keygen -t dsa此时会在当前.ssh目录下生成id_dsa和id_dsa.pub文件master# touch authorzied_keys将其他两台slave的id_dsa.pub内容追加到authorzied_keys文件中，然后修改authorzied_keys和.ssh的权限。master# chmod 600 authorzied_keysmaster# chown 700 ../.ssh</code></pre><h4 id="3-关闭防火墙-所有节点均配置"><a href="#3-关闭防火墙-所有节点均配置" class="headerlink" title="(3) 关闭防火墙(所有节点均配置)"></a>(3) 关闭防火墙(所有节点均配置)</h4><pre><code>systemctl stop firewalldsystemctl disable firewalld</code></pre><h4 id="4-集群时钟同步-所有节点均配置"><a href="#4-集群时钟同步-所有节点均配置" class="headerlink" title="(4) 集群时钟同步(所有节点均配置)"></a>(4) 集群时钟同步(所有节点均配置)</h4><pre><code>ln -fs /usr/share/zoneinfo/Asia/Shanghai /etc/localtimentpdate -u 0.asia.pool.ntp.org</code></pre><h4 id="5-安装hadoop-所有节点均配置"><a href="#5-安装hadoop-所有节点均配置" class="headerlink" title="(5)安装hadoop(所有节点均配置)"></a>(5)安装hadoop(所有节点均配置)</h4><pre><code>下载二进制：hadoop-2.7.3.tar.gzsudo tar -xvf hadoop-2.7.3.tar.gz -C /opt/sudo ln -sv /opt/hadoop-2.7.3 /opt/hadoopsudo chown -R centos.centos /opt/hadoop*配置环境变量#vim /etc/profile......export HADOOP_HOME=/opt/hadoopexport PATH=$PATH:$HADOOP_HOME/bin:$$HADOOP_HOME/Sbinsource /etc/profilecd &amp;&amp; hadoop version</code></pre><h2 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h2><h4 id="hadoop三种模式"><a href="#hadoop三种模式" class="headerlink" title="hadoop三种模式"></a>hadoop三种模式</h4><pre><code>(1) standalone（或local）本地模式    nothing! 什么也不做，即为本地模式(2) Pseudodistributed 伪分布模式(3)完全分布式模式            </code></pre><h4 id="修改hadoop配置文件"><a href="#修改hadoop配置文件" class="headerlink" title="修改hadoop配置文件"></a>修改hadoop配置文件</h4><pre><code>hadoop配置目录：${HADOOP_HOME}/etc/hadoop ,其下包含三个文件：hadoop-env.sh，mapred-env.sh，yarn-env.sh</code></pre><p>(1) core-site.xml   </p><pre><code>&lt;configuration&gt;&lt;property&gt;      &lt;name&gt;fs.defaultFS&lt;/name&gt;      &lt;value&gt;hdfs://master:9000&lt;/value&gt;      &lt;description&gt;主节点namenode的host和端口&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/usr/hadoop/tmp&lt;/value&gt;  &lt;description&gt;hdfs中namenode和datanode数据的默认存放目录&lt;/description&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><p>(2) hdfs-site.xml</p><pre><code>&lt;configuration&gt;&lt;property&gt;    &lt;name&gt;dfs.name.dir&lt;/name&gt;    &lt;value&gt;/usr/hadoop/hdfs/name&lt;/value&gt;    &lt;description&gt;namenode数据的存放目录&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.data.dir&lt;/name&gt;    &lt;value&gt;/usr/hadoop/hdfs/data&lt;/value&gt;    &lt;description&gt;datanode数据的存放目录&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;    &lt;value&gt;2&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;        &lt;value&gt;master:9001&lt;/value&gt;        &lt;description&gt;secondarynamenode的web地址&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;    &lt;description&gt;提供web访问hdfs的权限&lt;/description&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><pre><code>注：访问namenode的hdfs使用50070端口，访问datanode的webhdfs使用50075端口。要想不区分端口，直接使用namenode的IP和端口进行所有的webhdfs操作，就需要在所有的datanode上都设置hdfs-site.xml中的dfs.webhdfs.enabled为true。</code></pre><p>(3) mapred-site.xml</p><pre><code>&lt;configuration&gt;&lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;        &lt;value&gt;master:10020&lt;/value&gt;        &lt;description&gt;jobhistory是Hadoop自带了一个历史服务器，记录Mapreduce历史作业&lt;/description&gt;&lt;/property&gt;&lt;property&gt;        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;        &lt;value&gt;master:19888&lt;/value&gt;        &lt;description&gt;jobhistory的http地址&lt;/description&gt;&lt;/property&gt;&lt;/configuration&gt;</code></pre><pre><code>注：jobhistory是Hadoop自带了一个历史服务器，记录Mapreduce历史作业。默认情况下，jobhistory没有启动，可用以下命令启动：sbin/mr-jobhistory-daemon.sh start historyserver </code></pre><p>(4) yarn-site.xml</p><pre><code>&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;     &lt;property&gt;        &lt;name&gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&lt;/name&gt;        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;        &lt;value&gt;master:8032&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;        &lt;value&gt;master:8030&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;        &lt;value&gt;master:8031&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;        &lt;value&gt;master:8033&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;        &lt;value&gt;master:8088&lt;/value&gt;        &lt;description&gt;yarn资源管理的http地址&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;        &lt;value&gt;768&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是大数据？&quot;&gt;&lt;a href=&quot;#什么是大数据？&quot; class=&quot;headerlink&quot; title=&quot;什么是大数据？&quot;&gt;&lt;/a&gt;什么是大数据？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;大数据即海量数据，一般数据量在PB级别，甚至更高

1T = 1024G
1P = 1024T
1E = 1024P
1Z = 1024E
1Y = 1024Z
1N = 1024Y
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://wuyanteng.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="https://wuyanteng.github.io/tags/hadoop/"/>
    
      <category term="HDFS" scheme="https://wuyanteng.github.io/tags/HDFS/"/>
    
      <category term="YARN" scheme="https://wuyanteng.github.io/tags/YARN/"/>
    
      <category term="本地模式" scheme="https://wuyanteng.github.io/tags/%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="伪分布模式" scheme="https://wuyanteng.github.io/tags/%E4%BC%AA%E5%88%86%E5%B8%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从库同步出现主键错误-分析</title>
    <link href="https://wuyanteng.github.io/2018/09/18/mysql%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E5%87%BA%E7%8E%B0%E4%B8%BB%E9%94%AE%E9%94%99%E8%AF%AF-%E5%88%86%E6%9E%90/"/>
    <id>https://wuyanteng.github.io/2018/09/18/mysql主从库同步出现主键错误-分析/</id>
    <published>2018-09-18T07:45:38.000Z</published>
    <updated>2018-09-21T09:30:54.544Z</updated>
    
    <content type="html"><![CDATA[<pre><code>mysql主库数据量TB级别，废了九牛二虎之力做了从库，一切正常。过了没几天，出现了主键等错误。</code></pre><p>原因分析</p><pre><code>造成此问题的原因 与主库数据量几乎没有关系，很大可能是因为从库被写入了数据，导致主从主键不一致。</code></pre><a id="more"></a><p>建议</p><pre><code>1. 从库启用read_only, 配置文件添加如下配置【也可动态配置，无需重启服务】：   read_only = ON   super_read_only = ON2. 主从均开启GTID3. 主从均使用ROW格式</code></pre><p>临时解决</p><pre><code>/usr/sbin/mysql -uroot -p -e &quot;set global sql_slave_skip_counter=1;start slave;&quot;使用此命令来跳过一个事务</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;mysql主库数据量TB级别，废了九牛二虎之力做了从库，一切正常。过了没几天，出现了主键等错误。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原因分析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;造成此问题的原因 与主库数据量几乎没有关系，很大可能是因为从库被写入了数据，导致主从主键不一致。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="主从同步" scheme="https://wuyanteng.github.io/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
      <category term="mysql" scheme="https://wuyanteng.github.io/tags/mysql/"/>
    
      <category term="主键错误" scheme="https://wuyanteng.github.io/tags/%E4%B8%BB%E9%94%AE%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>重温ps命令</title>
    <link href="https://wuyanteng.github.io/2018/09/14/%E9%87%8D%E6%B8%A9ps-aux%E5%91%BD%E4%BB%A4/"/>
    <id>https://wuyanteng.github.io/2018/09/14/重温ps-aux命令/</id>
    <published>2018-09-14T02:48:20.000Z</published>
    <updated>2018-09-14T03:04:24.028Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Linux下最常用的2个命令：ps -efps aux来重新温习下他们两个命令的区别</code></pre><a id="more"></a><h4 id="ps-ef能输出什么内容："><a href="#ps-ef能输出什么内容：" class="headerlink" title="ps -ef能输出什么内容："></a>ps -ef能输出什么内容：</h4><pre><code>[root@gfw_proxy_15 ~]# ps -ef|headUID        PID  PPID  C STIME TTY          TIME CMDroot         8     2  0 Jul13 ?        00:00:00 [rcu_bh]root         9     2  0 Jul13 ?        00:00:00 [rcuob/0]root        10     2  0 Jul13 ?        00:00:00 [rcuob/1]root        11     2  0 Jul13 ?        00:00:00 [rcuob/2]</code></pre><pre><code>UID     //用户ID、但输出的是用户名PID     //进程的IDPPID    //父进程IDC       //进程占用CPU的百分比STIME   //进程启动到现在的时间TTY     //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。CMD     //命令的名称和参数</code></pre><h4 id="ps-aux能输出什么内容？"><a href="#ps-aux能输出什么内容？" class="headerlink" title="ps aux能输出什么内容？"></a>ps aux能输出什么内容？</h4><pre><code>[root@gfw_proxy_15 ~]# ps aux|headUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  0.0  0.0 123308  3820 ?        Ss   Jul13  45:58 /usr/lib/systemd/systemd...root         2  0.0  0.0      0     0 ?        S    Jul13   0:04 [kthreadd]root         3  0.0  0.0      0     0 ?        S    Jul13   0:14 [ksoftirqd/0]</code></pre><pre><code>USER      //用户名PID       //PID%CPU      //进程占用的CPU百分比%MEM      //占用内存的百分比VSZ       //该进程使用的虚拟內存量（KB）RSS       //该进程占用的固定內存量（KB）（驻留中页的数量）STAT      //进程的状态START     //该进程被触发启动时间TIME      //该进程实际使用CPU运行的时间</code></pre><h4 id="查看进程占用的CPU和内存大小"><a href="#查看进程占用的CPU和内存大小" class="headerlink" title="查看进程占用的CPU和内存大小"></a>查看进程占用的CPU和内存大小</h4><pre><code># ps aux |grep openvpnroot     18493  0.7  0.1  12336  3888 ?        Sl   Sep13   7:54 /usr/sbin/openvpn.....上面第3列是CPU占用百分比；上面第6列，是进程所占用的固定内存,单位k(除以1000单位是M)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;Linux下最常用的2个命令：
ps -ef
ps aux

来重新温习下他们两个命令的区别
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ps" scheme="https://wuyanteng.github.io/tags/ps/"/>
    
      <category term="aux" scheme="https://wuyanteng.github.io/tags/aux/"/>
    
      <category term="查看进程内存" scheme="https://wuyanteng.github.io/tags/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>date时间戳转换</title>
    <link href="https://wuyanteng.github.io/2018/09/13/date%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2/"/>
    <id>https://wuyanteng.github.io/2018/09/13/date时间戳转换/</id>
    <published>2018-09-13T06:12:01.000Z</published>
    <updated>2018-09-13T06:18:27.767Z</updated>
    
    <content type="html"><![CDATA[<pre><code>linux时间戳转换</code></pre><p>查看当前unix时间戳</p><pre><code>date +%s变量赋值Now_UNIX=`date +%s`</code></pre><a id="more"></a><p>标准时间转unix</p><pre><code>date -d &quot;2017-08-01 00:00:00&quot; +%s变量赋值UNIX=`date -d &quot;2017-08-01 00:00:00&quot; +%s`</code></pre><p>unix转标准时间</p><pre><code>date -d &quot;@1536819453&quot; </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;linux时间戳转换
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看当前unix时间戳&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;date +%s

变量赋值
Now_UNIX=`date +%s`
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="unix" scheme="https://wuyanteng.github.io/tags/unix/"/>
    
      <category term="date" scheme="https://wuyanteng.github.io/tags/date/"/>
    
      <category term="时间戳" scheme="https://wuyanteng.github.io/tags/%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    
      <category term="time" scheme="https://wuyanteng.github.io/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>基于easyrsa3自动化实现openvpn用户证书的创建与吊销</title>
    <link href="https://wuyanteng.github.io/2018/09/12/%E5%9F%BA%E4%BA%8Eeasyrsa3%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E7%8E%B0openvpn%E7%94%A8%E6%88%B7%E8%AF%81%E4%B9%A6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%8A%E9%94%80/"/>
    <id>https://wuyanteng.github.io/2018/09/12/基于easyrsa3自动化实现openvpn用户证书的创建与吊销/</id>
    <published>2018-09-12T08:36:25.000Z</published>
    <updated>2018-09-12T08:47:16.343Z</updated>
    
    <content type="html"><![CDATA[<pre><code>写个脚本，一键创建用户证书与吊销证书，使用格式：想要的效果--使用方法sh vpn.sh add/del username</code></pre><pre><code>前提：(1)自己能通过SSH登陆到自己，即ssh免密登陆(2)提前安装好所需包   yum install -y expect expect-devel tcl问题：为什么要这么做？因为自己的openvpn证书基于easyrsa3的版本进行创建，而此版本并不能使用pkitool的参数来方便快捷的解决免交互的问题【pkitool不支持easyrsa3, 只适用于easyrsa2】，所以只能借助于expect实现免交互</code></pre><a id="more"></a><pre><code>#!/bin/bashif [ $# != 2 ];then   echo &quot;USAGE: sh $0 add/del username&quot;   exit 1;fi#定义变量AD=$1USER=$2PASS=`head -c 100 /dev/urandom | tr -dc a-z0-9A-Z |head -c 16`DIR1=/opt/easy-rsa-3.0.5/easyrsa3DIR2=/etc/openvpn/easy-rsa/easyrsa3TMP=/tmp/openvpn.ept#解决签约错误cd $DIR2/pkiif [ -f index.txt ];then   rm -f index.txt &amp;&amp; touch index.txtfi#创建客户端证书if [ &quot;$AD&quot; == &quot;add&quot; ];thencat &gt; $TMP &lt;&lt; EOF#!/usr/bin/expectspawn ssh -p22 root@192.168.0.11set timeout -1expect &quot;]#&quot;send -- &quot;cd $DIR1\r&quot;sleep 2expect &quot;]#&quot;send -- &quot;echo &#39;yes&#39;|./easyrsa gen-req $USER\r&quot;sleep 5expect &quot;phrase:&quot;send -- &quot;$PASS\r&quot;expect &quot;phrase:&quot;send -- &quot;$PASS\r&quot;expect  &quot;]:&quot;send -- &quot;\r&quot;sleep 3expect &quot;]#&quot;   send -- &quot;cd $DIR2\r&quot;expect &quot;]#&quot;send -- &quot;./easyrsa import-req $DIR1/pki/reqs/$USER.req $USER\r&quot; sleep 3expect  &quot;]#&quot;send -- &quot;./easyrsa sign client $USER\r&quot;expect  &quot;details: &quot;send -- &quot;yes\r&quot;expect  &quot;key:&quot;send -- &quot;CA passwd\r&quot;expect  &quot;]#&quot;send -- &quot;exit\r&quot;expect eofEOF#运行expect脚本pass_file=$DIR1/pass_filestat_file=/tmp/openvpn_add_del.logecho &quot;$USER  $PASS&quot; &gt;&gt;$pass_fileuserpass=`tail -1 $pass_file`echo &quot;#..................................#&quot;echo &quot;  OVPN用户账号自动创建中...请稍等   &quot;echo &quot;#..................................#&quot;/usr/bin/expect -f $TMP &gt;$stat_fileif [ $? -ne 0 ];then   echo &quot;用户证书文件创建异常,请检查&quot;fi#拷贝crt/keymkdir -p $DIR1/users/$USERcp $DIR2/pki/issued/$USER.crt $DIR1/users/$USER/cp $DIR1/pki/private/$USER.key $DIR1/users/$USER/echo &quot;#.....用户账号创建完成,详情如下........#&quot;echo &quot;                                        &quot;echo &quot;用户crt/key下载目录：$DIR1/users/$USER&quot;echo &quot;用户证书密码[请牢记]: $userpass&quot;echo &quot;                                        &quot;echo &quot;#......................................#&quot;#写入随机数到文件,用于sync md5变更依据echo &quot;$PASS&quot; &gt;&gt;/tmp/ovpn_create.logrm $TMPfi#吊销用户证书if [ &quot;$AD&quot; == &quot;del&quot; ];thenTMP2=/tmp/ovpn_revoke.eptstat_file2=/tmp/ovpn_revoke.logcat &gt; $TMP2 &lt;&lt; EOF#!/usr/bin/expectspawn ssh -p22 root@192.168.0.11set timeout -1expect &quot;]#&quot;send -- &quot;cd $DIR2\r&quot;expect &quot;]#&quot;send -- &quot;./easyrsa revoke $USER\r&quot;expect &quot;revocation: &quot;send -- &quot;yes\r&quot;expect &quot;key:&quot;send -- &quot;CA passwd\r&quot;expect &quot;]#&quot;send -- &quot;./easyrsa gen-crl\r&quot;expect &quot;key:&quot;send -- &quot;CA passwd\r&quot;expect  &quot;]#&quot;send -- &quot;exit\r&quot;expect eofEOFecho &quot;#..................................#&quot;echo &quot;  OVPN账号自动吊销中...请稍等   &quot;echo &quot;#..................................#&quot;/usr/bin/expect -f $TMP2 &gt;${stat_file2}if [ $? -ne 0 ];then   echo &quot;用户证书吊销出现问题,请检查&quot;fi\cp /etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem /etc/openvpn/num1=`ps -ef|grep &quot;server.conf&quot;|grep -v grep|awk &#39;{print $2}&#39;`kill -9 $num1 &amp;&amp; sleep 2 /usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf  &gt; /tmp/open.log 2&gt;&amp;1 &amp; if [ $? -eq 0 ];then   echo &quot;警告: $USER账号已被注销, 即刻生效!&quot;firm $TMP2fi</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;写个脚本，一键创建用户证书与吊销证书，使用格式：

想要的效果--使用方法
sh vpn.sh add/del username
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;前提：
(1)自己能通过SSH登陆到自己，即ssh免密登陆
(2)提前安装好所需包
   yum install -y expect expect-devel tcl

问题：为什么要这么做？
因为自己的openvpn证书基于easyrsa3的版本进行创建，而此版本并不能使用pkitool的参数来方便快捷的解决免交互的问题【pkitool不支持easyrsa3, 只适用于easyrsa2】，所以只能借助于expect实现免交互
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="openvpn" scheme="https://wuyanteng.github.io/tags/openvpn/"/>
    
      <category term="expect" scheme="https://wuyanteng.github.io/tags/expect/"/>
    
      <category term="easyrsa" scheme="https://wuyanteng.github.io/tags/easyrsa/"/>
    
      <category term="ssh免交互" scheme="https://wuyanteng.github.io/tags/ssh%E5%85%8D%E4%BA%A4%E4%BA%92/"/>
    
      <category term="免交互" scheme="https://wuyanteng.github.io/tags/%E5%85%8D%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>编译安装cmake3和boost1.65</title>
    <link href="https://wuyanteng.github.io/2018/09/07/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85cmake3%E5%92%8Cboost1-65/"/>
    <id>https://wuyanteng.github.io/2018/09/07/编译安装cmake3和boost1-65/</id>
    <published>2018-09-07T12:55:58.000Z</published>
    <updated>2018-09-07T12:58:15.431Z</updated>
    
    <content type="html"><![CDATA[<pre><code>编译安装cmake3和boost1.65版本</code></pre><h4 id="编译安装cmake3-10"><a href="#编译安装cmake3-10" class="headerlink" title="编译安装cmake3.10"></a>编译安装cmake3.10</h4><pre><code>wget https://cmake.org/files/v3.10/cmake-3.10.2.tar.gztar -zxvf cmake-3.10.2.tar.gzcd cmake-3.10.2./bootstrap --prefix=/usrmake &amp;&amp; sudo make installcmake --version</code></pre><a id="more"></a><h4 id="编译安装bootst1-65-1"><a href="#编译安装bootst1-65-1" class="headerlink" title="编译安装bootst1.65.1"></a>编译安装bootst1.65.1</h4><pre><code>wget https://dl.bintray.com/boostorg/release/1.65.1/source/boost_1_65_1.tar.gztar zxvf boost_1_65_1.tar.gz使用bootstrap来生成编译工具b2sudo ./bootstrap.sh  使用b2安装sudo ./b2 install            安装Boost.Build(1)进入&quot;tools/build&quot;目录    cd tools/build(2)使用 bootstrap来生成编译工具b2    sudo ./bootstrap.sh(3)使用b2安装    sudo ./b2 install</code></pre><pre><code>查看boost版本cat /usr/local/include/boost/version.hpp | grep &quot;BOOST_LIB_VERSION&quot;结果如下：//  BOOST_LIB_VERSION must be defined to be the same as BOOST_VERSION#define BOOST_LIB_VERSION &quot;1_65_1&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;编译安装cmake3和boost1.65版本
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;编译安装cmake3-10&quot;&gt;&lt;a href=&quot;#编译安装cmake3-10&quot; class=&quot;headerlink&quot; title=&quot;编译安装cmake3.10&quot;&gt;&lt;/a&gt;编译安装cmake3.10&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;wget https://cmake.org/files/v3.10/cmake-3.10.2.tar.gz
tar -zxvf cmake-3.10.2.tar.gz
cd cmake-3.10.2
./bootstrap --prefix=/usr
make &amp;amp;&amp;amp; sudo make install
cmake --version
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="cmake3" scheme="https://wuyanteng.github.io/tags/cmake3/"/>
    
      <category term="boost" scheme="https://wuyanteng.github.io/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>编译安装openssl</title>
    <link href="https://wuyanteng.github.io/2018/09/07/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85openssl/"/>
    <id>https://wuyanteng.github.io/2018/09/07/编译安装openssl/</id>
    <published>2018-09-07T12:40:12.000Z</published>
    <updated>2018-09-07T12:54:45.547Z</updated>
    
    <content type="html"><![CDATA[<pre><code>本文主要记录openssl编译安装以及lib库的正确加载问题注：如果之前有yum或apt安装过openssl，建议卸载干净再继续。不建议手动删除老版本文件，否则后果可能很严重。</code></pre><a id="more"></a><p>编译安装openssl</p><p>官网：<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">下载</a></p><pre><code>wget https://www.openssl.org/source/openssl-1.0.2p.tar.gztar -xzf openssl-1.0.2p.tar.gzcd openssl-1.0.2p./config --prefix=/usr/local/opensslmake &amp;&amp; make install</code></pre><pre><code>命令软链【或添加环境变量均可】ln -sv /usr/local/openssl/bin/openssl /usr/bin/opensslopenssl version</code></pre><pre><code>打印openssl库文件所依赖的共享库列表ldd /usr/local/openssl/bin/openssl</code></pre><pre><code>加载openssl新版lib库cat /etc/ld.so.conf新增如下行：/usr/local/openssl/lib生效ldconfig /etc/ld.so.conf</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;本文主要记录openssl编译安装以及lib库的正确加载问题

注：如果之前有yum或apt安装过openssl，建议卸载干净再继续。不建议手动删除老版本文件，否则后果可能很严重。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="openssl" scheme="https://wuyanteng.github.io/tags/openssl/"/>
    
      <category term="libssl" scheme="https://wuyanteng.github.io/tags/libssl/"/>
    
      <category term="libcrypto" scheme="https://wuyanteng.github.io/tags/libcrypto/"/>
    
  </entry>
  
  <entry>
    <title>certbot免费证书申请</title>
    <link href="https://wuyanteng.github.io/2018/09/04/certbot%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"/>
    <id>https://wuyanteng.github.io/2018/09/04/certbot免费证书申请/</id>
    <published>2018-09-04T07:02:53.000Z</published>
    <updated>2018-09-04T07:09:15.064Z</updated>
    
    <content type="html"><![CDATA[<pre><code> Let&#39;s Encrypt Certbot生成免费证书</code></pre><p>Certbot官网：<a href="https://certbot.eff.org" target="_blank" rel="noopener">链接</a></p><a id="more"></a><h4 id="安装cerbot"><a href="#安装cerbot" class="headerlink" title="安装cerbot"></a>安装cerbot</h4><pre><code>在certbot官网选择对应的操作系统，安装其提供的方法来安装certbotyum -y install yum-utilsyum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optionalyum install -y certbot</code></pre><h4 id="使用certbot-certonly命令-生成证书公私钥-支持多域名"><a href="#使用certbot-certonly命令-生成证书公私钥-支持多域名" class="headerlink" title="使用certbot certonly命令,生成证书公私钥(支持多域名)"></a>使用certbot certonly命令,生成证书公私钥(支持多域名)</h4><pre><code>生成证书certbot certonly --webroot -w /home/sites/webroot1 -d domain1.com或certbot certonly --webroot -w /home/sites/webroot1 -d domain1.com  -w /home/sites/webroot2/ -d www.domain2.com此过程中 Certbot 会创建随机文件，然后远程验证域名及服务控制权新生成的证书及相关文件，将生成到 /etc/letsencrypt 路径下。</code></pre><pre><code>/etc/letsencrypt目录结构：drwx------ 3 root root 4096 Aug  8 23:11 accountsdrwx------ 3 root root 4096 Aug  8 23:16 archivedrwxr-xr-x 2 root root 4096 Aug  8 23:16 csrdrwx------ 2 root root 4096 Aug  8 23:30 keysdrwx------ 3 root root 4096 Aug  8 23:16 live      #这个是nginx可用证书目录drwxr-xr-x 2 root root 4096 Aug  8 23:25 renewal</code></pre><h4 id="配置Nginx-301跳转并配置SSL区域-指定SSL证书"><a href="#配置Nginx-301跳转并配置SSL区域-指定SSL证书" class="headerlink" title="配置Nginx 301跳转并配置SSL区域(指定SSL证书)"></a>配置Nginx 301跳转并配置SSL区域(指定SSL证书)</h4><pre><code>配置略, 配置完成需要重启nginx服务刷新浏览器访问网页就出现了绿色安全锁图标</code></pre><h4 id="最后为了保证证书长期可用，需要添加crond任务，每月自动续期"><a href="#最后为了保证证书长期可用，需要添加crond任务，每月自动续期" class="headerlink" title="最后为了保证证书长期可用，需要添加crond任务，每月自动续期"></a>最后为了保证证书长期可用，需要添加crond任务，每月自动续期</h4><pre><code>crontab -e# 输入* * * */1 * /usr/bin/certbot renew 1&gt;&gt; /dev/null 2&gt;&amp;1</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre><code>(1) Let&#39;s Encrypt 是单域绑定， 虽然支持多域名，但是不支持泛域绑定。(2) Let&#39;s Encrypt 需要每90天续期,请自行斟酌(3) 不支持IP地址绑定,必须指定域名</code></pre><p>参考：<a href="https://laravel-china.org/topics/2525/using-certbot-lets-encrypt-small-step-run-towards-https" target="_blank" rel="noopener">Laravel China</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt; Let&amp;#39;s Encrypt Certbot生成免费证书
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Certbot官网：&lt;a href=&quot;https://certbot.eff.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="HTTPS" scheme="https://wuyanteng.github.io/tags/HTTPS/"/>
    
      <category term="SSL" scheme="https://wuyanteng.github.io/tags/SSL/"/>
    
      <category term="免费SSL证书" scheme="https://wuyanteng.github.io/tags/%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6/"/>
    
      <category term="crt" scheme="https://wuyanteng.github.io/tags/crt/"/>
    
      <category term="pem" scheme="https://wuyanteng.github.io/tags/pem/"/>
    
      <category term="certbot" scheme="https://wuyanteng.github.io/tags/certbot/"/>
    
      <category term="Let&#39;s Encrypt" scheme="https://wuyanteng.github.io/tags/Let-s-Encrypt/"/>
    
      <category term="SSL证书自动续签" scheme="https://wuyanteng.github.io/tags/SSL%E8%AF%81%E4%B9%A6%E8%87%AA%E5%8A%A8%E7%BB%AD%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>基于OpenSSL自建CA和颁发SSL证书</title>
    <link href="https://wuyanteng.github.io/2018/09/03/%E5%9F%BA%E4%BA%8EOpenSSL%E8%87%AA%E5%BB%BACA%E5%92%8C%E9%A2%81%E5%8F%91SSL%E8%AF%81%E4%B9%A6/"/>
    <id>https://wuyanteng.github.io/2018/09/03/基于OpenSSL自建CA和颁发SSL证书/</id>
    <published>2018-09-03T07:46:16.000Z</published>
    <updated>2018-09-04T04:35:10.332Z</updated>
    
    <content type="html"><![CDATA[<h5 id="编译安装openssl"><a href="#编译安装openssl" class="headerlink" title="编译安装openssl"></a>编译安装openssl</h5><pre><code>官网：https://www.openssl.org/source/</code></pre><pre><code>wget https://www.openssl.org/source/openssl-1.1.1-pre9.tar.gztar -zxvf openssl-1.1.1-pre9.tar.gz cd openssl-1.1.1-pre9/./configmakemake testmake install</code></pre><a id="more"></a><pre><code>whereis opensslecho &quot;export LD_LIBRARY_PATH=/usr/local/lib&quot; &gt;&gt;/etc/profilesource /etc/profileroot@lohost:~# openssl versionOpenSSL 1.1.1-pre9 (beta) 21 Aug 2018</code></pre><h2 id="颁发证书"><a href="#颁发证书" class="headerlink" title="颁发证书"></a>颁发证书</h2><h5 id="生成根密钥"><a href="#生成根密钥" class="headerlink" title="生成根密钥"></a>生成根密钥</h5><pre><code>CA要给别人颁发证书，首先自己得有一个作为根证书cd /data/caopenssl genrsa -out cakey.pem 4096</code></pre><h5 id="生成根证书"><a href="#生成根证书" class="headerlink" title="生成根证书"></a>生成根证书</h5><pre><code>使用req命令生成自签证书：openssl req -new -x509 -key cakey.pem -out cacert.pem会提示输入一些信息：Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:beijingLocality Name (eg, city) []:BJOrganization Name (eg, company) [Internet Widgits Pty Ltd]:AloneOrganizational Unit Name (eg, section) []:AloneCommon Name (e.g. server FQDN or YOUR name) []:xx.xx.xx.xx     Email Address []:xxx@gmail.com</code></pre><h5 id="以上CA证书创建完毕-下面来给程序颁发SSL证书"><a href="#以上CA证书创建完毕-下面来给程序颁发SSL证书" class="headerlink" title="以上CA证书创建完毕,下面来给程序颁发SSL证书"></a>以上CA证书创建完毕,下面来给程序颁发SSL证书</h5><pre><code>mkdir -p /data/ca/sslcd /data/ca/ssl#生成ssl密钥openssl genrsa -out server.key 4096#生成csropenssl req -new -key server.key -out server.csr同样会提示输入一些内容，除了Commone Name字段一定要是你要授予证书的服务器域名或主机名，challenge password不填。#最后使用CA签署证书openssl x509 -req -in /data/ca/ssl/server.csr -CA /data/ca/cacert.pem -CAkey /data/ca/cakey.pem -CAcreateserial -out /data/ca/ssl/server.crt</code></pre><pre><code>生成以后，/data/ca/ssl目录下的crt和key文件就可以被程序使用了</code></pre><h2 id="无交互SSL证书生成"><a href="#无交互SSL证书生成" class="headerlink" title="无交互SSL证书生成"></a>无交互SSL证书生成</h2><pre><code>适用场景：自签名SSL证书安全性大大降低，有被攻击风险，故可通过如下命令编写脚本定期生成并更换到程序中来保障安全性</code></pre><pre><code>openssl genrsa -des3 -passout pass:huawei -out ca.key 4096openssl req -new -passin pass:huawei -key ca.key -out ca.csr -subj &quot;/C=HK/ST=HongKong/L=HongKong/O=foundation/OU=FD/CN=example.com/emailAddress=fd@gmail.com&quot;openssl x509 -sha256 -req -in ca.csr -out ca.crt -signkey ca.key -passin pass:huawei -days 30</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;编译安装openssl&quot;&gt;&lt;a href=&quot;#编译安装openssl&quot; class=&quot;headerlink&quot; title=&quot;编译安装openssl&quot;&gt;&lt;/a&gt;编译安装openssl&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;官网：https://www.openssl.org/source/
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;wget https://www.openssl.org/source/openssl-1.1.1-pre9.tar.gz
tar -zxvf openssl-1.1.1-pre9.tar.gz 
cd openssl-1.1.1-pre9/
./config
make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="pem" scheme="https://wuyanteng.github.io/tags/pem/"/>
    
      <category term="OpenSSL" scheme="https://wuyanteng.github.io/tags/OpenSSL/"/>
    
      <category term="CA" scheme="https://wuyanteng.github.io/tags/CA/"/>
    
      <category term="SSL证书" scheme="https://wuyanteng.github.io/tags/SSL%E8%AF%81%E4%B9%A6/"/>
    
      <category term="csr" scheme="https://wuyanteng.github.io/tags/csr/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本中嵌入ssh无密钥登陆</title>
    <link href="https://wuyanteng.github.io/2018/08/31/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%B5%8C%E5%85%A5ssh%E6%97%A0%E5%AF%86%E9%92%A5%E7%99%BB%E9%99%86/"/>
    <id>https://wuyanteng.github.io/2018/08/31/shell脚本中嵌入ssh无密钥登陆/</id>
    <published>2018-08-31T06:17:21.000Z</published>
    <updated>2018-08-31T07:36:19.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><pre><code>有这样一个生产场景: zabbix-agent只在server1服务器有安装并提供监控服务，想使用这一台server1服务器通过编写shell脚本去监控其他服务器运行的服务，比如：服务运行状态、log日志统计并发等等。如何做？</code></pre><a id="more"></a><p>场景分析</p><pre><code>server1需要与其他server创建SSH互信，shell中通过ssh来远程登陆到其他服务器来执行命令。那么问题来了？命令执行完成，如何在shell中退出并将命令执行后的结果返回到server1中，并让zabbix去监控呢？</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h4 id="将server1的密钥上传到101服务器实现ssh互信"><a href="#将server1的密钥上传到101服务器实现ssh互信" class="headerlink" title="将server1的密钥上传到101服务器实现ssh互信"></a>将server1的密钥上传到101服务器实现ssh互信</h4><pre><code>首先在server1以root命令生成SSH密钥[root@web01 ~]# ssh-keygen -t dsaGenerating public/private dsa key pair.Enter file in which to save the key (/root/.ssh/id_dsa):Created directory &#39;/root/.ssh&#39;.Enter passphrase (empty for no passphrase):Enter same passphrase again: Your identification has been saved in /root/.ssh/id_dsa.Your public key has been saved in /root/.ssh/id_dsa.pub.The key fingerprint is:25:93:78:e9:01:2d:82:db:cb:0b:34:f7:0c:a9:1b:11 root@web01The key&#39;s randomart image is:+--[ DSA 1024]----+|   .  ..         ||  E . .o.o       ||   + o..B .      ||  = =  o =       || . * =  S        ||  + o o          ||   + .           ||  . .            ||                 |+-----------------+#检查密钥文件[root@web01 ~]# ll /root/.ssh/total 8-rw------- 1 root root 736 2017-08-06 15:17 id_dsa-rw-r--r-- 1 root root 600 2017-08-06 15:17 id_dsa.pub#将生成的.pub密钥上传到所需的服务器上（比如：101），实现ssh免密登陆 ssh-copy-id -i ~/.ssh/id_dsa.pub root@10.10.10.101#确认远端101服务器密钥上传成功[root@101 ~]# ll /root/.ssh/total 8-rw------- 1 root root 600 2017-08-06 15:29 authorized_keys-rw-r--r-- 1 root root 393 2017-08-05 11:03 known_hosts#在server1服务器无密码远程登录测试[root@web01 ~]# ssh root@10.10.10.101注意：如果远程登录失败,需要配置ssh允许root登录，并重启ssh服务。</code></pre><h4 id="在101服务器生成密钥上传到server1服务器，实现反向ssh互信"><a href="#在101服务器生成密钥上传到server1服务器，实现反向ssh互信" class="headerlink" title="在101服务器生成密钥上传到server1服务器，实现反向ssh互信"></a>在101服务器生成密钥上传到server1服务器，实现反向ssh互信</h4><pre><code>在101服务器，生成dsa密钥，并上传到server1服务器，实现互信。</code></pre><h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h4><pre><code>接下来就可以愉快的在server1编写所需的shell脚本了，范例如下：[root@web01 ~]# cat /opt/check_service.sh</code></pre><pre><code>#!/bin/bashDNS_IP=10.0.0.101FILE1=/var/log/dns.logFILE2=/tmp/pri_dns.logNOW_UNIX=`date +%s`UNIX=`expr ${NOW_UNIX} - 60` #本地文件清理rm -f $FILE2#SSH DNS并发信息获取ssh root@${DNS_IP} &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF    egrep &quot;${UNIX}&quot; $FILE1|wc -l &gt;$FILE2    scp -r $FILE2 root@server1:/tmp/     exitEOF</code></pre><pre><code>脚本逻辑：(1)定义所需环境变量(2)通过如下方式在shell中嵌入SSH远程登录并在远程服务器执行命令   ssh root@10.10.10.101 &gt; /dev/null 2&gt;&amp;1 &lt;&lt; EOF      comm1...      comm2...      comm3...      exit   EOF在上面的例子中，远端执行完毕后，通过scp方式，将结果传输到server1服务器的/tmp目录下，最后再编写zabbix自定义key来实现监控。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;有这样一个生产场景: zabbix-agent只在server1服务器有安装并提供监控服务，想使用这一台server1服务器通过编写shell脚本去监控其他服务器运行的服务，比如：服务运行状态、log日志统计并发等等。如何做？
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://wuyanteng.github.io/tags/ssh/"/>
    
      <category term="shell脚本" scheme="https://wuyanteng.github.io/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>rsync限速实例</title>
    <link href="https://wuyanteng.github.io/2018/08/31/rsync%E9%99%90%E9%80%9F%E5%AE%9E%E4%BE%8B/"/>
    <id>https://wuyanteng.github.io/2018/08/31/rsync限速实例/</id>
    <published>2018-08-31T03:54:35.000Z</published>
    <updated>2018-08-31T04:02:31.533Z</updated>
    
    <content type="html"><![CDATA[<h4 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h4><pre><code>生产环境有这样的需求，需要跨机房传输TB级文件，但又不想其带宽占用的太厉害而影响了其他业务，这时候就需要使用rsync的限速功能了，简单扯下</code></pre><a id="more"></a><h4 id="rsync限速参数-–bwlimit"><a href="#rsync限速参数-–bwlimit" class="headerlink" title="rsync限速参数: –bwlimit"></a>rsync限速参数: –bwlimit</h4><pre><code>--bwlimit=100   单位：KBPS, 100意思是 传输速度限制100KB/s，也就是限速大概1MB的速度。再比如：想要限速50MB的速度，那么应该设置为 --bwlimit=5000</code></pre><h4 id="rsync限速传输命令"><a href="#rsync限速传输命令" class="headerlink" title="rsync限速传输命令"></a>rsync限速传输命令</h4><pre><code>参考：time rsync --port 873 -ravPz ./2018* rsync@X.X.X.X::logfile/2018/H5/</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;场景介绍&quot;&gt;&lt;a href=&quot;#场景介绍&quot; class=&quot;headerlink&quot; title=&quot;场景介绍&quot;&gt;&lt;/a&gt;场景介绍&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;生产环境有这样的需求，需要跨机房传输TB级文件，但又不想其带宽占用的太厉害而影响了其他业务，这时候就需要使用rsync的限速功能了，简单扯下
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="rsync" scheme="https://wuyanteng.github.io/tags/rsync/"/>
    
      <category term="rsync限速" scheme="https://wuyanteng.github.io/tags/rsync%E9%99%90%E9%80%9F/"/>
    
      <category term="bwlimit" scheme="https://wuyanteng.github.io/tags/bwlimit/"/>
    
  </entry>
  
  <entry>
    <title>shell数组</title>
    <link href="https://wuyanteng.github.io/2018/08/28/shell%E6%95%B0%E7%BB%84/"/>
    <id>https://wuyanteng.github.io/2018/08/28/shell数组/</id>
    <published>2018-08-28T09:24:20.000Z</published>
    <updated>2018-08-29T10:44:38.462Z</updated>
    
    <content type="html"><![CDATA[<pre><code>shell数组</code></pre><a id="more"></a><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><pre><code>在Shell中，用括号来表示数组, 数组元素使用“空格” 分隔开，如：#数组定义name=(tom jerry jackson free gary)  #读取数组读取数组元素值的一般格式是：${数组名[下标]}，注：下标是从0开始的例如：echo ${name[0]}       #获取第1个元素值echo ${name[1]}       #获取第2个元素值echo ${name[2]}       #获取第3个元素值使用“*”或“@”符号可以获取数组中的所有元素echo ${name=[*]}echo $(name=[@])</code></pre><h4 id="数组删除"><a href="#数组删除" class="headerlink" title="数组删除"></a>数组删除</h4><pre><code>直接通过：&quot;unset 数组[下标]&quot; 可以清除相应的元素；若不带下标，则清除整个数据。 只清除第1个元素a=(1 2 3 4 5)unset a[0]echo ${a[*]}2 3 4 5清除整个数组元素unset a </code></pre><h4 id="数组之分片"><a href="#数组之分片" class="headerlink" title="数组之分片"></a>数组之分片</h4><pre><code>直接通过 &quot;${数组名[@或*]:起始位置:长度}&quot; 切片原先数组,然后返回字符串。如下：a=(1 2 3 4 5)       #定义数组echo ${a[@]:0:3}    #分片 1 2 3echo ${a[@]:1:4}2 3 4 5如果加上”()”，将得到切片数组，下面例子中，c就是一个新数据。c=(${a[@]:1:4})echo ${#c[@]}      #统计新数据c的元素总个数4echo ${c[*]}       #重新打印c的新数据数组 2 3 4 5  </code></pre><h4 id="数组之替换"><a href="#数组之替换" class="headerlink" title="数组之替换"></a>数组之替换</h4><pre><code>调用方法是：&quot;${数组名[@或*]/查找字符/替换字符}&quot; 注：该操作不会改变原先数组内容，如果需要修改，可以看下面例子，重新定义数据。# name=(gary tom jerry jackson)# echo ${name[@]/jackson/green}   #查找字符jackson，替换字符为greengary tom jerry green# echo ${name[@]}                 #可以看到，数组替换不会改变原数组的内容gary tom jerry jackson# name2=(${name[@]/jackson/green})  #但可以进行重新赋值来实现数组替换# echo ${name2[@]}gary tom jerry green</code></pre><pre><code>关于数组相关shell案例，有时间补充。。。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;shell数组
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="数组" scheme="https://wuyanteng.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>OpenVPN编译安装部署</title>
    <link href="https://wuyanteng.github.io/2018/08/23/OpenVPN%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/08/23/OpenVPN编译安装部署/</id>
    <published>2018-08-23T01:43:46.000Z</published>
    <updated>2018-08-23T02:30:24.380Z</updated>
    
    <content type="html"><![CDATA[<pre><code>整理下OpenVPN编译安装+部署过程，尤其是向客户端push路由、证书创建与吊销等相关技术。最后还会说明下客户端如何高可用实现逻辑负载均衡。</code></pre><a id="more"></a><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><pre><code>启动并清空iptables规则  # iptables -F  # service iptables save  # service iptables restart关闭SELINUX  # setenforce 0  # vi /etc/sysconfig/selinux    修改为SELINUX=disabled开启服务器端路由转发功能  # vi /etc/sysctl.conf    改为 net.ipv4.ip_forward = 1  # sysctl -p设置nat转发（注：添加正确的OpenVPN客户端网络地址）  # iptables -t nat -A POSTROUTING -s 172.101.101.0/24 -o eth0 -j MASQUERADE  注：如果是VPS配置openvpn，需要把上面的“-o eth0”参数取消，否则无法上网。设置iptables开放openvpn端口：  # iptables -A INPUT -p TCP --dport 1194 -j ACCEPT  # service iptables save  # service iptables restart时间同步(重要)：  # yum install ntp  # ntpdate asia.pool.ntp.org  # vi /etc/rc.d/rc.local    添加 /usr/bin/ntpdate asia.pool.ntp.org安装编译依赖库  # yum install -y openssl openssl-devel lzo lzo-devel pam pam-devel automake pkgconfig gcc gcc++</code></pre><h5 id="下载openvpn：-官网"><a href="#下载openvpn：-官网" class="headerlink" title="下载openvpn： 官网"></a>下载openvpn： <a href="https://openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="noopener">官网</a></h5><pre><code># tar -zxvf openvpn.2.3.10.tar.gz &amp;&amp; cd openvpn.2.3.10# ./configure --prefix=/usr/local/openvpn# make &amp;&amp; make install</code></pre><pre><code>创建/etc/openvpn目录# mkdir -p /etc/openvpn# cp -rf /root/openvpn.2.3.10/sample /etc/openvpn# cp /etc/openvpn/sample/sample-config-files/server.conf /etc/openvpn</code></pre><h5 id="安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3"><a href="#安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3" class="headerlink" title="安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3"></a>安装openvpn最新的easy-rsa，该包用来制作ca证书，服务端证书，客户端证书。最新的为easy-rsa3</h5><pre><code># wget -c https://github.com/OpenVPN/easy-rsa/archive/master.zip# unzip master.zip# mv easy-ras-master easy-rsa# cp -rf easy-rsa /etc/openvpn# cd /etc/openvpn/easy-rsa/easyrsa3# cp vars.example vars# chmod +x vars修改Vars文件内的如下字段：set_var EASYRSA_REQ_COUNTRY &quot;CN&quot; //根据自己情况更改set_var EASYRSA_REQ_PROVINCE &quot;Beijing&quot;set_var EASYRSA_REQ_CITY &quot;Tong&quot;set_var EASYRSA_REQ_ORG &quot;qingliu Certificate&quot;set_var EASYRSA_REQ_EMAIL &quot;shuiqingliu14@gmail.com&quot;set_var EASYRSA_REQ_OU &quot;My OpenVPN&quot;创建服务端证书及KeyA. 进入/etc/openvpn/easy-rsa/easyrsa3/目录初始化：   ./easyrsa init-pkiB. 创建根证书   ./easyrsa build-ca   B1. 根据提示输入PEM密码，密码为：P**4 【务必要记住改密码，否则以后不能为证书签名】   B2. 还需要输入common name 通用名，配置为Moxiu。  C. 创建服务器端证书    ./easyrsa gen-req server nopassD. 签约服务端证书   ./easyrsa sign server server   根据提示输入”yes ” ,再输入刚才设置的PEM密码D. 创建Diffie-Hellman，确保key穿越不安全网络的命令   ./easyrsa gen-dh</code></pre><h5 id="创建客户端证书"><a href="#创建客户端证书" class="headerlink" title="创建客户端证书"></a>创建客户端证书</h5><pre><code>A. 在/root目录下，创建openvpn_users文件夹来存储所有客户端证书文件。   # mkdir  /root/openvpn_users &amp;&amp; cd openvpn_users   # cp -R /root/easy-rsa  ./   # cd easy-rsa/easyrsa3/   # cp vars.example  varsB. 初始化   # ./easyrsa init-pkiC. 创建客户端key以及生成证书（记住生成是自己输入的密码）   # ./easyrsa  gen-req  test   //名字自己定义D. 切换到Server证书目录下，将得到的test.req导入，然后签约证书# cd  /etc/openvpn/easy-rsa/easyrsa3/# ./easyrsa  import-req /root/openvpn_users/easy-rsa/easyrsa3/pki/reqs/test.req testD. 用户签约，根据提示输入服务端CA密码   # ./easyrsa sign client testE. 这一步很重要，看看生成的全部文件    (1)Server:  [目录：/etc/openvpn/easy-rsa/文件夹]    /etc/openvpn/easy-rsa/easyrsa3/pki/ca.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/reqs/server.req    /etc/openvpn/easy-rsa/easyrsa3/pki/reqs/test.req    /etc/openvpn/easy-rsa/easyrsa3/pki/private/ca.key    /etc/openvpn/easy-rsa/easyrsa3/pki/private/server.key    /etc/openvpn/easy-rsa/easyrsa3/pki/issued/server.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/issued/test.crt    /etc/openvpn/easy-rsa/easyrsa3/pki/dh.pem    (2) Client: [目录：/etc/openvpn/clients/easy-rsa/文件夹]      /root/openvpn_users/easy-rsa/easyrsa3/pki/private/test.key      /root/openvpn_users/easy-rsa/easyrsa3/pki/reqs/test.req         这个文件被我们导入到了服务端文件所以那里也有F. 拷贝服务器证书文件放到/etc/openvpn目录   进入/etc/openvpn/easy-rsa/easyrsa3目录   #cp pki/ca.crt  /etc/openvpn   #cp pki/private/server.key  /etc/openvpn   #cp pki/issued/server.crt  /etc/openvpn   #cp pki/dh.pem  /etc/openvpnG. Client证书（集中放到一个文件夹下，给VPN用户使用）   # mkdir /root/users   # mkdir /root/users/test //内部文件夹以姓名全拼命名，方便下载这些密钥文件   # cd /root/users/test/   # cp /etc/openvpn/ca.crt ./              拷贝CA证书到test目录下   # cp /etc/openvpn/easy-rsa/easyrsa3/pki/issued/test.crt ./          拷贝（服务端路径）用户crt文件   # cp /root/openvpn_users/easy-rsa/easyrsa3/pki/private/test.key ./　　拷贝（客户端路径）用户key文件   查看   [root@OpenVPN test]# ls   ca.crt  test.crt  test.key</code></pre><h5 id="生成ta-key【为了安全】"><a href="#生成ta-key【为了安全】" class="headerlink" title="生成ta.key【为了安全】"></a>生成ta.key【为了安全】</h5><pre><code>配置服务之前，需要生成配置文件需要的ta.key文件，并将ta.key放入/etc/openvpn目录下【注：客户端连接也要使用有此文件】# cd /root/# /usr/local/openvpn/sbin/openvpn --genkey --secret ta.key# ls# cp  ta.key  /etc/openvpn/# cp ta.key /root/users/test</code></pre><h5 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h5><pre><code># vi /etc/openvpn/server.conf       local 10.0.8.28     #申明本机使用的IP地址，也可以不说明     port 1194     #申明使用的端口，默认1194     proto tcp     #申明使用的协议，默认使用UDP，如果使用HTTP proxy，必须使用TCP协议     dev tun     #申明使用的设备可选tap和tun，tap是二层设备，支持链路层协议。     ca /etc/openvpn/ca.crt     #指定ca证书的路径     cert /etc/openvpn/server.crt     #指定server.crt路径     key /etc/openvpn/server.key     #指定server.key路径     dh /etc/openvpn/dh.pem     #指定dh.pem路径     server 172.101.101.0 255.255.255.0     #为VPN客户端指定分配的网络地址（自己根据规划分配）     ifconfig-pool-persist ipp.txt     push &quot;redirect-gateway&quot;           #向客户端push网关【push 网关后，客户端通过远程网络上网，作用类似NAT伪装；如果不想这么做，就需要向客户端直接push路由--后边故障解决部分有介绍】     push &quot;dhcp-option DNS 114.114.114.114&quot;  #向客户端push DNS     client-to-client  #让客户端彼此可以互相访问     tls-auth   /etc/openvpn/ta.key 0       #注：此处客户端配置文件中该参数需要改为 tls-auth ta.key 1     comp-lzo     auth md5      cipher AES-256-CBC      max-clients 100      keepalive 10 120      persist-key      persist-tun      status openvpn-status.log      verb 3</code></pre><h5 id="启动openvpn"><a href="#启动openvpn" class="headerlink" title="启动openvpn"></a>启动openvpn</h5><pre><code>/usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &amp;加入开机启动项【手动创建开机启动脚本文件】# vi  /etc/init.d/openvpn 输入以下内容，保存：#!/bin/bash# chkconfig: 2345 67 33# description: ntpd is the NTPv4 daemon.nohup /usr/local/openvpn/sbin/openvpn --config /etc/openvpn/server.conf &gt; /tmp/open.log 2&gt;&amp;1 &amp;</code></pre><pre><code># chmod  755  openvpn             //添加执行权限# chkconfig --add openvpn# chkconfig openvpn on           //加入开机启动项# netstat -ln                   //查看端口是否正确启动</code></pre><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><pre><code>此处以windows客户端为例：安装Openvpn客户端并以管理员身份运行</code></pre><p>配置创建client.ovpn文件</p><pre><code>clientdev tunproto udpremote 10.0.8.28   #主要这里修改成自己server ipresolv-retry infinitenobindpersist-keypersist-tunca ca.crt               #这里需要证书cert test.crtkey  test.keyauth md5cipher AES-256-CBCtls-auth ta.key 1comp-lzoverb 3</code></pre><p>故障处理</p><pre><code>故障描述：运行openvpn客户端后，VPN连接正常，但无法上网和Ping公司内网</code></pre><pre><code>解决方法：  1. 打开Openvpn服务端配置文件   # vi /etc/openvpn/server.conf  添加如下静态路由(填写服务器这边的网络)  push &quot;route 10.0.8.0 255.255.254.0 net_gateway&quot;  push &quot;route 10.0.0.0 255.255.254.0 net_gateway&quot;  #push &quot;route 10.0.16.0 255.255.248.0 net_gateway&quot;  push &quot;route 0.0.0.0 0.0.0.0 net_gateway&quot;重启openvpn服务，再进行测试即可 </code></pre><h5 id="证书吊销"><a href="#证书吊销" class="headerlink" title="证书吊销"></a>证书吊销</h5><pre><code>OpenVPN证书吊销# cd  /etc/openvpn/easy-rsa/easyrsa3/# ./easyrsa revoke  clientName              //name输入需要注销的用户名称# ./easyrsa  gen-crl此时会在/etc/openvpn/easy-rsa/easyrsa3/pki目录下生成crl.pem文件# cp  ./etc/openvpn/easy-rsa/easyrsa3/pki/crl.pem    /etc/openvpn# cd   /etc/openvpn# vim  server.conf添加如下内容：crl-verify  /etc/openvpn/crl.pem重启OpenVPN服务,使配置生效</code></pre><h6 id="关于客户端逻辑负载均衡"><a href="#关于客户端逻辑负载均衡" class="headerlink" title="关于客户端逻辑负载均衡"></a>关于客户端逻辑负载均衡</h6><pre><code>为什么说客户端负载均衡是逻辑上的呢？实现逻辑是这样：部署多台独立的openvpn服务端，然后客户端配置多台server ip地址，客户端每次连接都会选择不同的server进行连接，如果失败，则自动连接下一个server。客户端轮询部分配置如下：remote server1 1194remote server2 1194remote server3 1194remote-randomresolv-retry 2那么问题来了，如何保证多台server的配置文件和用户key能保持一致呢？解决方案：以其中一台server作为逻辑主server，也就是说所有的keys用户创建，都只在这个主server上进行，然后，将/etc/openvpn目录下的所有文件【注意：不包括server.conf主配置文件】覆盖到server2、server3上面【注意：不要覆盖server2和server3的主配置文件: server.conf,否则你就呵呵吧】，并重启他们的openvpn服务即可。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;整理下OpenVPN编译安装+部署过程，尤其是向客户端push路由、证书创建与吊销等相关技术。最后还会说明下客户端如何高可用实现逻辑负载均衡。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ovpn" scheme="https://wuyanteng.github.io/tags/ovpn/"/>
    
      <category term="openvpn" scheme="https://wuyanteng.github.io/tags/openvpn/"/>
    
      <category term="vpn" scheme="https://wuyanteng.github.io/tags/vpn/"/>
    
      <category term="easy-rsa3" scheme="https://wuyanteng.github.io/tags/easy-rsa3/"/>
    
  </entry>
  
  <entry>
    <title>Bind9主从同步部署</title>
    <link href="https://wuyanteng.github.io/2018/08/17/Bind9%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2/"/>
    <id>https://wuyanteng.github.io/2018/08/17/Bind9主从同步部署/</id>
    <published>2018-08-17T09:20:09.000Z</published>
    <updated>2018-08-22T03:12:34.726Z</updated>
    
    <content type="html"><![CDATA[<pre><code>之前没有独立写过Bind主从同步，只有与LVS相结合的文章，故今天给补充完善。本次测试版本：bind-9.10.8-P1.tar.gz     </code></pre><a id="more"></a><h2 id="部署Bind主DNS"><a href="#部署Bind主DNS" class="headerlink" title="部署Bind主DNS"></a>部署Bind主DNS</h2><p>编译安装</p><pre><code>tar -zxvf bind-9.10.8-P1.tar.gzcd  bind-9.10.8-P1mkdir -p /etc/bind./configure --enable-threads --with-libtool --with-ecdsa --prefix=/usr/local/web2016/bind  \     --sysconfdir=/etc/bindmakemake install</code></pre><pre><code>编译参数，释义：--enable-threads    #开启多线程支持--with-libtool      #使用GNU libtool--with-ecdsa        #开启ECDSA算法支持</code></pre><p>命令软链</p><pre><code>ln -sv /usr/local/web2016/bind/sbin/* /sbin/</code></pre><p>创建傀儡用户named</p><pre><code>useradd -r -m  -d /var/named -s /sbin/nologin named</code></pre><p>创建rndc key</p><pre><code>伪造数据，便于生成keyecho &quot;1111111111qqqqqqqqqqqqwwwwwwwwwwwwwwddddddddddffffffhjFD21AAAAAAAAAAA&quot; &gt;/root/random生成keyrndc-confgen -r /root/random -s 127.0.0.1 -p 953 &gt;/etc/bind/rndc.conf</code></pre><p>手动创建named.conf</p><pre><code>vim /etc/bind/named.conf</code></pre><h4 id="named-conf配置文件"><a href="#named-conf配置文件" class="headerlink" title="named.conf配置文件"></a>named.conf配置文件</h4><pre><code>options {   listen-on port 53 { any; };      //定义DNS监听在哪个端口上   directory &quot;/etc/bind/zone&quot;;   //指定DNS区域文件存放目录   pid-file &quot;/etc/bind/var/named.pid&quot;;   //指定named进程pid文件路径   allow-query { any; };          //允许哪些主机可以使用该DNS来解析   Dump-file &quot;/etc/bind/var/binddump.db&quot;;     //缓存转储位置   Statistics-file &quot;/etc/bind/stats/named_stats&quot;;   //记录统计信息的文件   zone-statistics yes;  //收集在服务器所有域的统计数据, 这些统计数据可以通过使用rndc stats来访问   memstatistics-file &quot;/etc/bind/stats/mem_stats&quot;;     //记录内存使用的统计信息   empty-zones-enable yes;      forwarders {114.114.114.114;8.8.8.8;};   //定义上游DNS[需要配置root hint顶级域]};key &quot;rndc-key&quot; {               //注：这个key部分是通过rndc-confgen命令生成的配置，贴过来        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};controls {              //配置rndc权限与端口       inet 127.0.0.1 port 953       allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };};logging {  channel warning {        //warnning可以改为default_debug（默认）。     file &quot;/var/log/named/named.log&quot; versions 10 size 10m;    //日志文件路径/版本/大小     severity warning;     //如果warnning改为default_debug后，此处可以改为severity dynamic     print-category yes;   //日志中是否需要写入日志类别     print-severity yes;   //日志中是否需要写入消息级别     print-time yes;       //日志中是否需要写入时间    };     channel general_dns {               //绑定其他log channel通道，以下保持默认即可。     file &quot;/var/log/named/named2.log&quot; versions 10 size 100m;     severity info;         print-category yes;      print-severity yes;     print-time yes;    };  category default {    warning;  };  category queries {    general_dns;  };};include &quot;/etc/bind/view/*.conf&quot;;   #加载Bind视图文件</code></pre><p>创建相关目录并授权</p><pre><code>mkdir -p /etc/bind/zonemkdir -p /etc/bind/varmkdir -p /etc/bind/statsmkdir -p /etc/bind/viewmkdir -p /var/log/namedwget https://www.internic.net/domain/named.rootchown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>配置Bind视图</p><pre><code>vim /etc/bind/view/view.conf</code></pre><pre><code>view &quot;View&quot; {                  //配置bind视图功能  zone &quot;test.org&quot; {        type    master;             file    &quot;test.org.zone&quot;;    //定义zone区域文件        allow-transfer {            //允许本区域传输给特定的从DNS服务器                10.0.10.102;      //slave IP,可以存在多个slave        };        notify  yes;          also-notify {               10.0.10.102;        };  };  zone &quot;10.0.10.in-addr.arpa&quot; {     //定义反向zone区域文件        type    master;        file    &quot;10.0.10.zone&quot;;             allow-transfer {               //允许本区域传输给特定的从DNS服务器                10.0.10.102;         //slave IP,可以存在多个slave                       };        notify  yes;        also-notify {                10.0.10.102;        };   };   zone &quot;.&quot; in {         type hint;         file &quot;/etc/bind/named.root&quot;   }};注：参数释义(1)区域类型有type：｛hint（根）| master（主dns）| slave（辅助DNS）| forward（转发）｝(2)notify如果是yes（默认），当一个授权的服务器修改了一个域后，DNS NOTIFY信息被发送给列在also-notify选项中的服务器。</code></pre><p>正向区域和反向区域文件配置-略</p><pre><code>需要在zone子目录定义，因为配置文件zone目录是这么写的zone配置文件语法检查named-checkzone test.org /etc/bind/zone/test.org.zone </code></pre><p>最后再次修改目录权限</p><pre><code>chown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>启动服务</p><pre><code>named.conf配置文件检查named-checkconf /etc/bind/named.conf</code></pre><p>named启动脚本[建议使用supervisor]</p><pre><code>/etc/init.d/named</code></pre><pre><code>#!/bin/bash # named a network name service. # chkconfig: 345 35 75 # description: a name serverif [ `id -u` -ne 0 ];then   echo &quot;ERROR:For bind to port 53,must run as root.&quot;    exit 1ficase &quot;$1&quot; instart)        if [ -x /usr/sbin/named ]; then  /usr/sbin/named -c /etc/bind/named.conf -u named &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server started&#39;         fi      ;;stop)       kill `cat /etc/named/var/named.pid` &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server stopped&#39;        ;;restart)       echo .        echo &quot;Restart BIND9.10 server&quot;        $0 stop       sleep 10       $0 start       ;;reload)      /usr/sbin/rndc reload      ;;status)     /usr/sbin/rndc status     ;;*)     echo &quot;$0 start | stop | restart |reload |status&quot;      ;;esac</code></pre><pre><code>chmod  755  /etc/init.d/namedchkconfig --add namedchkconfig named on/etc/init.d/named start /etc/init.d/named status</code></pre><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><pre><code>[root@ns1 ~]# netstat -lntup|grep 53tcp    0     0 10.0.10.101:53          0.0.0.0:*       LISTEN      2361/named          tcp    0     0 127.0.0.1:53            0.0.0.0:*       LISTEN      2361/named          tcp    0     0 127.0.0.1:953           0.0.0.0:*       LISTEN      2361/named          tcp6   0     0 :::53                   :::*            LISTEN      2361/named          udp    0     0 10.0.10.101:53          0.0.0.0:*      2361/named          udp    0     0 127.0.0.1:53            0.0.0.0:*      2361/named          udp6   0     0 :::53                   :::*           2361/named</code></pre><h4 id="日常管理"><a href="#日常管理" class="headerlink" title="日常管理"></a>日常管理</h4><pre><code>/etc/init.d/named start 启动服务rndc status  查看服务运行情况rndc reload  重新加载区域文件rndc stop    停止DNS服务</code></pre><h2 id="部署bind从DNS"><a href="#部署bind从DNS" class="headerlink" title="部署bind从DNS"></a>部署bind从DNS</h2><p>编译安装</p><pre><code>略</code></pre><p>主配置文件/etc/bind/named.conf</p><pre><code>options {   listen-on port 53 { any; };      //定义DNS监听在哪个端口上   directory &quot;/etc/bind/zone&quot;;   //指定DNS区域文件存放目录   pid-file &quot;/etc/bind/var/named.pid&quot;;   //指定named进程pid文件路径   allow-query { any; };          //允许哪些主机可以使用该DNS来解析   Dump-file &quot;/etc/bind/var/binddump.db&quot;;     //缓存转储位置   Statistics-file &quot;/etc/bind/stats/named_stats&quot;;   //记录统计信息的文件   zone-statistics yes;  //收集在服务器所有域的统计数据, 这些统计数据可以通过使用rndc stats来访问   memstatistics-file &quot;/etc/bind/stats/mem_stats&quot;;     //记录内存使用的统计信息   empty-zones-enable yes;      forwarders {114.114.114.114;8.8.8.8;};   //定义上游DNS[需要配置root hint顶级域]};key &quot;rndc-key&quot; {               //注：这个key部分是通过rndc-confgen命令生成的配置，贴过来        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};controls {              //配置rndc权限与端口       inet 127.0.0.1 port 953       allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };};logging {  channel warning {        //warnning可以改为default_debug（默认）。     file &quot;/var/log/named/named.log&quot; versions 10 size 10m;    //日志文件路径/版本/大小     severity warning;     //如果warnning改为default_debug后，此处可以改为severity dynamic     print-category yes;   //日志中是否需要写入日志类别     print-severity yes;   //日志中是否需要写入消息级别     print-time yes;       //日志中是否需要写入时间    };     channel general_dns {               //绑定其他log channel通道，以下保持默认即可。     file &quot;/var/log/named/named2.log&quot; versions 10 size 100m;     severity info;         print-category yes;      print-severity yes;     print-time yes;    };  category default {    warning;  };  category queries {    general_dns;  };};include &quot;/etc/bind/view/*.conf&quot;;   #加载Bind视图文件</code></pre><p>编辑/etc/bind/rndc.key</p><pre><code>key &quot;rndc-key&quot; {               //与主DNS保持一致        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};</code></pre><p>编辑/etc/bind/rndc.conf</p><pre><code>key &quot;rndc-key&quot; {               //与主DNS保持一致        algorithm hmac-md5;        secret &quot;7RJEIT7ztJyXy9A8ZlvZJA==&quot;;};options {        default-key &quot;rndc-key&quot;;        default-server 127.0.0.1;        default-port 953;};</code></pre><p>创建相关目录并授权</p><pre><code>mkdir -p /etc/bind/zonemkdir -p /etc/bind/varmkdir -p /etc/bind/statsmkdir -p /etc/bind/viewmkdir -p /var/log/namedwget https://www.internic.net/domain/named.rootchown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>配置Bind视图</p><pre><code>vim /etc/bind/view/view.conf</code></pre><pre><code>view &quot;View&quot; {                  //配置bind视图功能  zone &quot;test.org&quot; {        type    slave;          //正向区域文件配置为slave模式        masters { 10.0.10.101; };  //此处要指定masterIP，可以添加多个        file    &quot;slave.test.org.zone&quot;;  //不需要对其创建，服务启动后，会自动同步过来  };  zone &quot;10.0.10.in-addr.arpa&quot; {             type    slave;                 //反向区域文件配置为slave模式        masters { 10.0.10.101; };    //此处要指定masterIP，可以添加多个        file    &quot;slave.10.0.10.zone&quot;;     //不需要对其创建，服务启动后，会自动同步过来   };   zone &quot;.&quot; in {         type hint;         file &quot;/etc/bind/named.root&quot;;   }};注：参数释义(1)区域类型有type：｛hint（根）| master（主dns）| slave（辅助DNS）| forward（转发）｝(2)file 可以指定一个文件路径</code></pre><p>最后再次修改目录权限</p><pre><code>chown -R named.named /etc/bindchown -R named.named /var/log</code></pre><p>启动服务</p><pre><code>named.conf配置文件检查named-checkconf /etc/bind/named.conf</code></pre><p>named启动脚本[建议使用supervisor]</p><pre><code>/etc/init.d/named</code></pre><pre><code>#!/bin/bash # named a network name service. # chkconfig: 345 35 75 # description: a name serverif [ `id -u` -ne 0 ];then   echo &quot;ERROR:For bind to port 53,must run as root.&quot;    exit 1ficase &quot;$1&quot; instart)        if [ -x /usr/sbin/named ]; then  /usr/sbin/named -c /etc/bind/named.conf -u named &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server started&#39;         fi      ;;stop)       kill `cat /etc/named/var/named.pid` &amp;&amp; echo . &amp;&amp; echo &#39;BIND9.10 server stopped&#39;        ;;restart)       echo .        echo &quot;Restart BIND9.10 server&quot;        $0 stop       sleep 10       $0 start       ;;reload)      /usr/sbin/rndc reload      ;;status)     /usr/sbin/rndc status     ;;*)     echo &quot;$0 start | stop | restart |reload |status&quot;      ;;esac</code></pre><pre><code>chmod  755  /etc/init.d/namedchkconfig --add namedchkconfig named on/etc/init.d/named start /etc/init.d/named status</code></pre><h4 id="进程查看-1"><a href="#进程查看-1" class="headerlink" title="进程查看"></a>进程查看</h4><pre><code>[root@ns2 ~]# netstat -lntup|grep 53</code></pre><h4 id="日常管理-1"><a href="#日常管理-1" class="headerlink" title="日常管理"></a>日常管理</h4><pre><code>/etc/init.d/named start 启动服务rndc status  查看服务运行情况rndc reload  重新加载区域文件rndc stop    停止DNS服务</code></pre><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><pre><code>dig 分别测试主从DNS解析是否正常。接下来就可以进行压力测试了，工具很多，不进行列举</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>正向区域zone-格式参考</p><pre><code>$ORIGIN test.org.     ; //设置默认域$TTL 38404         ; default time to live@   IN   SOA     web.moxiu. admin.moxiu. (    20180814        10800        3600        604800        38400 )        NS      10.0.10.101.      ; 主DNS IP或域名        IN      NS      ns1.moxiu.        IN      NS      ns2.moxiu.ns1     IN      A       10.0.10.101ns2     IN      A       10.0.10.102cname   IN      CNAME   www.baidu.com.cwl     IN      A       1.1.1.1cwl2    IN      A       7.7.7.7</code></pre><pre><code>其中:  $ORIGIN test.org.     ; //设置默认域这样的话，域名解析的时候需要：dig  cw1.test.org ; 当然默认域，也可以设置为&quot;teet.&quot;, 解析的时候这样：dig  cw1.teet.  也就是说解析二级域是由自己在这里控制的【顶级域是.】</code></pre><h2 id="关于优化"><a href="#关于优化" class="headerlink" title="关于优化"></a>关于优化</h2><pre><code>此配置文件能满足基本需求，如果需要将Bind效率提升，需要对参数进行优化。不在本篇讨论范围，Google解决。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;之前没有独立写过Bind主从同步，只有与LVS相结合的文章，故今天给补充完善。
本次测试版本：bind-9.10.8-P1.tar.gz     
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="bind" scheme="https://wuyanteng.github.io/tags/bind/"/>
    
      <category term="bind9" scheme="https://wuyanteng.github.io/tags/bind9/"/>
    
      <category term="bind主从" scheme="https://wuyanteng.github.io/tags/bind%E4%B8%BB%E4%BB%8E/"/>
    
      <category term="DNS" scheme="https://wuyanteng.github.io/tags/DNS/"/>
    
      <category term="迭代DNS" scheme="https://wuyanteng.github.io/tags/%E8%BF%AD%E4%BB%A3DNS/"/>
    
      <category term="root hint" scheme="https://wuyanteng.github.io/tags/root-hint/"/>
    
  </entry>
  
  <entry>
    <title>编写expect交互类脚本</title>
    <link href="https://wuyanteng.github.io/2018/08/09/%E7%BC%96%E5%86%99expect%E4%BA%A4%E4%BA%92%E7%B1%BB%E8%84%9A%E6%9C%AC/"/>
    <id>https://wuyanteng.github.io/2018/08/09/编写expect交互类脚本/</id>
    <published>2018-08-09T08:36:31.000Z</published>
    <updated>2018-08-09T11:35:55.054Z</updated>
    
    <content type="html"><![CDATA[<pre><code>有时候业务中免不了编写交互式输入账号密码的脚本，今天正好有需求，特意记录下</code></pre><h5 id="expect作用介绍"><a href="#expect作用介绍" class="headerlink" title="expect作用介绍"></a>expect作用介绍</h5><pre><code>expect就是用来做交互用的，基本任何交互登录的场合都能使用，不过需要安装expect包</code></pre><a id="more"></a><h5 id="expect包安装"><a href="#expect包安装" class="headerlink" title="expect包安装"></a>expect包安装</h5><pre><code>yum install -y tcl expect expect-devel</code></pre><h5 id="确认expect路径"><a href="#确认expect路径" class="headerlink" title="确认expect路径"></a>确认expect路径</h5><pre><code>[root@localhost]# which expect/usr/bin/expect</code></pre><h5 id="脚本语法-示例"><a href="#脚本语法-示例" class="headerlink" title="脚本语法,示例"></a>脚本语法,示例</h5><pre><code>[root@localhost]# cat test.et#!/usr/bin/expect                      #与bash类似,声明脚本类型set timeout 30                         #设定超时时间为30sspawn ssh garywu@192.168.1.1 -p 7113   #spawn后面接要执行的命令expect &quot;password:&quot;                     #捕捉交互返回的 password：关键字send &quot;garywu123\r&quot;                     #发送一个密码字符串interact                            #表示执行完留在远程控制台；不加这句则执行完后返回本地控制台 </code></pre><h5 id="给脚本增加执行权限"><a href="#给脚本增加执行权限" class="headerlink" title="给脚本增加执行权限"></a>给脚本增加执行权限</h5><pre><code>chmod +x test.et</code></pre><h5 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="!需要注意的点"></a>!需要注意的点</h5><pre><code>不能按照习惯来用sh autosu.sh来这行expect的程序，会提示找不到命令，如下：autosu.sh: line 3: spawn: command not foundcouldn&#39;t read file &quot;password:&quot;: no such file or directoryautosu.sh: line 5: send: command not foundautosu.sh: line 6: interact: command not found因为expect用的不是bash所以会报错。执行的时候直接./autosu.sh就可以了。～切记！</code></pre><h5 id="使用ssh和expect监控RouterOS—生产环境示例："><a href="#使用ssh和expect监控RouterOS—生产环境示例：" class="headerlink" title="使用ssh和expect监控RouterOS—生产环境示例："></a>使用ssh和expect监控RouterOS—生产环境示例：</h5><pre><code>#!/bin/bashHOSTNAME=&quot;192.168.1.1&quot;PORT=&quot;22&quot;USER=&quot;xxx&quot;PASS=&quot;xxxxx&quot;TMP=$(mktemp)#创建expect脚本cat &gt; $TMP &lt;&lt; EOF set timeout -1spawn ssh -p$PORT $USER@$HOSTNAMEmatch_max 100000expect -exact &quot;password:&quot;send -- &quot;$PASS\r&quot;sleep 1expect &quot; &gt; &quot;send -- &quot;/system resource print\r&quot;expect &quot; &gt; &quot;send -- &quot;quit\r&quot;expect eofEOF#运行expect脚本stat_file=/tmp/ros_status.log/usr/bin/expect -f $TMP &gt;$stat_filerm $TMP</code></pre><pre><code>注: 脚本运行完毕，RouterOS运行状态信息会出现在/tmp/ros_status.log中，通过grep或awk取出想要的值，然后自定义zabbix key即可，也可以在zabbix中配置图形展示。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;有时候业务中免不了编写交互式输入账号密码的脚本，今天正好有需求，特意记录下
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;expect作用介绍&quot;&gt;&lt;a href=&quot;#expect作用介绍&quot; class=&quot;headerlink&quot; title=&quot;expect作用介绍&quot;&gt;&lt;/a&gt;expect作用介绍&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;expect就是用来做交互用的，基本任何交互登录的场合都能使用，不过需要安装expect包
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="高级运维" scheme="https://wuyanteng.github.io/tags/%E9%AB%98%E7%BA%A7%E8%BF%90%E7%BB%B4/"/>
    
      <category term="shell" scheme="https://wuyanteng.github.io/tags/shell/"/>
    
      <category term="ssh" scheme="https://wuyanteng.github.io/tags/ssh/"/>
    
      <category term="expect" scheme="https://wuyanteng.github.io/tags/expect/"/>
    
      <category term="自动输入密码" scheme="https://wuyanteng.github.io/tags/%E8%87%AA%E5%8A%A8%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/"/>
    
      <category term="交互式" scheme="https://wuyanteng.github.io/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
      <category term="非交互" scheme="https://wuyanteng.github.io/tags/%E9%9D%9E%E4%BA%A4%E4%BA%92/"/>
    
      <category term="使用ssh和expect监控RouterOS" scheme="https://wuyanteng.github.io/tags/%E4%BD%BF%E7%94%A8ssh%E5%92%8Cexpect%E7%9B%91%E6%8E%A7RouterOS/"/>
    
  </entry>
  
</feed>
